digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 290"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-220"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 codeblock_7 codeblock_8 section_9 section_10 section_11}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 codeblock_7 codeblock_8 section_9 section_10 section_11}

header_2 [label="1 : Historian"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

codeblock_7 [label="code block 16-25"]

codeblock_8 [label="code block 27-29"]

section_9 [label="section: 32-130"]

section_10 [label="section: 175-220"]

section_11 [label="section: 221-265"]


// END RANK section_1

header_2 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Historian"]
// END RANK header_2

prose_3 -> { raw_13}
{rank=same; raw_13}

raw_13 [label="raw"]


// END RANK prose_3

raw_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


This module is responsible for REPL history.
"]
// END RANK raw_13

prose_4 -> { raw_15}
{rank=same; raw_15}

raw_15 [label="raw"]


// END RANK prose_4

raw_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Eventually this will include persisting and restoring from a SQLite database,
fuzzy searching, and variable cacheing.
"]
// END RANK raw_15

prose_5 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


// END RANK prose_5

raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Currently does the basic job of retaining history and not letting subsequent
edits munge it.
"]
// END RANK raw_17

prose_6 -> { raw_19}
{rank=same; raw_19}

raw_19 [label="raw"]


// END RANK prose_6

raw_19 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Next step: now that we clone a new linebuf each time, we have an immutable
record.  We should store the line as a string, to facilitate fuzzy matching.

"]
// END RANK raw_19

codeblock_7 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Linebuf = require \"linebuf\"
local sql     = require \"sqlayer\"
local color   = require \"color\"
local L       = require \"lpeg\"
local format  = assert (string.format)
local sub     = assert (string.sub)
local reverse = assert (table.reverse)
assert(meta)"]
// END RANK codeblock_7

codeblock_8 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Historian = meta {}"]
// END RANK codeblock_8

section_9 -> { header_23 prose_24 section_25 section_26 section_27}
{rank=same; header_23 prose_24 section_25 section_26 section_27}

header_23 [label="2 : Persistence"]

prose_24 [label="prose"]

section_25 [label="section: 35-96"]

section_26 [label="section: 97-130"]

section_27 [label="section: 131-174"]


// END RANK section_9

header_23 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Persistence"]
// END RANK header_23

prose_24 -> { raw_29}
{rank=same; raw_29}

raw_29 [label="raw"]


// END RANK prose_24

raw_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
// END RANK raw_29

section_25 -> { header_31 prose_32 codeblock_33}
{rank=same; header_31 prose_32 codeblock_33}

header_31 [label="3 : SQLite battery"]

prose_32 [label="prose"]

codeblock_33 [label="code block 37-94"]


// END RANK section_25

header_31 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** SQLite battery"]
// END RANK header_31

prose_32 -> { raw_35}
{rank=same; raw_35}

raw_35 [label="raw"]


// END RANK prose_32

raw_35 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_35

codeblock_33 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Historian.HISTORY_LIMIT = 1000

local create_repl_table = [[
CREATE TABLE IF NOT EXISTS repl (
line_id INTEGER PRIMARY KEY AUTOINCREMENT,
project TEXT,
line TEXT,
time DATETIME DEFAULT CURRENT_TIMESTAMP);
]]

local create_result_table = [[
CREATE TABLE IF NOT EXISTS results (
result_id INTEGER PRIMARY KEY AUTOINCREMENT,
line_id INTEGER,
repr text NOT NULL,
value blob,
FOREIGN KEY (line_id)
   REFERENCES repl (line_id)
   ON DELETE CASCADE);
]]

local insert_line_stmt = [[
INSERT INTO repl (project, line) VALUES (:project, :line);
]]

local insert_result_stmt = [[
INSERT INTO results (line_id, repr) VALUES (:line_id, :repr);
]]

local get_tables = [[
SELECT name FROM sqlite_master WHERE type='table';
]]

local get_recent = [[
SELECT line FROM repl
   WHERE project = %s
   ORDER BY time
   DESC LIMIT %d;
]]

local home_dir = io.popen(\"echo $HOME\", \"r\"):read(\"*a\"):sub(1, -2)

local bridge_home = io.popen(\"echo $BRIDGE_HOME\", \"r\"):read(\"*a\"):sub(1, -2)
Historian.bridge_home = bridge_home ~= \"\" and bridge_home
                        or home_dir .. \"/.bridge\"

Historian.project = io.popen(\"pwd\", \"r\"):read(\"*a\"):sub(1, -2)

local function has(table, name)
   for _,v in ipairs(table) do
      if name == v then
         return true
      end
   end
   return false
end"]
// END RANK codeblock_33

section_26 -> { header_38 prose_39 codeblock_40}
{rank=same; header_38 prose_39 codeblock_40}

header_38 [label="3 : Historian:load()"]

prose_39 [label="prose"]

codeblock_40 [label="code block 101-128"]


// END RANK section_26

header_38 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:load()"]
// END RANK header_38

prose_39 -> { raw_42}
{rank=same; raw_42}

raw_42 [label="raw"]


// END RANK prose_39

raw_42 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Brings up the project history and (eventually) results and user config.
"]
// END RANK raw_42

codeblock_40 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.load(historian)
   local conn = sql.open(historian.bridge_home)
   historian.conn = conn
   conn:exec \"PRAGMA foreign_keys = ON;\"
   local table_names = conn:exec(get_tables)
   conn:exec(create_result_table)
   if not table_names or not has(table_names.name, \"repl\") then
      local success, err = sql.pexec(conn, create_repl_table)
      -- success is nil for creation, false for error
      if success == false then
         error(err)
      end
   end
   historian.insert_line_stmt = conn:prepare(insert_line_stmt)
   historian.insert_result_stmt = conn:prepare(insert_result_stmt)
   local pop_stmt = sql.format(get_recent, historian.project,
                        historian.HISTORY_LIMIT)
   local values, err = sql.pexec(conn, pop_stmt)
   if values then
      for i,v in ipairs(reverse(values[1])) do
         historian[i] = Linebuf(v)
      end
      historian.cursor = #historian
      historian.up = false
   end
end"]
// END RANK codeblock_40

section_27 -> { header_45 prose_46 prose_47 prose_48 prose_49 codeblock_50}
{rank=same; header_45 prose_46 prose_47 prose_48 prose_49 codeblock_50}

header_45 [label="3 : Historian:persist(linebuf)"]

prose_46 [label="prose"]

prose_47 [label="prose"]

prose_48 [label="prose"]

prose_49 [label="prose"]

codeblock_50 [label="code block 146-172"]


// END RANK section_27

header_45 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:persist(linebuf)"]
// END RANK header_45

prose_46 -> { raw_52}
{rank=same; raw_52}

raw_52 [label="raw"]


// END RANK prose_46

raw_52 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Persists a line and results to store.
"]
// END RANK raw_52

prose_47 -> { raw_54}
{rank=same; raw_54}

raw_54 [label="raw"]


// END RANK prose_47

raw_54 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The hooks are in place to persist the results. I'm starting with a string
representation; the goal is to provide the sense of persistence across
sessions, and supplement that over time with better and better approximations.
"]
// END RANK raw_54

prose_48 -> { raw_56 prespace_57 literal_58 raw_59 prespace_60 literal_61 raw_62}
{rank=same; raw_56 prespace_57 literal_58 raw_59 prespace_60 literal_61 raw_62}

raw_56 [label="raw"]

prespace_57 [label="prespace"]

literal_58 [label="literal"]

raw_59 [label="raw"]

prespace_60 [label="prespace"]

literal_61 [label="literal"]

raw_62 [label="raw"]


// END RANK prose_48

raw_56 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To really nail it down will require semantic analysis and hence thorough
parsing.  General-purpose persistence tools belong in"]
// END RANK raw_56

prespace_57 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_57

literal_58 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sqlayer"]
// END RANK literal_58

raw_59 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", which will
merge with our increasingly-modified"]
// END RANK raw_59

prespace_60 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_60

literal_61 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sqlite"]
// END RANK literal_61

raw_62 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" bindings.
"]
// END RANK raw_62

prose_49 -> { raw_70}
{rank=same; raw_70}

raw_70 [label="raw"]


// END RANK prose_49

raw_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Medium-term goal is to hash any Lua object in a way that will resolve to a
common value for any identical semantics.
"]
// END RANK raw_70

codeblock_50 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.persist(historian, linebuf, results)
   local lb = tostring(linebuf)
   historian.insert_line_stmt:bindkv { project = historian.project,
                                  line    = lb }
   local err = historian.insert_line_stmt:step()
   if not err then
      historian.insert_line_stmt:clearbind():reset()
   else
      error(err)
   end
   local line_id = sql.lastRowId(historian.conn)
   if results and type(results) == \"table\" then
      for _,v in ipairs(results) do
         -- insert result repr
         historian.insert_result_stmt:bindkv { line_id = line_id,
                                               repr = color.ts(v) }
         err = historian.insert_result_stmt:step()
         if not err then
            historian.insert_result_stmt:clearbind():reset()
         end
      end
   end

   return true
end"]
// END RANK codeblock_50

section_10 -> { header_73 prose_74 codeblock_75}
{rank=same; header_73 prose_74 codeblock_75}

header_73 [label="2 : Historian:search(frag)"]

prose_74 [label="prose"]

codeblock_75 [label="code block 177-218"]


// END RANK section_10

header_73 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Historian:search(frag)"]
// END RANK header_73

prose_74 -> { raw_77}
{rank=same; raw_77}

raw_77 [label="raw"]


// END RANK prose_74

raw_77 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_77

codeblock_75 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local P, match = L.P, L.match

-- second_best is broke and I don't know why
-- also this fails on a single key search >.<
local function fuzz_patt(frag)
   frag = type(frag) == \"string\" and codepoints(frag) or frag
   local patt =        (P(1) - P(frag[1]))^0
   for i = 1 , #frag - 1 do
      local v = frag[i]
      patt = patt * (P(v) * (P(1) - P(frag[i + 1]))^0)
   end
   patt = patt * P(frag[#frag])
   return patt
end

function Historian.search(historian, frag)
   local collection = {}
   local best = true
   local patt = fuzz_patt(frag)
   for i = #historian, 1, -1 do
      local score = match(patt, tostring(historian[i]))
      if score then
         collection[#collection + 1] = tostring(historian[i])
      end
   end
   if #collection == 0 then
      -- try the transpose
      best = false
      local slip = sub(frag, 1, -3) .. sub(frag, -1, -1) .. sub(frag, -2, -2)
      local second = fuzz_patt(slip)
      for i = #historian, 1, -1 do
         local score = match(second, tostring(historian[i]))
         if score then
            collection[#collection + 1] = tostring(historian[i])
         end
      end
   end

   return collection, best
end"]
// END RANK codeblock_75

section_11 -> { header_80 prose_81 codeblock_82 section_83 section_84}
{rank=same; header_80 prose_81 codeblock_82 section_83 section_84}

header_80 [label="2 : Historian:prev()"]

prose_81 [label="prose"]

codeblock_82 [label="code block 223-235"]

section_83 [label="section: 238-265"]

section_84 [label="section: 266-290"]


// END RANK section_11

header_80 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Historian:prev()"]
// END RANK header_80

prose_81 -> { raw_86}
{rank=same; raw_86}

raw_86 [label="raw"]


// END RANK prose_81

raw_86 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_86

codeblock_82 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.prev(historian)
   if historian.cursor == 0 then
      return Linebuf()
   end
   local Δ = historian.cursor > 1 and 1 or 0
   local linebuf = historian[historian.cursor - Δ]
   local result = historian.results[linebuf]
   historian.cursor = historian.cursor - Δ
   linebuf.cursor = #linebuf.line + 1
   return linebuf:clone(), result
end"]
// END RANK codeblock_82

section_83 -> { header_89 prose_90 codeblock_91}
{rank=same; header_89 prose_90 codeblock_91}

header_89 [label="3 : Historian:next()"]

prose_90 [label="prose"]

codeblock_91 [label="code block 243-263"]


// END RANK section_83

header_89 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:next()"]
// END RANK header_89

prose_90 -> { raw_93 prespace_94 literal_95 raw_96}
{rank=same; raw_93 prespace_94 literal_95 raw_96}

raw_93 [label="raw"]

prespace_94 [label="prespace"]

literal_95 [label="literal"]

raw_96 [label="raw"]


// END RANK prose_90

raw_93 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Returns the next linebuf in history, and a second flag to tell the"]
// END RANK raw_93

prespace_94 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_94

literal_95 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="modeselektor"]
// END RANK literal_95

raw_96 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" it might be time for a new one.
"]
// END RANK raw_96

codeblock_91 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.next(historian)
   local Δ = historian.cursor < #historian and 1 or 0
   if historian.cursor == 0 then
      return Linebuf()
   end
   local linebuf= historian[historian.cursor + Δ]
   local result = historian.results[linebuf]
   if not linebuf then
      return Linebuf()
   end
   historian.cursor = historian.cursor + Δ
   linebuf.cursor = #linebuf.line + 1
   if not (Δ > 0) and #linebuf.line > 0 then
      historian.cursor = #historian + 1
      return linebuf:clone(), nil, true
   else
      return linebuf:clone(), result, false
   end
end"]
// END RANK codeblock_91

section_84 -> { header_102 prose_103 codeblock_104 codeblock_105 codeblock_106}
{rank=same; header_102 prose_103 codeblock_104 codeblock_105 codeblock_106}

header_102 [label="3 : Historian:append()"]

prose_103 [label="prose"]

codeblock_104 [label="code block 268-275"]

codeblock_105 [label="code block 277-286"]

codeblock_106 [label="code block 288-290"]


// END RANK section_84

header_102 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:append()"]
// END RANK header_102

prose_103 -> { raw_108}
{rank=same; raw_108}

raw_108 [label="raw"]


// END RANK prose_103

raw_108 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_108

codeblock_104 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.append(historian, linebuf, results)
   historian[#historian + 1] = linebuf
   historian.cursor = #historian
   historian:persist(linebuf, results)
   return true
end"]
// END RANK codeblock_104

codeblock_105 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new()
   local historian = meta(Historian)
   historian:load()
   -- This will also be load()ed once we have the tables for it
   historian.results = {} -- keyed by linebuf
   return historian
end
Historian.idEst = new"]
// END RANK codeblock_105

codeblock_106 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]
// END RANK codeblock_106


}
