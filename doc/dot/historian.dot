digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 557"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-455"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 codeblock_7 codeblock_8 section_9 section_10 section_11 section_12}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 codeblock_7 codeblock_8 section_9 section_10 section_11 section_12}

header_2 [label="1 : Historian"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

codeblock_7 [label="code block 16-27"]

codeblock_8 [label="code block 29-31"]

section_9 [label="section: 34-240"]

section_10 [label="section: 292-327"]

section_11 [label="section: 394-455"]

section_12 [label="section: 456-522"]


// END RANK section_1

header_2 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Historian"]
// END RANK header_2

prose_3 -> { raw_14}
{rank=same; raw_14}

raw_14 [label="raw"]


// END RANK prose_3

raw_14 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


This module is responsible for REPL history.
"]
// END RANK raw_14

prose_4 -> { raw_16}
{rank=same; raw_16}

raw_16 [label="raw"]


// END RANK prose_4

raw_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Eventually this will include persisting and restoring from a SQLite database,
fuzzy searching, and variable cacheing.
"]
// END RANK raw_16

prose_5 -> { raw_18}
{rank=same; raw_18}

raw_18 [label="raw"]


// END RANK prose_5

raw_18 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Currently does the basic job of retaining history and not letting subsequent
edits munge it.
"]
// END RANK raw_18

prose_6 -> { raw_20}
{rank=same; raw_20}

raw_20 [label="raw"]


// END RANK prose_6

raw_20 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Next step: now that we clone a new txtbuf each time, we have an immutable
record.  We should store the line as a string, to facilitate fuzzy matching.

"]
// END RANK raw_20

codeblock_7 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Txtbuf  = require \"txtbuf\"
local Rainbuf = require \"rainbuf\"
local sql     = require \"sqlayer\"
local color   = require \"color\"
local L       = require \"lpeg\"
local format  = assert (string.format)
local sub     = assert (string.sub)
local codepoints = assert(string.codepoints, \"must have string.codepoints\")
local reverse = assert (table.reverse)
assert(meta)"]
// END RANK codeblock_7

codeblock_8 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Historian = meta {}"]
// END RANK codeblock_8

section_9 -> { header_24 prose_25 section_26 section_27 section_28 section_29}
{rank=same; header_24 prose_25 section_26 section_27 section_28 section_29}

header_24 [label="2 : Persistence"]

prose_25 [label="prose"]

section_26 [label="section: 38-143"]

section_27 [label="section: 144-229"]

section_28 [label="section: 230-240"]

section_29 [label="section: 241-291"]


// END RANK section_9

header_24 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Persistence"]
// END RANK header_24

prose_25 -> { raw_31}
{rank=same; raw_31}

raw_31 [label="raw"]


// END RANK prose_25

raw_31 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This defines the persistence model for bridge.
"]
// END RANK raw_31

section_26 -> { header_33 prose_34 codeblock_35}
{rank=same; header_33 prose_34 codeblock_35}

header_33 [label="3 : SQLite battery"]

prose_34 [label="prose"]

codeblock_35 [label="code block 40-141"]


// END RANK section_26

header_33 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** SQLite battery"]
// END RANK header_33

prose_34 -> { raw_37}
{rank=same; raw_37}

raw_37 [label="raw"]


// END RANK prose_34

raw_37 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_37

codeblock_35 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Historian.HISTORY_LIMIT = 2000

local create_project_table = [[
CREATE TABLE IF NOT EXISTS project (
project_id INTEGER PRIMARY KEY AUTOINCREMENT,
directory TEXT UNIQUE,
time DATETIME DEFAULT CURRENT_TIMESTAMP );
]]

local create_repl_table = [[
CREATE TABLE IF NOT EXISTS repl (
line_id INTEGER PRIMARY KEY AUTOINCREMENT,
project INTEGER,
line TEXT,
time DATETIME DEFAULT CURRENT_TIMESTAMP,
FOREIGN KEY (project)
   REFERENCES project (project_id)
   ON DELETE CASCADE );
]]

local create_result_table = [[
CREATE TABLE IF NOT EXISTS result (
result_id INTEGER PRIMARY KEY AUTOINCREMENT,
line_id INTEGER,
repr text NOT NULL,
value blob,
FOREIGN KEY (line_id)
   REFERENCES repl (line_id)
   ON DELETE CASCADE );
]]

local create_session_table = [[
CREATE TABLE IF NOT EXISTS session (
session_id INTEGER PRIMARY KEY AUTOINCREMENT,
name TEXT,
project INTEGER,
-- These two are line_ids
start INTEGER NOT NULL,
end INTEGER,
test BOOLEAN,
sha TEXT,
FOREIGN KEY (project)
   REFERENCES project (project_id)
   ON DELETE CASCADE );
]]

local insert_line = [[
INSERT INTO repl (project, line) VALUES (:project, :line);
]]

local insert_result = [[
INSERT INTO result (line_id, repr) VALUES (:line_id, :repr);
]]

local insert_project = [[
INSERT INTO project (directory) VALUES (:dir);
]]

local get_tables = [[
SELECT name FROM sqlite_master WHERE type='table';
]]

local get_recent = [[
SELECT CAST (line_id AS REAL), line FROM repl
   WHERE project = %d
   ORDER BY time
   DESC LIMIT %d;
]]

local get_project = [[
SELECT project_id FROM project
   WHERE directory = %s;
]]

local get_reprs = [[
SELECT CAST (repl.line_id AS REAL), result.repr
FROM repl
LEFT OUTER JOIN result
ON repl.line_id = result.line_id
WHERE repl.project = %d
ORDER BY result.result_id
DESC LIMIT %d;
]]

local home_dir = io.popen(\"echo $HOME\", \"r\"):read(\"*a\"):sub(1, -2)

local bridge_home = io.popen(\"echo $BRIDGE_HOME\", \"r\"):read(\"*a\"):sub(1, -2)
Historian.bridge_home = bridge_home ~= \"\" and bridge_home
                        or home_dir .. \"/.bridge\"

Historian.project = io.popen(\"pwd\", \"r\"):read(\"*a\"):sub(1, -2)

local function has(table, name)
   for _,v in ipairs(table) do
      if name == v then
         return true
      end
   end
   return false
end"]
// END RANK codeblock_35

section_27 -> { header_40 prose_41 prose_42 structure_43 prose_44 codeblock_45}
{rank=same; header_40 prose_41 prose_42 structure_43 prose_44 codeblock_45}

header_40 [label="3 : Historian:load()"]

prose_41 [label="prose"]

prose_42 [label="prose"]

structure_43 [label="structure"]

prose_44 [label="prose"]

codeblock_45 [label="code block 158-227"]


// END RANK section_27

header_40 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:load()"]
// END RANK header_40

prose_41 -> { raw_47}
{rank=same; raw_47}

raw_47 [label="raw"]


// END RANK prose_41

raw_47 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Brings up the project history and results, and (eventually) user config.
"]
// END RANK raw_47

prose_42 -> { raw_49}
{rank=same; raw_49}

raw_49 [label="raw"]


// END RANK prose_42

raw_49 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Most of the complexity serves to make a simple key/value relationship
between the regenerated txtbufs and their associated result history.
"]
// END RANK raw_49

structure_43 -> { hashline_51}
{rank=same; hashline_51}

hashline_51 [label="hashline"]


// END RANK structure_43

hashline_51 -> { hashtag_52}
{rank=same; hashtag_52}

hashtag_52 [label="hashtag"]


// END RANK hashline_51

hashtag_52 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="todo"]
// END RANK hashtag_52

prose_44 -> { raw_54}
{rank=same; raw_54}

raw_54 [label="raw"]


// END RANK prose_44

raw_54 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
the results never get used.
"]
// END RANK raw_54

codeblock_45 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.load(historian)
   local conn = sql.open(historian.bridge_home)
   historian.conn = conn
   -- Set up bridge tables
   conn.pragma.foreign_keys(true)
   conn:exec(create_project_table)
   conn:exec(create_result_table)
   conn:exec(create_repl_table)
   conn:exec(create_session_table)
   -- Retrive project id
   local proj_val, proj_row = sql.pexec(conn,
                                  sql.format(get_project, historian.project),
                                  \"i\")
   if not proj_val then
      local ins_proj_stmt = conn:prepare(insert_project)
      ins_proj_stmt:bindkv {dir = historian.project}
      proj_val, proj_row = ins_proj_stmt:step()
      -- retry
      proj_val, proj_row = sql.pexec(conn,
                              sql.format(get_project, historian.project),
                              \"i\")
      if not proj_val then
         error \"Could not create project in .bridge\"
      end
   end

   local project_id = proj_val[1][1]
   historian.project_id = project_id
   -- Create insert prepared statements
   historian.insert_line = conn:prepare(insert_line)
   historian.insert_result = conn:prepare(insert_result)
   -- Retrieve history
   local pop_str = sql.format(get_recent, project_id,
                        historian.HISTORY_LIMIT)
   local repl_val, repl_row = sql.pexec(conn, pop_str, \"i\")
   local res_str = sql.format(get_reprs, project_id,
                       historian.HISTORY_LIMIT * 2)
   local res_val, res_row = sql.pexec(conn, res_str, \"i\")
   if repl_val and res_val then
      local lines = reverse(repl_val[2])
      local line_ids = reverse(repl_val[1])
      local repl_map = {}
      for i, v in ipairs(lines) do
         local buf = Txtbuf(v)
         historian[i] = buf
         repl_map[line_ids[i]] = buf
      end
      historian.cursor = #historian
      -- reuse line_id var for foreign keys
      line_ids = res_val[1]
      local reprs = res_val[2]
      -- This is keyed by txtbuf with a string value.
      local result_map = {}
      for i = 1, #reprs do
         local buf = repl_map[line_ids[i]]
         if buf then
            local result = result_map[buf] or {frozen = true}
            result[#result + 1] = reprs[i]
            result.n = #result -- for compat with nil in live use
            result_map[buf] = result
         end
      end
      historian.results = result_map
   else
      historian.results = {}
      historian.cursor = 0
   end
end"]
// END RANK codeblock_45

section_28 -> { header_57 prose_58 prose_59 codeblock_60}
{rank=same; header_57 prose_58 prose_59 codeblock_60}

header_57 [label="3 : Historian:restore_session(modeS, session)"]

prose_58 [label="prose"]

prose_59 [label="prose"]

codeblock_60 [label="code block 236-238"]


// END RANK section_28

header_57 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:restore_session(modeS, session)"]
// END RANK header_57

prose_58 -> { raw_62}
{rank=same; raw_62}

raw_62 [label="raw"]


// END RANK prose_58

raw_62 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

If there is an open session, we want to replay it.
"]
// END RANK raw_62

prose_59 -> { raw_64}
{rank=same; raw_64}

raw_64 [label="raw"]


// END RANK prose_59

raw_64 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To do this, we need to borrow the modeselektor.
"]
// END RANK raw_64

codeblock_60 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK codeblock_60

section_29 -> { header_67 prose_68 prose_69 prose_70 prose_71 codeblock_72}
{rank=same; header_67 prose_68 prose_69 prose_70 prose_71 codeblock_72}

header_67 [label="3 : Historian:persist(txtbuf)"]

prose_68 [label="prose"]

prose_69 [label="prose"]

prose_70 [label="prose"]

prose_71 [label="prose"]

codeblock_72 [label="code block 256-289"]


// END RANK section_29

header_67 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:persist(txtbuf)"]
// END RANK header_67

prose_68 -> { raw_74}
{rank=same; raw_74}

raw_74 [label="raw"]


// END RANK prose_68

raw_74 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Persists a line and results to store.
"]
// END RANK raw_74

prose_69 -> { raw_76}
{rank=same; raw_76}

raw_76 [label="raw"]


// END RANK prose_69

raw_76 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The hooks are in place to persist the results. I'm starting with a string
representation; the goal is to provide the sense of persistence across
sessions, and supplement that over time with better and better approximations.
"]
// END RANK raw_76

prose_70 -> { raw_78 prespace_79 literal_80 raw_81 prespace_82 literal_83 raw_84}
{rank=same; raw_78 prespace_79 literal_80 raw_81 prespace_82 literal_83 raw_84}

raw_78 [label="raw"]

prespace_79 [label="prespace"]

literal_80 [label="literal"]

raw_81 [label="raw"]

prespace_82 [label="prespace"]

literal_83 [label="literal"]

raw_84 [label="raw"]


// END RANK prose_70

raw_78 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To really nail it down will require semantic analysis and hence thorough
parsing.  General-purpose persistence tools belong in"]
// END RANK raw_78

prespace_79 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_79

literal_80 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sqlayer"]
// END RANK literal_80

raw_81 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", which will
merge with our increasingly-modified"]
// END RANK raw_81

prespace_82 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_82

literal_83 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sqlite"]
// END RANK literal_83

raw_84 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" bindings.
"]
// END RANK raw_84

prose_71 -> { raw_92}
{rank=same; raw_92}

raw_92 [label="raw"]


// END RANK prose_71

raw_92 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Medium-term goal is to hash any Lua object in a way that will resolve to a
common value for any identical semantics.
"]
// END RANK raw_92

codeblock_72 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local concat = table.concat
function Historian.persist(historian, txtbuf, results)
   local lb = tostring(txtbuf)
   if lb ~= \"\" then
      historian.insert_line:bindkv { project = historian.project_id,
                                          line    = lb }
      local err = historian.insert_line:step()
      if not err then
         historian.insert_line:clearbind():reset()
      else
         error(err)
      end
      local line_id = sql.lastRowId(historian.conn)
      if results and type(results) == \"table\" then
         for _,v in ipairs(reverse(results)) do
            -- insert result repr
            historian.insert_result:bindkv { line_id = line_id,
                                                  repr = color.ts(v) }
            err = historian.insert_result:step()
            if not err then
               historian.insert_result:clearbind():reset()
            end
         end
      end

   return true
   else
      -- A blank line can have no results and is uninteresting.
      return false
   end
   --]]
end"]
// END RANK codeblock_72

section_10 -> { header_95 prose_96 prose_97 section_98 section_99}
{rank=same; header_95 prose_96 prose_97 section_98 section_99}

header_95 [label="2 : Historian:search(frag)"]

prose_96 [label="prose"]

prose_97 [label="prose"]

section_98 [label="section: 302-327"]

section_99 [label="section: 328-393"]


// END RANK section_10

header_95 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Historian:search(frag)"]
// END RANK header_95

prose_96 -> { raw_101}
{rank=same; raw_101}

raw_101 [label="raw"]


// END RANK prose_96

raw_101 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is a 'fuzzy search', that attempts to find a string containing the
letters of the fragment in order.
"]
// END RANK raw_101

prose_97 -> { raw_103}
{rank=same; raw_103}

raw_103 [label="raw"]


// END RANK prose_97

raw_103 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If it finds nothing, it switches the last two letters and tries again. This
is an affordance for incremental searches, it's easy to make this mistake and
harmless to suggest the alternative.

"]
// END RANK raw_103

section_98 -> { header_105 prose_106 prose_107 codeblock_108}
{rank=same; header_105 prose_106 prose_107 codeblock_108}

header_105 [label="3 : fuzz_patt"]

prose_106 [label="prose"]

prose_107 [label="prose"]

codeblock_108 [label="code block 311-325"]


// END RANK section_98

header_105 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** fuzz_patt"]
// END RANK header_105

prose_106 -> { raw_110 prespace_111 literal_112 raw_113}
{rank=same; raw_110 prespace_111 literal_112 raw_113}

raw_110 [label="raw"]

prespace_111 [label="prespace"]

literal_112 [label="literal"]

raw_113 [label="raw"]


// END RANK prose_106

raw_110 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Here we incrementally build up a single"]
// END RANK raw_110

prespace_111 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_111

literal_112 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpeg"]
// END RANK literal_112

raw_113 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" pattern which will recognize
our desired lines.
"]
// END RANK raw_113

prose_107 -> { prespace_118 literal_119 raw_120 prespace_121 literal_122 raw_123}
{rank=same; prespace_118 literal_119 raw_120 prespace_121 literal_122 raw_123}

prespace_118 [label="prespace"]

literal_119 [label="literal"]

raw_120 [label="raw"]

prespace_121 [label="prespace"]

literal_122 [label="literal"]

raw_123 [label="raw"]


// END RANK prose_107

prespace_118 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_118

literal_119 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label="(P(1) - P(frag[n]))^0"]
// END RANK literal_119

raw_120 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" matches anything that isn't the next fragment,
including"]
// END RANK raw_120

prespace_121 -> leaf_127
leaf_127  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_121

literal_122 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\"\""]
// END RANK literal_122

raw_123 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  We then require this to be followed by the next fragment,
and so on.
"]
// END RANK raw_123

codeblock_108 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local P, match = L.P, L.match

local function fuzz_patt(frag)
   frag = type(frag) == \"string\" and codepoints(frag) or frag
   local patt =  (P(1) - P(frag[1]))^0
   for i = 1 , #frag - 1 do
      local v = frag[i]
      patt = patt * (P(v) * (P(1) - P(frag[i + 1]))^0)
   end
   patt = patt * P(frag[#frag])
   return patt
end
"]
// END RANK codeblock_108

section_99 -> { header_131 prose_132 prose_133 codeblock_134}
{rank=same; header_131 prose_132 prose_133 codeblock_134}

header_131 [label="3 : __repr for collection"]

prose_132 [label="prose"]

prose_133 [label="prose"]

codeblock_134 [label="code block 337-391"]


// END RANK section_99

header_131 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** __repr for collection"]
// END RANK header_131

prose_132 -> { raw_136 prespace_137 literal_138 raw_139}
{rank=same; raw_136 prespace_137 literal_138 raw_139}

raw_136 [label="raw"]

prespace_137 [label="prespace"]

literal_138 [label="literal"]

raw_139 [label="raw"]


// END RANK prose_132

raw_136 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

We use a pseudo-metamethod called"]
// END RANK raw_136

prespace_137 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_137

literal_138 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__repr"]
// END RANK literal_138

raw_139 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to specify custom table
representations.  These take the table as the first value and receive the
local color palette for consistency.
"]
// END RANK raw_139

prose_133 -> { raw_144}
{rank=same; raw_144}

raw_144 [label="raw"]


// END RANK prose_133

raw_144 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In this case we want to highlight the letters of the fragment, which we
attach to the collection.
"]
// END RANK raw_144

codeblock_134 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local concat, litpat = assert(table.concat), assert(string.litpat)
local gsub = assert(string.gsub)

local function _highlight(line, frag, c, best)
   local hl = {}
   local og_line = line -- debugging
   while #frag > 0 do
      local char
      char, frag = frag:sub(1,1), frag:sub(2)
      local at = line:find(litpat(char))
      if not at then
         error (\"can't find \" .. char .. \" in: \" .. line)
      end
      local color
      -- highlight the last two differently if this is a 'second best'
      -- search
      if not best and #frag <= 1 then
         color = c.alert
      else
         color = c.search_hl
      end
      hl[#hl + 1] = c.base(line:sub(1, at -1))
      hl[#hl + 1] = color(char)
      line = line:sub(at + 1)
   end
   hl[#hl + 1] = c.base(line)
   return concat(hl):gsub(\"\\n\", c.stresc(\"\\\\n\"))
end


local function _collect_repr(collection, c)
   if #collection == 0 then
      return c.alert \"No results found\"
   end
   local phrase = \"\"
   for i,v in ipairs(collection) do
      local alt_seq = \"    \"
      if i < 10 then
         alt_seq = a.bold(\"M-\" .. tostring(i) .. \" \")
      end
      local next_line = alt_seq
                        .. _highlight(v, collection.frag, c, collection.best)
                        .. \"\\n\"
      if i == collection.hl then
         next_line = c.highlight(next_line)
      end
      phrase = phrase .. next_line
   end

   return phrase
end

local collect_M = {__repr = _collect_repr}"]
// END RANK codeblock_134

section_11 -> { header_147 prose_148 prose_149 prose_150 prose_151 prose_152 prose_153 codeblock_154}
{rank=same; header_147 prose_148 prose_149 prose_150 prose_151 prose_152 prose_153 codeblock_154}

header_147 [label="2 : Historian:search(frag)"]

prose_148 [label="prose"]

prose_149 [label="prose"]

prose_150 [label="prose"]

prose_151 [label="prose"]

prose_152 [label="prose"]

prose_153 [label="prose"]

codeblock_154 [label="code block 411-453"]


// END RANK section_11

header_147 -> leaf_155
leaf_155  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Historian:search(frag)"]
// END RANK header_147

prose_148 -> { raw_156 prespace_157 literal_158 raw_159}
{rank=same; raw_156 prespace_157 literal_158 raw_159}

raw_156 [label="raw"]

prespace_157 [label="prespace"]

literal_158 [label="literal"]

raw_159 [label="raw"]


// END RANK prose_148

raw_156 -> leaf_160
leaf_160  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is an incremental 'fuzzy' search, returning a"]
// END RANK raw_156

prespace_157 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_157

literal_158 -> leaf_162
leaf_162  [color=Gray,shape=rectangle,fontname=Inconsolata,label="collection"]
// END RANK literal_158

raw_159 -> leaf_163
leaf_163  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_159

prose_149 -> { raw_164}
{rank=same; raw_164}

raw_164 [label="raw"]


// END RANK prose_149

raw_164 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The array portion of a collection is any line which matches the search.
"]
// END RANK raw_164

prose_150 -> { raw_166}
{rank=same; raw_166}

raw_166 [label="raw"]


// END RANK prose_150

raw_166 -> leaf_167
leaf_167  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The other fields are:
"]
// END RANK raw_166

prose_151 -> { raw_168}
{rank=same; raw_168}

raw_168 [label="raw"]


// END RANK prose_151

raw_168 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- #fields
  -  best :  Whether this is a best-fit collection, that is, one with all
             codepoints in order.
"]
// END RANK raw_168

prose_152 -> { raw_170}
{rank=same; raw_170}

raw_170 [label="raw"]


// END RANK prose_152

raw_170 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  frag :  The fragment, used to highlight the collection
"]
// END RANK raw_170

prose_153 -> { raw_172}
{rank=same; raw_172}

raw_172 [label="raw"]


// END RANK prose_153

raw_172 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  cursors :  This is an array, each value is the cursor position of
                the corresponding line in the history.
"]
// END RANK raw_172

codeblock_154 -> leaf_174
leaf_174  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.search(historian, frag)
   if historian.last_collection
      and historian.last_collection.frag == frag then
      return historian.last_collection
   end
   local collection = setmeta({}, collect_M)
   collection.frag = frag
   if frag == \"\" then
      return collection, false
   end
   local cursors = {}
   local best = true
   local patt = fuzz_patt(frag)
   for i = #historian, 1, -1 do
      local score = match(patt, tostring(historian[i]))
      if score then
         collection[#collection + 1] = tostring(historian[i])

            cursors[#cursors + 1] = i
      end
   end
   if #collection == 0 then
      -- try the transpose
      best = false
      local slip = sub(frag, 1, -3) .. sub(frag, -1, -1) .. sub(frag, -2, -2)
      collection.frag = slip
      patt = fuzz_patt(slip)
      for i = #historian, 1, -1 do
         local score = match(patt, tostring(historian[i]))
         if score then
            collection[#collection + 1] = tostring(historian[i])
            cursors[#cursors + 1] = i
         end
      end
   end
   collection.best = best
   collection.cursors = cursors
   collection.hl = 1
   historian.last_collection = collection
   return collection, best
end"]
// END RANK codeblock_154

section_12 -> { header_175 prose_176 codeblock_177 section_178 section_179 section_180}
{rank=same; header_175 prose_176 codeblock_177 section_178 section_179 section_180}

header_175 [label="2 : Historian:prev()"]

prose_176 [label="prose"]

codeblock_177 [label="code block 458-471"]

section_178 [label="section: 474-503"]

section_179 [label="section: 504-522"]

section_180 [label="section: 523-557"]


// END RANK section_12

header_175 -> leaf_181
leaf_181  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Historian:prev()"]
// END RANK header_175

prose_176 -> { raw_182}
{rank=same; raw_182}

raw_182 [label="raw"]


// END RANK prose_176

raw_182 -> leaf_183
leaf_183  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_182

codeblock_177 -> leaf_184
leaf_184  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.prev(historian)
   if historian.cursor == 0 or #historian == 0 then
      return Txtbuf()
   end
   local Δ = historian.cursor > 1 and 1 or 0
   local txtbuf = historian[historian.cursor - Δ]
   txtbuf.cur_row = 1
   local result = historian.results[txtbuf]
   historian.cursor = historian.cursor - Δ
   txtbuf.cursor = #txtbuf.lines[txtbuf.cur_row] + 1
   return txtbuf:clone(), result
end"]
// END RANK codeblock_177

section_178 -> { header_185 prose_186 codeblock_187}
{rank=same; header_185 prose_186 codeblock_187}

header_185 [label="3 : Historian:next()"]

prose_186 [label="prose"]

codeblock_187 [label="code block 480-501"]


// END RANK section_178

header_185 -> leaf_188
leaf_188  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:next()"]
// END RANK header_185

prose_186 -> { raw_189 prespace_190 literal_191 raw_192}
{rank=same; raw_189 prespace_190 literal_191 raw_192}

raw_189 [label="raw"]

prespace_190 [label="prespace"]

literal_191 [label="literal"]

raw_192 [label="raw"]


// END RANK prose_186

raw_189 -> leaf_193
leaf_193  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Returns the next txtbuf in history, and a second flag to tell the"]
// END RANK raw_189

prespace_190 -> leaf_194
leaf_194  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_190

literal_191 -> leaf_195
leaf_195  [color=Gray,shape=rectangle,fontname=Inconsolata,label="modeselektor"]
// END RANK literal_191

raw_192 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" it might be time for a new one.

"]
// END RANK raw_192

codeblock_187 -> leaf_197
leaf_197  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.next(historian)
   local Δ = historian.cursor < #historian and 1 or 0
   if historian.cursor == 0 or #historian == 0 then
      return Txtbuf()
   end
   local txtbuf = historian[historian.cursor + Δ]
   if not txtbuf then
      return Txtbuf(), nil, true
   end
   txtbuf.cur_row = #txtbuf.lines
   local result = historian.results[txtbuf]
   historian.cursor = historian.cursor + Δ
   txtbuf.cursor = #txtbuf.lines[txtbuf.cur_row] + 1
   if not (Δ > 0) and #txtbuf.lines > 0 then
      historian.cursor = #historian + 1
      return txtbuf:clone(), nil, true
   else
      return txtbuf:clone(), result, false
   end
end"]
// END RANK codeblock_187

section_179 -> { header_198 prose_199 codeblock_200}
{rank=same; header_198 prose_199 codeblock_200}

header_198 [label="3 : Historian:index(cursor)"]

prose_199 [label="prose"]

codeblock_200 [label="code block 508-521"]


// END RANK section_179

header_198 -> leaf_201
leaf_201  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:index(cursor)"]
// END RANK header_198

prose_199 -> { raw_202}
{rank=same; raw_202}

raw_202 [label="raw"]


// END RANK prose_199

raw_202 -> leaf_203
leaf_203  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Loads the history to an exact index.
"]
// END RANK raw_202

codeblock_200 -> leaf_204
leaf_204  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.index(historian, cursor)
   if (not cursor) or cursor < 0 or cursor > #historian + 1 then
      return Txtbuf()
   end
   local txtbuf = historian[cursor]
   local result = historian.results[txtbuf]
   txtbuf = txtbuf:clone()
   historian.cursor = cursor
   txtbuf.cur_row = #txtbuf.lines
   txtbuf.cursor = #txtbuf.lines[txtbuf.cur_row] + 1
   return txtbuf, result
end"]
// END RANK codeblock_200

section_180 -> { header_205 prose_206 prose_207 codeblock_208 codeblock_209 codeblock_210}
{rank=same; header_205 prose_206 prose_207 codeblock_208 codeblock_209 codeblock_210}

header_205 [label="3 : Historian:append(txtbuf, results, success)"]

prose_206 [label="prose"]

prose_207 [label="prose"]

codeblock_208 [label="code block 529-544"]

codeblock_209 [label="code block 546-553"]

codeblock_210 [label="code block 555-557"]


// END RANK section_180

header_205 -> leaf_211
leaf_211  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:append(txtbuf, results, success)"]
// END RANK header_205

prose_206 -> { raw_212}
{rank=same; raw_212}

raw_212 [label="raw"]


// END RANK prose_206

raw_212 -> leaf_213
leaf_213  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Appends a txtbuf to history and persists it.
"]
// END RANK raw_212

prose_207 -> { raw_214}
{rank=same; raw_214}

raw_214 [label="raw"]


// END RANK prose_207

raw_214 -> leaf_215
leaf_215  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Doesn't adjust the cursor.
"]
// END RANK raw_214

codeblock_208 -> leaf_216
leaf_216  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.append(historian, txtbuf, results, success)
   if tostring(historian[#historian]) == tostring(txtbuf)
      or tostring(txtbuf) == \"\" then
      -- don't bother
      return false
   end
   historian[#historian + 1] = txtbuf
   if success then
      historian:persist(txtbuf, results)
   else
      historian:persist(txtbuf)
   end
   return true
end"]
// END RANK codeblock_208

codeblock_209 -> leaf_217
leaf_217  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new()
   local historian = meta(Historian)
   historian:load()
   return historian
end
Historian.idEst = new"]
// END RANK codeblock_209

codeblock_210 -> leaf_218
leaf_218  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]
// END RANK codeblock_210


}
