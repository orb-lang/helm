digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 414"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-328"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 codeblock_7 codeblock_8 section_9 section_10 section_11}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 codeblock_7 codeblock_8 section_9 section_10 section_11}

header_2 [label="1 : Historian"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

codeblock_7 [label="code block 16-25"]

codeblock_8 [label="code block 27-29"]

section_9 [label="section: 32-231"]

section_10 [label="section: 283-328"]

section_11 [label="section: 329-380"]


// END RANK section_1

header_2 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Historian"]
// END RANK header_2

prose_3 -> { raw_13}
{rank=same; raw_13}

raw_13 [label="raw"]


// END RANK prose_3

raw_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


This module is responsible for REPL history.
"]
// END RANK raw_13

prose_4 -> { raw_15}
{rank=same; raw_15}

raw_15 [label="raw"]


// END RANK prose_4

raw_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Eventually this will include persisting and restoring from a SQLite database,
fuzzy searching, and variable cacheing.
"]
// END RANK raw_15

prose_5 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


// END RANK prose_5

raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Currently does the basic job of retaining history and not letting subsequent
edits munge it.
"]
// END RANK raw_17

prose_6 -> { raw_19}
{rank=same; raw_19}

raw_19 [label="raw"]


// END RANK prose_6

raw_19 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Next step: now that we clone a new txtbuf each time, we have an immutable
record.  We should store the line as a string, to facilitate fuzzy matching.

"]
// END RANK raw_19

codeblock_7 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Txtbuf = require \"txtbuf\"
local sql     = require \"sqlayer\"
local color   = require \"color\"
local L       = require \"lpeg\"
local format  = assert (string.format)
local sub     = assert (string.sub)
local reverse = assert (table.reverse)
assert(meta)"]
// END RANK codeblock_7

codeblock_8 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Historian = meta {}"]
// END RANK codeblock_8

section_9 -> { header_23 prose_24 section_25 section_26 section_27 section_28}
{rank=same; header_23 prose_24 section_25 section_26 section_27 section_28}

header_23 [label="2 : Persistence"]

prose_24 [label="prose"]

section_25 [label="section: 36-141"]

section_26 [label="section: 142-220"]

section_27 [label="section: 221-231"]

section_28 [label="section: 232-282"]


// END RANK section_9

header_23 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Persistence"]
// END RANK header_23

prose_24 -> { raw_30}
{rank=same; raw_30}

raw_30 [label="raw"]


// END RANK prose_24

raw_30 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This defines the persistence model for bridge.
"]
// END RANK raw_30

section_25 -> { header_32 prose_33 codeblock_34}
{rank=same; header_32 prose_33 codeblock_34}

header_32 [label="3 : SQLite battery"]

prose_33 [label="prose"]

codeblock_34 [label="code block 38-139"]


// END RANK section_25

header_32 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** SQLite battery"]
// END RANK header_32

prose_33 -> { raw_36}
{rank=same; raw_36}

raw_36 [label="raw"]


// END RANK prose_33

raw_36 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_36

codeblock_34 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Historian.HISTORY_LIMIT = 1000

local create_project_table = [[
CREATE TABLE IF NOT EXISTS project (
project_id INTEGER PRIMARY KEY AUTOINCREMENT,
directory TEXT UNIQUE,
time DATETIME DEFAULT CURRENT_TIMESTAMP );
]]

local create_repl_table = [[
CREATE TABLE IF NOT EXISTS repl (
line_id INTEGER PRIMARY KEY AUTOINCREMENT,
project INTEGER,
line TEXT,
time DATETIME DEFAULT CURRENT_TIMESTAMP,
FOREIGN KEY (project)
   REFERENCES project (project_id)
   ON DELETE CASCADE );
]]

local create_result_table = [[
CREATE TABLE IF NOT EXISTS result (
result_id INTEGER PRIMARY KEY AUTOINCREMENT,
line_id INTEGER,
repr text NOT NULL,
value blob,
FOREIGN KEY (line_id)
   REFERENCES repl (line_id)
   ON DELETE CASCADE );
]]

local create_session_table = [[
CREATE TABLE IF NOT EXISTS session (
session_id INTEGER PRIMARY KEY AUTOINCREMENT,
name TEXT,
project INTEGER,
-- These two are line_ids
start INTEGER NOT NULL,
end INTEGER,
test BOOLEAN,
sha TEXT,
FOREIGN KEY (project)
   REFERENCES project (project_id)
   ON DELETE CASCADE );
]]

local insert_line = [[
INSERT INTO repl (project, line) VALUES (:project, :line);
]]

local insert_result = [[
INSERT INTO result (line_id, repr) VALUES (:line_id, :repr);
]]

local insert_project = [[
INSERT INTO project (directory) VALUES (:dir);
]]

local get_tables = [[
SELECT name FROM sqlite_master WHERE type='table';
]]

local get_recent = [[
SELECT CAST (line_id AS REAL), line FROM repl
   WHERE project = %d
   ORDER BY time
   DESC LIMIT %d;
]]

local get_project = [[
SELECT project_id FROM project
   WHERE directory = %s;
]]

local get_reprs = [[
SELECT CAST (repl.line_id AS REAL), result.repr
FROM repl
LEFT OUTER JOIN result
ON repl.line_id = result.line_id
WHERE repl.project = %d
ORDER BY result.result_id
DESC LIMIT %d;
]]

local home_dir = io.popen(\"echo $HOME\", \"r\"):read(\"*a\"):sub(1, -2)

local bridge_home = io.popen(\"echo $BRIDGE_HOME\", \"r\"):read(\"*a\"):sub(1, -2)
Historian.bridge_home = bridge_home ~= \"\" and bridge_home
                        or home_dir .. \"/.bridge\"

Historian.project = io.popen(\"pwd\", \"r\"):read(\"*a\"):sub(1, -2)

local function has(table, name)
   for _,v in ipairs(table) do
      if name == v then
         return true
      end
   end
   return false
end"]
// END RANK codeblock_34

section_26 -> { header_39 prose_40 prose_41 codeblock_42}
{rank=same; header_39 prose_40 prose_41 codeblock_42}

header_39 [label="3 : Historian:load()"]

prose_40 [label="prose"]

prose_41 [label="prose"]

codeblock_42 [label="code block 149-218"]


// END RANK section_26

header_39 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:load()"]
// END RANK header_39

prose_40 -> { raw_44}
{rank=same; raw_44}

raw_44 [label="raw"]


// END RANK prose_40

raw_44 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Brings up the project history and (eventually) results and user config.
"]
// END RANK raw_44

prose_41 -> { raw_46}
{rank=same; raw_46}

raw_46 [label="raw"]


// END RANK prose_41

raw_46 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Most of the complexity serves to make a simple key/value relationship
between the regenerated txtbufs and their associated result history.
"]
// END RANK raw_46

codeblock_42 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.load(historian)
   local conn = sql.open(historian.bridge_home)
   historian.conn = conn
   -- Set up bridge tables
   conn.pragma.foreign_keys(true)
   conn:exec(create_project_table)
   conn:exec(create_result_table)
   conn:exec(create_repl_table)
   conn:exec(create_session_table)
   -- Retrive project id
   local proj_val, proj_row = sql.pexec(conn,
                                  sql.format(get_project, historian.project),
                                  \"i\")
   if not proj_val then
      local ins_proj_stmt = conn:prepare(insert_project)
      ins_proj_stmt:bindkv {dir = historian.project}
      proj_val, proj_row = ins_proj_stmt:step()
      -- retry
      proj_val, proj_row = sql.pexec(conn,
                                  sql.format(get_project, historian.project),
                                  \"i\")
      if not proj_val then
         error \"Could not create project in .bridge\"
      end
   end

   local project_id = proj_val[1][1]
   historian.project_id = project_id
   -- Create insert prepared statements
   historian.insert_line = conn:prepare(insert_line)
   historian.insert_result = conn:prepare(insert_result)
   -- Retrieve history
   local pop_str = sql.format(get_recent, project_id,
                        historian.HISTORY_LIMIT)
   local repl_val, repl_row = sql.pexec(conn, pop_str, \"i\")
   local res_str = sql.format(get_reprs, project_id,
                       historian.HISTORY_LIMIT * 2)
   local res_val, res_row = sql.pexec(conn, res_str, \"i\")
   if repl_val and res_val then
      local lines = reverse(repl_val[2])
      local line_ids = reverse(repl_val[1])
      local repl_map = {}
      for i, v in ipairs(lines) do
         local buf = Txtbuf(v)
         historian[i] = buf
         repl_map[line_ids[i]] = buf
      end
      historian.cursor = #historian
      -- reuse line_id var for foreign keys
      line_ids = res_val[1]
      local reprs = res_val[2]
      -- This is keyed by txtbuf with a string value.
      local result_map = {}
      for i = 1, #reprs do
         local buf = repl_map[line_ids[i]]
         if buf then
            local result = result_map[buf] or {frozen = true}
            result[#result + 1] = reprs[i]
            result.n = #result -- for compat with nil in live use
            result_map[buf] = result
         end
      end
      historian.results = result_map
   else
      historian.results = {}
      historian.cursor = 0
   end
end"]
// END RANK codeblock_42

section_27 -> { header_49 prose_50 prose_51 codeblock_52}
{rank=same; header_49 prose_50 prose_51 codeblock_52}

header_49 [label="3 : Historian:restore_session(modeS, session)"]

prose_50 [label="prose"]

prose_51 [label="prose"]

codeblock_52 [label="code block 227-229"]


// END RANK section_27

header_49 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:restore_session(modeS, session)"]
// END RANK header_49

prose_50 -> { raw_54}
{rank=same; raw_54}

raw_54 [label="raw"]


// END RANK prose_50

raw_54 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

If there is an open session, we want to replay it.
"]
// END RANK raw_54

prose_51 -> { raw_56}
{rank=same; raw_56}

raw_56 [label="raw"]


// END RANK prose_51

raw_56 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To do this, we need to borrow the modeselektor.
"]
// END RANK raw_56

codeblock_52 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK codeblock_52

section_28 -> { header_59 prose_60 prose_61 prose_62 prose_63 codeblock_64}
{rank=same; header_59 prose_60 prose_61 prose_62 prose_63 codeblock_64}

header_59 [label="3 : Historian:persist(txtbuf)"]

prose_60 [label="prose"]

prose_61 [label="prose"]

prose_62 [label="prose"]

prose_63 [label="prose"]

codeblock_64 [label="code block 247-280"]


// END RANK section_28

header_59 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:persist(txtbuf)"]
// END RANK header_59

prose_60 -> { raw_66}
{rank=same; raw_66}

raw_66 [label="raw"]


// END RANK prose_60

raw_66 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Persists a line and results to store.
"]
// END RANK raw_66

prose_61 -> { raw_68}
{rank=same; raw_68}

raw_68 [label="raw"]


// END RANK prose_61

raw_68 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The hooks are in place to persist the results. I'm starting with a string
representation; the goal is to provide the sense of persistence across
sessions, and supplement that over time with better and better approximations.
"]
// END RANK raw_68

prose_62 -> { raw_70 prespace_71 literal_72 raw_73 prespace_74 literal_75 raw_76}
{rank=same; raw_70 prespace_71 literal_72 raw_73 prespace_74 literal_75 raw_76}

raw_70 [label="raw"]

prespace_71 [label="prespace"]

literal_72 [label="literal"]

raw_73 [label="raw"]

prespace_74 [label="prespace"]

literal_75 [label="literal"]

raw_76 [label="raw"]


// END RANK prose_62

raw_70 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To really nail it down will require semantic analysis and hence thorough
parsing.  General-purpose persistence tools belong in"]
// END RANK raw_70

prespace_71 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_71

literal_72 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sqlayer"]
// END RANK literal_72

raw_73 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", which will
merge with our increasingly-modified"]
// END RANK raw_73

prespace_74 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_74

literal_75 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sqlite"]
// END RANK literal_75

raw_76 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" bindings.
"]
// END RANK raw_76

prose_63 -> { raw_84}
{rank=same; raw_84}

raw_84 [label="raw"]


// END RANK prose_63

raw_84 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Medium-term goal is to hash any Lua object in a way that will resolve to a
common value for any identical semantics.
"]
// END RANK raw_84

codeblock_64 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.persist(historian, txtbuf, results)
   local lb = tostring(txtbuf)
   if lb ~= \"\" then
      historian.insert_line:bindkv { project = historian.project_id,
                                          line    = lb }
      local err = historian.insert_line:step()
      if not err then
         historian.insert_line:clearbind():reset()
      else
         error(err)
      end
      local line_id = sql.lastRowId(historian.conn)
      if results and type(results) == \"table\" then
         for _,v in ipairs(reverse(results)) do
            -- insert result repr
            -- tostring() just for compactness
            historian.insert_result:bindkv { line_id = line_id,
                                                  repr = color.ts(v) }
            err = historian.insert_result:step()
            if not err then
               historian.insert_result:clearbind():reset()
            end
         end
      end

   return true
   else
      -- A blank line can have no results and is uninteresting.
      return false
   end
   --]]
end"]
// END RANK codeblock_64

section_10 -> { header_87 prose_88 codeblock_89}
{rank=same; header_87 prose_88 codeblock_89}

header_87 [label="2 : Historian:search(frag)"]

prose_88 [label="prose"]

codeblock_89 [label="code block 285-326"]


// END RANK section_10

header_87 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Historian:search(frag)"]
// END RANK header_87

prose_88 -> { raw_91}
{rank=same; raw_91}

raw_91 [label="raw"]


// END RANK prose_88

raw_91 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_91

codeblock_89 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local P, match = L.P, L.match

-- second_best is broke and I don't know why
-- also this fails on a single key search >.<
local function fuzz_patt(frag)
   frag = type(frag) == \"string\" and codepoints(frag) or frag
   local patt =        (P(1) - P(frag[1]))^0
   for i = 1 , #frag - 1 do
      local v = frag[i]
      patt = patt * (P(v) * (P(1) - P(frag[i + 1]))^0)
   end
   patt = patt * P(frag[#frag])
   return patt
end

function Historian.search(historian, frag)
   local collection = {}
   local best = true
   local patt = fuzz_patt(frag)
   for i = #historian, 1, -1 do
      local score = match(patt, tostring(historian[i]))
      if score then
         collection[#collection + 1] = tostring(historian[i])
      end
   end
   if #collection == 0 then
      -- try the transpose
      best = false
      local slip = sub(frag, 1, -3) .. sub(frag, -1, -1) .. sub(frag, -2, -2)
      local second = fuzz_patt(slip)
      for i = #historian, 1, -1 do
         local score = match(second, tostring(historian[i]))
         if score then
            collection[#collection + 1] = tostring(historian[i])
         end
      end
   end

   return collection, best
end"]
// END RANK codeblock_89

section_11 -> { header_94 prose_95 codeblock_96 section_97 section_98}
{rank=same; header_94 prose_95 codeblock_96 section_97 section_98}

header_94 [label="2 : Historian:prev()"]

prose_95 [label="prose"]

codeblock_96 [label="code block 331-344"]

section_97 [label="section: 347-380"]

section_98 [label="section: 381-414"]


// END RANK section_11

header_94 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Historian:prev()"]
// END RANK header_94

prose_95 -> { raw_100}
{rank=same; raw_100}

raw_100 [label="raw"]


// END RANK prose_95

raw_100 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_100

codeblock_96 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.prev(historian)
   if historian.cursor == 0 or #historian == 0 then
      return Txtbuf()
   end
   local Δ = historian.cursor > 1 and 1 or 0
   local txtbuf = historian[historian.cursor - Δ]
   txtbuf.cur_row = 1
   local result = historian.results[txtbuf]
   historian.cursor = historian.cursor - Δ
   txtbuf.cursor = #txtbuf.lines[txtbuf.cur_row] + 1
   return txtbuf:clone(), result
end"]
// END RANK codeblock_96

section_97 -> { header_103 prose_104 prose_105 codeblock_106}
{rank=same; header_103 prose_104 prose_105 codeblock_106}

header_103 [label="3 : Historian:next()"]

prose_104 [label="prose"]

prose_105 [label="prose"]

codeblock_106 [label="code block 354-378"]


// END RANK section_97

header_103 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:next()"]
// END RANK header_103

prose_104 -> { raw_108 prespace_109 literal_110 raw_111}
{rank=same; raw_108 prespace_109 literal_110 raw_111}

raw_108 [label="raw"]

prespace_109 [label="prespace"]

literal_110 [label="literal"]

raw_111 [label="raw"]


// END RANK prose_104

raw_108 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Returns the next txtbuf in history, and a second flag to tell the"]
// END RANK raw_108

prespace_109 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_109

literal_110 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="modeselektor"]
// END RANK literal_110

raw_111 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" it might be time for a new one.
"]
// END RANK raw_111

prose_105 -> { raw_116}
{rank=same; raw_116}

raw_116 [label="raw"]


// END RANK prose_105

raw_116 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'd like to stop buffering blank lines at some point.
"]
// END RANK raw_116

codeblock_106 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.next(historian)
   local Δ = historian.cursor < #historian and 1 or 0
   if historian.cursor == 0 or #historian == 0 then
      return Txtbuf()
   end
   local txtbuf = historian[historian.cursor + Δ]
   if not txtbuf then
      return Txtbuf()
   end
   txtbuf.cur_row = #txtbuf.lines
   local result = historian.results[txtbuf]
   if not txtbuf then
      return Txtbuf()
   end
   historian.cursor = historian.cursor + Δ
   txtbuf.cursor = #txtbuf.lines[txtbuf.cur_row] + 1
   if not (Δ > 0) and #txtbuf.lines > 0 then
      historian.cursor = #historian + 1
      return txtbuf:clone(), nil, true
   else
      return txtbuf:clone(), result, false
   end
end"]
// END RANK codeblock_106

section_98 -> { header_119 prose_120 prose_121 codeblock_122 codeblock_123 codeblock_124}
{rank=same; header_119 prose_120 prose_121 codeblock_122 codeblock_123 codeblock_124}

header_119 [label="3 : Historian:append()"]

prose_120 [label="prose"]

prose_121 [label="prose"]

codeblock_122 [label="code block 387-401"]

codeblock_123 [label="code block 403-410"]

codeblock_124 [label="code block 412-414"]


// END RANK section_98

header_119 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Historian:append()"]
// END RANK header_119

prose_120 -> { raw_126}
{rank=same; raw_126}

raw_126 [label="raw"]


// END RANK prose_120

raw_126 -> leaf_127
leaf_127  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Appends a txtbuf to history and persists it.
"]
// END RANK raw_126

prose_121 -> { raw_128}
{rank=same; raw_128}

raw_128 [label="raw"]


// END RANK prose_121

raw_128 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Doesn't adjust the cursor.
"]
// END RANK raw_128

codeblock_122 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Historian.append(historian, txtbuf, results, success)
   if tostring(historian[#historian]) == tostring(txtbuf) then
      -- don't bother
      return false
   end
   historian[#historian + 1] = txtbuf
   if success then
      historian:persist(txtbuf, results)
   else
      historian:persist(txtbuf)
   end
   return true
end"]
// END RANK codeblock_122

codeblock_123 -> leaf_131
leaf_131  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new()
   local historian = meta(Historian)
   historian:load()
   return historian
end
Historian.idEst = new"]
// END RANK codeblock_123

codeblock_124 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]
// END RANK codeblock_124


}
