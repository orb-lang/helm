digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 259"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-168"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 section_6 section_7 section_8}
{rank=same; header_2 prose_3 prose_4 prose_5 section_6 section_7 section_8}

header_2 [label="1 : Anterm"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

section_6 [label="section: 12-119"]

section_7 [label="section: 120-168"]

section_8 [label="section: 169-259"]


// END RANK section_1

header_2 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Anterm"]
// END RANK header_2

prose_3 -> { raw_10 prespace_11 literal_12 raw_13}
{rank=same; raw_10 prespace_11 literal_12 raw_13}

raw_10 [label="raw"]

prespace_11 [label="prespace"]

literal_12 [label="literal"]

raw_13 [label="raw"]


// END RANK prose_3

raw_10 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_10

prespace_11 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_11

literal_12 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="anterm"]
// END RANK literal_12

raw_13 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is actually the protocol.
"]
// END RANK raw_13

prose_4 -> { prespace_18 literal_19 raw_20}
{rank=same; prespace_18 literal_19 raw_20}

prespace_18 [label="prespace"]

literal_19 [label="literal"]

raw_20 [label="raw"]


// END RANK prose_4

prespace_18 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_18

literal_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="anterm.orb"]
// END RANK literal_19

raw_20 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is properly called \"anterm's monster\".
"]
// END RANK raw_20

prose_5 -> { raw_24 prespace_25 literal_26 raw_27 prespace_28 literal_29 raw_30}
{rank=same; raw_24 prespace_25 literal_26 raw_27 prespace_28 literal_29 raw_30}

raw_24 [label="raw"]

prespace_25 [label="prespace"]

literal_26 [label="literal"]

raw_27 [label="raw"]

prespace_28 [label="prespace"]

literal_29 [label="literal"]

raw_30 [label="raw"]


// END RANK prose_5

raw_24 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is actually our raw"]
// END RANK raw_24

prespace_25 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_25

literal_26 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="xterm"]
// END RANK literal_26

raw_27 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" handler. "]
// END RANK raw_27

prespace_28 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_28

literal_29 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="anterm"]
// END RANK literal_29

raw_30 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" protocol requires a few
platforms which run it.

"]
// END RANK raw_30

section_6 -> { header_38 prose_39 codeblock_40 codeblock_41}
{rank=same; header_38 prose_39 codeblock_40 codeblock_41}

header_38 [label="3 : includes"]

prose_39 [label="prose"]

codeblock_40 [label="code block 16-18"]

codeblock_41 [label="code block 20-117"]


// END RANK section_6

header_38 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
// END RANK header_38

prose_39 -> { raw_43}
{rank=same; raw_43}

raw_43 [label="raw"]


// END RANK prose_39

raw_43 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

We'll want lpeg for fuzzy matching.
"]
// END RANK raw_43

codeblock_40 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\""]
// END RANK codeblock_40

codeblock_41 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local pairs = pairs
local tostring = tostring
local setmetatable = setmetatable
local error = error
local require = require
local rawget = rawget
local io = io
local schar = string.char

local _M = {}

local CSI = schar(27)..'['

local colormt = {}

local colors = {
    -- attributes
    attribute = {
        reset = 0,
        clear = 0,
        bright = 1,
        bold = 1,
        dim = 2,
        italic = 3,
        underscore = 4,
        blink = 5,
        reverse = 7,
        hidden = 8},
    -- foreground
    fg = {
        black = 30,
        red = 31,
        green = 32,
        yellow = 33,
        blue = 34,
        magenta = 35,
        cyan = 36,
        white = 37,
        clear_fg = 39  },
    -- background
    bg = {
        onblack = 40,
        onred = 41,
        ongreen = 42,
        onyellow = 43,
        onblue = 44,
        onmagenta = 45,
        oncyan = 46,
        onwhite = 47,
        clear_bg = 49}
}

local function makecolor(value, name, kind)
    local color = {
        value = CSI .. value ..\"m\",
        name = name,
        kind = kind }
    return setmetatable(color, colormt)
end

for kind, val in pairs(colors) do
    for c, v in pairs(val) do
        _M[c] = makecolor(v, c, kind)
    end
end

function colormt:__tostring()
    return self.value
end

function colormt:__concat(other)
    return tostring(self) .. tostring(other)
end


local function reset(color)
    -- given a color, reset its action.
    -- simple for fg and bg
    -- complex but tractable for attributes
    if color.kind == \"fg\" then
        return _M.clear_fg
    elseif color.kind == \"bg\" then
        return _M.clear_bg
    elseif color.kind == \"attribute\" then
        --error \"attribute reset NYI\"
        return _M.clear
    end
end

function colormt:__call(s)
    if s then
        return tostring(self) .. s .. reset(self)
    else
        return tostring(self)
    end
end"]
// END RANK codeblock_41

section_7 -> { header_47 prose_48 prose_49 codeblock_50}
{rank=same; header_47 prose_48 prose_49 codeblock_50}

header_47 [label="3 : 256 color"]

prose_48 [label="prose"]

prose_49 [label="prose"]

codeblock_50 [label="code block 126-166"]


// END RANK section_7

header_47 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** 256 color"]
// END RANK header_47

prose_48 -> { raw_52 prespace_53 literal_54 raw_55}
{rank=same; raw_52 prespace_53 literal_54 raw_55}

raw_52 [label="raw"]

prespace_53 [label="prespace"]

literal_54 [label="literal"]

raw_55 [label="raw"]


// END RANK prose_48

raw_52 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

There are 512"]
// END RANK raw_52

prespace_53 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_53

literal_54 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="xterm"]
// END RANK literal_54

raw_55 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" colors available.
"]
// END RANK raw_55

prose_49 -> { raw_60}
{rank=same; raw_60}

raw_60 [label="raw"]


// END RANK prose_49

raw_60 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We memoize their creation, giving reference equality between these colors.
"]
// END RANK raw_60

codeblock_50 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function byte_panic(byte_p)
       if not byte_p or not (0 <= byte_p and byte_p <= 255) then
        error \"xterm value must be 8 bit unsigned\"
    end
end

local x256_store = {}

local function ansi_fg(byte)
    local function make (byte)
        byte_panic(byte)
        local color = { value = schar(27)..\"[38;5;\"..byte..\"m\",
                        kind = \"fg\" }
        return setmetatable(color, colormt)
    end
    if x256_store[byte] then
        return x256_store[byte]
    else
        local color = make(byte)
        x256_store[byte] = color
        return color
    end
end

local function ansi_bg(byte)
    local function make (byte)
        byte_panic(byte)
        local color = { value = schar(27)..\"[48;5;\"..byte..\"m\",
                        kind = \"bg\" }
        return setmetatable(color, colormt)
    end
    if x256_store[byte] then
        return x256_store[byte]
    else
        local color = make(byte)
        x256_store[byte] = color
        return color
    end
end"]
// END RANK codeblock_50

section_8 -> { header_63 prose_64 prose_65 prose_66 prose_67 codeblock_68}
{rank=same; header_63 prose_64 prose_65 prose_66 prose_67 codeblock_68}

header_63 [label="3 : fg24(r,g,b), bg24(r,g,b)"]

prose_64 [label="prose"]

prose_65 [label="prose"]

prose_66 [label="prose"]

prose_67 [label="prose"]

codeblock_68 [label="code block 182-259"]


// END RANK section_8

header_63 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** fg24(r,g,b), bg24(r,g,b)"]
// END RANK header_63

prose_64 -> { raw_70}
{rank=same; raw_70}

raw_70 [label="raw"]


// END RANK prose_64

raw_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This state space is far too large to retain pointers to all colorizers.
"]
// END RANK raw_70

prose_65 -> { raw_72}
{rank=same; raw_72}

raw_72 [label="raw"]


// END RANK prose_65

raw_72 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
One might want to write a smooth transition, and would expect the colors to be
garbage collected after.
"]
// END RANK raw_72

prose_66 -> { raw_74}
{rank=same; raw_74}

raw_74 [label="raw"]


// END RANK prose_66

raw_74 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Hence we memoize with a weak table.  The only reliable way to achieve
reference equality between instances of a 24 bit color is to retain a pointer
to it.
"]
// END RANK raw_74

prose_67 -> { raw_76}
{rank=same; raw_76}

raw_76 [label="raw"]


// END RANK prose_67

raw_76 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Happily, this is a requirement for any comparsion.
"]
// END RANK raw_76

codeblock_68 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local x24k = setmetatable({}, {__mode = \"v\"})

local fg24pre = schar(27) .. \"[38;2;\"

local function fg24(r,g,b)
   byte_panic(r)
   byte_panic(g)
   byte_panic(b)
   local color = { value = fg24pre
                           .. r .. \";\" .. g .. \";\" .. b .. \"m\",
                   kind = \"fg\" }
   if x24k[color] then
      return x24k[color]
   end
   x24k[color] = color
   return setmetatable(color, colormt)
end

local bg24pre = schar(27) .. \"[48;2;\"

local function bg24(r,g,b)
   byte_panic(r)
   byte_panic(g)
   byte_panic(b)
   local color = { value = bg24pre
                           .. r .. \";\" .. g .. \";\" .. b .. \"m\",
                   kind = \"bg\" }
   if x24k[color] then
      return x24k[color]
   end
   x24k[color] = color
   return setmetatable(color, colormt)
end

_M[\"fg\"], _M[\"bg\"] = ansi_fg, ansi_bg

_M[\"fg24\"], _M[\"bg24\"] = fg24, bg24

--- Jumps

local jump = {}

jump.up = function(num)
    if not num then num = \"\" end
    return CSI..num..\"A\"
end

jump.down = function(num)
    if not num then num = \"\" end
        return CSI..num..\"B\"
end

jump.forward = function(num)
    if not num then num = \"\" end
    return CSI..num..\"C\"
end

jump.back = function(num)
    if not num then num = \"\" end
    return CSI..num..\"D\"
end

local function Jump(_,row,column)
    return CSI..row..\";\"..column..\"H\"
end

local J = { __call = Jump}
setmetatable(jump,J)

_M[\"jump\"] = jump


return _M

"]
// END RANK codeblock_68


}
