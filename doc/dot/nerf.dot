digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 241"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-37"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 section_7 section_8}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 section_7 section_8}

header_2 [label="1 : Nerf mode"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

section_7 [label="section: 14-37"]

section_8 [label="section: 38-223"]


// END RANK section_1

header_2 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Nerf mode"]
// END RANK header_2

prose_3 -> { raw_10 prespace_11 literal_12 raw_13}
{rank=same; raw_10 prespace_11 literal_12 raw_13}

raw_10 [label="raw"]

prespace_11 [label="prespace"]

literal_12 [label="literal"]

raw_13 [label="raw"]


// END RANK prose_3

raw_10 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_10

prespace_11 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_11

literal_12 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="nerf"]
// END RANK literal_12

raw_13 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is the default mode for the repl.
"]
// END RANK raw_13

prose_4 -> { raw_18}
{rank=same; raw_18}

raw_18 [label="raw"]


// END RANK prose_4

raw_18 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
-  #Todo
"]
// END RANK raw_18

prose_5 -> { raw_20 prespace_21 literal_22 raw_23}
{rank=same; raw_20 prespace_21 literal_22 raw_23}

raw_20 [label="raw"]

prespace_21 [label="prespace"]

literal_22 [label="literal"]

raw_23 [label="raw"]


// END RANK prose_5

raw_20 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - [ ]  All of the content for the first draft is in"]
// END RANK raw_20

prespace_21 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_21

literal_22 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="modeselektor"]
// END RANK literal_22

raw_23 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", so
         let's transfer that.
"]
// END RANK raw_23

prose_6 -> { raw_28}
{rank=same; raw_28}

raw_28 [label="raw"]


// END RANK prose_6

raw_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - [?]  There should probably be a metatable for Mode objects.

"]
// END RANK raw_28

section_7 -> { header_30 prose_31 codeblock_32 codeblock_33}
{rank=same; header_30 prose_31 codeblock_32 codeblock_33}

header_30 [label="4 : includes"]

prose_31 [label="prose"]

codeblock_32 [label="code block 18-22"]

codeblock_33 [label="code block 24-35"]


// END RANK section_7

header_30 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** includes"]
// END RANK header_30

prose_31 -> { raw_35}
{rank=same; raw_35}

raw_35 [label="raw"]


// END RANK prose_31

raw_35 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is copypasta from Modeselektor, but yeah, we'll need most of this.
"]
// END RANK raw_35

codeblock_32 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="assert(meta, \"must have meta in _G\")
assert(write, \"must have write in _G\")
assert(ts, \"must have ts in _G\")"]
// END RANK codeblock_32

codeblock_33 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Txtbuf    = require \"txtbuf\"
local Rainbuf   = require \"rainbuf\"
local Historian = require \"historian\"
local Lex       = require \"lex\"
local a         = require \"anterm\"

local concat         = assert(table.concat)
local sub, gsub, rep = assert(string.sub),
                       assert(string.gsub),
                       assert(string.rep)"]
// END RANK codeblock_33

section_8 -> { header_39 prose_40 section_41 section_42 section_43 section_44}
{rank=same; header_39 prose_40 section_41 section_42 section_43 section_44}

header_39 [label="2 : Nerf"]

prose_40 [label="prose"]

section_41 [label="section: 41-64"]

section_42 [label="section: 65-193"]

section_43 [label="section: 194-223"]

section_44 [label="section: 224-241"]


// END RANK section_8

header_39 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Nerf"]
// END RANK header_39

prose_40 -> { raw_46}
{rank=same; raw_46}

raw_46 [label="raw"]


// END RANK prose_40

raw_46 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
// END RANK raw_46

section_41 -> { header_48 prose_49 codeblock_50 prose_51 codeblock_52}
{rank=same; header_48 prose_49 codeblock_50 prose_51 codeblock_52}

header_48 [label="3 : Categories"]

prose_49 [label="prose"]

codeblock_50 [label="code block 45-52"]

prose_51 [label="prose"]

codeblock_52 [label="code block 56-62"]


// END RANK section_41

header_48 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Categories"]
// END RANK header_48

prose_49 -> { raw_54}
{rank=same; raw_54}

raw_54 [label="raw"]


// END RANK prose_49

raw_54 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

These are the broad types of event.
"]
// END RANK raw_54

codeblock_50 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local ASCII  = meta {}
local NAV    = {}
local CTRL   = {}
local ALT    = {}
local FN     = {}
local NYI    = {}"]
// END RANK codeblock_50

prose_51 -> { raw_57}
{rank=same; raw_57}

raw_57 [label="raw"]


// END RANK prose_51

raw_57 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
While we will likely want a metatable going forward, this will do for now:
"]
// END RANK raw_57

codeblock_52 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Nerf = { ASCII  = ASCII,
                NAV    = NAV,
                CTRL   = CTRL,
                ALT    = ALT,
                NYI    = NYI }"]
// END RANK codeblock_52

section_42 -> { header_60 prose_61 codeblock_62 codeblock_63}
{rank=same; header_60 prose_61 codeblock_62 codeblock_63}

header_60 [label="3 : NAV"]

prose_61 [label="prose"]

codeblock_62 [label="code block 67-118"]

codeblock_63 [label="code block 124-189"]


// END RANK section_42

header_60 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** NAV"]
// END RANK header_60

prose_61 -> { raw_65}
{rank=same; raw_65}

raw_65 [label="raw"]


// END RANK prose_61

raw_65 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_65

codeblock_62 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local up1, down1 = a.jump.up(), a.jump.down()

function NAV.UP(modeS, category, value)
   modeS.firstChar = false
   local inline = modeS.txtbuf:up()
   if not inline then
      local prev_result, linestash
      if tostring(modeS.txtbuf) ~= \"\"
         and modeS.hist.cursor > #modeS.hist then
         linestash = modeS.txtbuf
      end
      modeS.txtbuf, prev_result = modeS.hist:prev()
      if linestash then
         modeS.hist:append(linestash)
      end
      if prev_result then
         modeS.zones.results:replace(Rainbuf(prev_result))
      else
         modeS.zones.results:replace \"\"
      end
   end

   return modeS
end

function NAV.DOWN(modeS, category, value)
   local inline = modeS.txtbuf:down()
   if not inline then
      local next_p, next_result, new_txtbuf
      new_txtbuf, next_result, next_p = modeS.hist:next()
      if next_p then
         modeS.firstChar = true
         local added = modeS.hist:append(modeS.txtbuf)
         if added then
            modeS.hist.cursor = #modeS.hist + 1
         end
         modeS.txtbuf = Txtbuf()
      else
         modeS.txtbuf = new_txtbuf
      end
      modeS:clearResults()
      if next_result then
         modeS.zones.results:replace(Rainbuf(next_result))
      else
         modeS.zones.results:replace \"\"
      end
   end

   return modeS
end"]
// END RANK codeblock_62

codeblock_63 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function NAV.LEFT(modeS, category, value)
   local moved = modeS.txtbuf:left()
   if not moved and modeS.txtbuf.cur_row ~= 1 then
      local cur_row = modeS.txtbuf.cur_row - 1
      modeS.txtbuf.cur_row = cur_row
      modeS.txtbuf.cursor = #modeS.txtbuf.lines[cur_row] + 1
   end
end

function NAV.RIGHT(modeS, category, value)
   local moved = modeS.txtbuf:right()
   if not moved and modeS.txtbuf.cur_row ~= #modeS.txtbuf.lines then
      modeS.txtbuf.cur_row = modeS.txtbuf.cur_row + 1
      modeS.txtbuf.cursor = 1
   end
end

function NAV.RETURN(modeS, category, value)
   -- eval or split line
   local eval = modeS.txtbuf:nl()
   if eval then
     local more = modeS:eval()
     if not more then
       modeS.txtbuf = Txtbuf()
       modeS.firstChar = true
     end
     modeS.hist.cursor = modeS.hist.cursor + 1
   end
end

local function _modeShiftOnEmpty(modeS)
   local buf = tostring(modeS.txtbuf)
   if buf == \"\" then
      modeS:shiftMode(modeS.raga_default)
      modeS.firstChar = true
      modeS:clearResults()
   end
end

function NAV.BACKSPACE(modeS, category, value)
   local shrunk =  modeS.txtbuf:d_back()
   _modeShiftOnEmpty(modeS)
end

function NAV.DELETE(modeS, category, value)
   local shrunk = modeS.txtbuf:d_fwd()
   _modeShiftOnEmpty(modeS)
end

function NAV.SHIFT_DOWN(modeS, category, value)
   local results = modeS.zones.results.contents
   if results.more then
      results.offset = results.offset + 1
      modeS.zones.results.touched = true
   end
end

function NAV.SHIFT_UP(modeS, category, value)
   local results = modeS.zones.results.contents
   if results.offset > 0 then
      results.offset = results.offset - 1
      modeS.zones.results.touched = true
   end
end"]
// END RANK codeblock_63

section_43 -> { header_69 prose_70 prose_71 codeblock_72}
{rank=same; header_69 prose_70 prose_71 codeblock_72}

header_69 [label="3 : CTRL"]

prose_70 [label="prose"]

prose_71 [label="prose"]

codeblock_72 [label="code block 200-221"]


// END RANK section_43

header_69 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** CTRL"]
// END RANK header_69

prose_70 -> { raw_74}
{rank=same; raw_74}

raw_74 [label="raw"]


// END RANK prose_70

raw_74 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Many/most of these will be re-used as e.g. \"^\" and \"$\" in vim mode.
"]
// END RANK raw_74

prose_71 -> { raw_76}
{rank=same; raw_76}

raw_76 [label="raw"]


// END RANK prose_71

raw_76 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Thus we will declare them as bare functions and assign them to slots.
"]
// END RANK raw_76

codeblock_72 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function cursor_begin(modeS, category, value)
   modeS.txtbuf.cursor = 1
end

CTRL[\"^A\"] = cursor_begin

local function cursor_end(modeS, category, value)
   modeS.txtbuf.cursor = #modeS.txtbuf.lines[modeS.txtbuf.cur_row] + 1
end

CTRL[\"^E\"] = cursor_end

local function clear_txtbuf(modeS, category, value)
   modeS.txtbuf = Txtbuf()
   modeS.hist.cursor = #modeS.hist + 1
   modeS.firstChar = true
   modeS.zones.results:replace \"\"
end

CTRL [\"^L\"] = clear_txtbuf"]
// END RANK codeblock_72

section_44 -> { header_79 prose_80 codeblock_81 codeblock_82}
{rank=same; header_79 prose_80 codeblock_81 codeblock_82}

header_79 [label="3 : MOUSE"]

prose_80 [label="prose"]

codeblock_81 [label="code block 226-236"]

codeblock_82 [label="code block 238-240"]


// END RANK section_44

header_79 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** MOUSE"]
// END RANK header_79

prose_80 -> { raw_84}
{rank=same; raw_84}

raw_84 [label="raw"]


// END RANK prose_80

raw_84 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_84

codeblock_81 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Nerf.MOUSE(modeS, category, value)
   if value.scrolling then
      if value.button == \"MB0\" then
         modeS.modes.NAV.SHIFT_UP(modeS, category, value)
      elseif value.button == \"MB1\" then
         modeS.modes.NAV.SHIFT_DOWN(modeS, category, value)
      end
   end
end"]
// END RANK codeblock_81

codeblock_82 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return Nerf"]
// END RANK codeblock_82


}
