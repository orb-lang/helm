digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 321"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-54"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 prose_7 codeblock_8 section_9}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 prose_7 codeblock_8 section_9}

header_2 [label="1 : Color"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

prose_7 [label="prose"]

codeblock_8 [label="code block 20-51"]

section_9 [label="section: 55-253"]


// END RANK section_1

header_2 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Color"]
// END RANK header_2

prose_3 -> { raw_11}
{rank=same; raw_11}

raw_11 [label="raw"]


// END RANK prose_3

raw_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


Colorizer and all-purpose pretty printer.
"]
// END RANK raw_11

prose_4 -> { raw_13 prespace_14 literal_15 raw_16}
{rank=same; raw_13 prespace_14 literal_15 raw_16}

raw_13 [label="raw"]

prespace_14 [label="prespace"]

literal_15 [label="literal"]

raw_16 [label="raw"]


// END RANK prose_4

raw_13 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The main event is"]
// END RANK raw_13

prespace_14 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_14

literal_15 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ts(value)"]
// END RANK literal_15

raw_16 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", which unwraps tables, looks up
names for things, and otherwise makes itself useful.
"]
// END RANK raw_16

prose_5 -> { raw_21 prespace_22 literal_23 raw_24 prespace_25 literal_26 raw_27}
{rank=same; raw_21 prespace_22 literal_23 raw_24 prespace_25 literal_26 raw_27}

raw_21 [label="raw"]

prespace_22 [label="prespace"]

literal_23 [label="literal"]

raw_24 [label="raw"]

prespace_25 [label="prespace"]

literal_26 [label="literal"]

raw_27 [label="raw"]


// END RANK prose_5

raw_21 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The"]
// END RANK raw_21

prespace_22 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_22

literal_23 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="color"]
// END RANK literal_23

raw_24 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" table can be overridden by the user, but this must
be on the field level.  A local pointer to the table is retained for
efficiency of coding and execution.  Same with the"]
// END RANK raw_24

prespace_25 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_25

literal_26 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="color.hints"]
// END RANK literal_26

raw_27 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" table, change
references at the value level.
"]
// END RANK raw_27

prose_6 -> { raw_35 prespace_36 literal_37 raw_38 prespace_39 literal_40 raw_41}
{rank=same; raw_35 prespace_36 literal_37 raw_38 prespace_39 literal_40 raw_41}

raw_35 [label="raw"]

prespace_36 [label="prespace"]

literal_37 [label="literal"]

raw_38 [label="raw"]

prespace_39 [label="prespace"]

literal_40 [label="literal"]

raw_41 [label="raw"]


// END RANK prose_6

raw_35 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The third relevant field is a method,"]
// END RANK raw_35

prespace_36 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_36

literal_37 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="C.allNames()"]
// END RANK literal_37

raw_38 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  There is an"]
// END RANK raw_38

prespace_39 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_39

literal_40 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="anti_G"]
// END RANK literal_40

raw_41 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
object, this method populates it with every reachable name for an object,
keyed with the value itself.
"]
// END RANK raw_41

prose_7 -> { prespace_49 literal_50 raw_51 prespace_52 literal_53 raw_54}
{rank=same; prespace_49 literal_50 raw_51 prespace_52 literal_53 raw_54}

prespace_49 [label="prespace"]

literal_50 [label="literal"]

raw_51 [label="raw"]

prespace_52 [label="prespace"]

literal_53 [label="literal"]

raw_54 [label="raw"]


// END RANK prose_7

prespace_49 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_49

literal_50 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="C.clearNames()"]
// END RANK literal_50

raw_51 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" sets this table to"]
// END RANK raw_51

prespace_52 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_52

literal_53 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="{}"]
// END RANK literal_53

raw_54 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_54

codeblock_8 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local a = require \"anterm\"

local core = require \"core\"

local WIDE_TABLE = 200 -- should be tty-specific

local C = {}

local thread_shade = a.fg24(240, 50, 100)

local function thread_color(str)
   return a.italic .. thread_shade .. str .. a.clear
end

C.color = {}
C.color.number = a.fg(42)
C.color.string = a.fg(222)
C.color.stresc = a.fg(225)
C.color.table  = a.fg(64)
C.color.func   = a.fg24(210,12,120)
C.color.truth  = a.fg(231)
C.color.falsehood  = a.fg(94)
C.color.nilness    = a.fg(93)
C.color.thread     = thread_color
C.color.field      = a.fg(111)
C.color.userdata   = a.fg24(230, 145, 23)
C.color.cdata      = a.fg24(200, 115, 0)
C.color.alert      = a.fg24(250, 0, 40)
C.color.base       = a.fg24(200, 200, 200)
C.color.metatable  = a.fg24(242, 0, 234)"]
// END RANK codeblock_8

section_9 -> { header_62 prose_63 section_64 section_65 section_66 section_67 section_68}
{rank=same; header_62 prose_63 section_64 section_65 section_66 section_67 section_68}

header_62 [label="2 : ts(value)"]

prose_63 [label="prose"]

section_64 [label="section: 58-73"]

section_65 [label="section: 74-87"]

section_66 [label="section: 88-151"]

section_67 [label="section: 152-253"]

section_68 [label="section: 254-321"]


// END RANK section_9

header_62 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** ts(value)"]
// END RANK header_62

prose_63 -> { raw_70}
{rank=same; raw_70}

raw_70 [label="raw"]


// END RANK prose_63

raw_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
// END RANK raw_70

section_64 -> { header_72 prose_73 codeblock_74}
{rank=same; header_72 prose_73 codeblock_74}

header_72 [label="4 : setup"]

prose_73 [label="prose"]

codeblock_74 [label="code block 62-71"]


// END RANK section_64

header_72 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** setup"]
// END RANK header_72

prose_73 -> { raw_76 prespace_77 literal_78 raw_79}
{rank=same; raw_76 prespace_77 literal_78 raw_79}

raw_76 [label="raw"]

prespace_77 [label="prespace"]

literal_78 [label="literal"]

raw_79 [label="raw"]


// END RANK prose_73

raw_76 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Localize a few values and create an anti-"]
// END RANK raw_76

prespace_77 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_77

literal_78 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_G"]
// END RANK literal_78

raw_79 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" table.
"]
// END RANK raw_79

codeblock_74 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="C.color.hints = { field = C.color.field,
                  fn    = C.color.func,
                  mt    = C.color.mt }

local hints = C.color.hints

local c = C.color
local anti_G = { _G = \"_G\" }"]
// END RANK codeblock_74

section_65 -> { header_85 prose_86 prose_87 codeblock_88}
{rank=same; header_85 prose_86 prose_87 codeblock_88}

header_85 [label="4 : tie_break(old, new)"]

prose_86 [label="prose"]

prose_87 [label="prose"]

codeblock_88 [label="code block 81-85"]


// END RANK section_65

header_85 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** tie_break(old, new)"]
// END RANK header_85

prose_86 -> { raw_90}
{rank=same; raw_90}

raw_90 [label="raw"]


// END RANK prose_86

raw_90 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A helper function to decide which name is better.
"]
// END RANK raw_90

prose_87 -> { raw_92 prespace_93 literal_94 raw_95}
{rank=same; raw_92 prespace_93 literal_94 raw_95}

raw_92 [label="raw"]

prespace_93 [label="prespace"]

literal_94 [label="literal"]

raw_95 [label="raw"]


// END RANK prose_87

raw_92 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To really dig out a good name for metatables we're going to need to write"]
// END RANK raw_92

prespace_93 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_93

literal_94 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="use"]
// END RANK literal_94

raw_95 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_95

codeblock_88 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function tie_break(old, new)
   return #old > #new
end"]
// END RANK codeblock_88

section_66 -> { header_101 prose_102 codeblock_103}
{rank=same; header_101 prose_102 codeblock_103}

header_101 [label="3 : C.allNames()"]

prose_102 [label="prose"]

codeblock_103 [label="code block 93-149"]


// END RANK section_66

header_101 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** C.allNames()"]
// END RANK header_101

prose_102 -> { raw_105 prespace_106 literal_107 raw_108}
{rank=same; raw_105 prespace_106 literal_107 raw_108}

raw_105 [label="raw"]

prespace_106 [label="prespace"]

literal_107 [label="literal"]

raw_108 [label="raw"]


// END RANK prose_102

raw_105 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


Ransacks"]
// END RANK raw_105

prespace_106 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_106

literal_107 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_G"]
// END RANK literal_107

raw_108 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" looking for names to put on things.
"]
// END RANK raw_108

codeblock_103 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function addName(t, aG, pre)
   pre = pre or \"\"
   aG = aG or anti_G
   if pre ~= \"\" then
      pre = pre .. \".\"
   end
   for k, v in pairs(t) do
      T = type(v)
      if (T == \"table\") then
         key = pre .. k
         if not aG[v] then
            aG[v] = key
            if not (pre == \"\" and k == \"package\") then
               addName(v, aG, key)
            end
         else
            local kv = aG[v]
            if tie_break(kv, key) then
               -- quadradic lol
               aG[v] = key
               addName(v, aG, key)
            end
         end
         local _M = getmetatable(v)
         local _M_id = _M and \"⟨\" .. pre .. k .. \"⟩\" or \"\"
         if _M then
            if not aG[_M] then
               addName(_M, aG, _M_id)
               aG[_M] = _M_id
            else
               local aG_M_id = aG[_M]
               if tie_break(aG_M_id, _M_id) then
                  addName(_M, aG, _M_id)
                  aG[_M] = _M_id
               end
            end
         end
      elseif T == \"function\" or
         T == \"thread\" or
         T == \"userdata\" or
         T == \"cdata\" then
         aG[v] = pre .. k
      end
   end
   return aG
end

function C.allNames()
   return addName(_G)
end

function C.clearNames()
   anti_G = {_G = \"_G\"}
   return anti_G
end"]
// END RANK codeblock_103

section_67 -> { header_114 prose_115 codeblock_116 prose_117 codeblock_118}
{rank=same; header_114 prose_115 codeblock_116 prose_117 codeblock_118}

header_114 [label="3 : tabulator"]

prose_115 [label="prose"]

codeblock_116 [label="code block 156-215"]

prose_117 [label="prose"]

codeblock_118 [label="code block 220-251"]


// END RANK section_67

header_114 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** tabulator"]
// END RANK header_114

prose_115 -> { raw_120}
{rank=same; raw_120}

raw_120 [label="raw"]


// END RANK prose_115

raw_120 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is mostly [[Tim Caswell's][https://github.com/creationix]] code.
"]
// END RANK raw_120

codeblock_116 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local ts
local function tabulate(tab, depth)
   if type(tab) ~= \"table\" then
      return ts(tab)
   end
   if type(depth) == \"nil\" then
      depth = 0
   end
   if depth > 3 then
      return ts(tab, \"tab_name\")
   end
   local indent = (\"  \"):rep(depth)
   -- Check to see if this is an array
   local is_array = true
   local i = 1
   for k,v in pairs(tab) do
      if not (k == i) then
         is_array = false
      end
      i = i + 1
   end
   local first = true
   local lines = {}
   -- if we have a metatable, get it first
   local mt = \"\"
   local _M = getmetatable(tab)
   if _M then
      mt = ts(tab, \"mt\") .. c.base(\" = \") .. tabulate(_M, depth + 1)
      lines[1] = mt
      i = 2
   else
      i = 1
   end
   local estimated = 0
   for k,v in (is_array and ipairs or pairs)(tab) do
      local s
      if is_array then
         s = \"\"
      else
         if type(k) == \"string\" and k:find(\"^[%a_][%a%d_]*$\") then
            s = ts(k) .. c.base(\" = \")
         else
            s = c.base(\"[\") .. tabulate(k, 100) .. c.base(\"] = \")
         end
      end
      s = s .. tabulate(v, depth + 1)
      lines[i] = s
      estimated = estimated + #s
      i = i + 1
   end
   if estimated > WIDE_TABLE then
      return c.base(\"{\\n  \") .. indent
         .. table.concat(lines, \",\\n  \" .. indent)
         .. \"\\n\" .. indent .. c.base(\"}\")
   else
      return c.base(\"{ \") .. table.concat(lines, c.base(\", \")) .. c.base(\" }\")
   end
end"]
// END RANK codeblock_116

prose_117 -> { raw_123}
{rank=same; raw_123}

raw_123 [label="raw"]


// END RANK prose_117

raw_123 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We make a small wrapper function which resets string color in between
escapes, then gsub the daylights out of it.
"]
// END RANK raw_123

codeblock_118 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local find, sub, gsub, byte = string.find, string.sub,
                              string.gsub, string.byte

local e = function(str)
   return c.stresc .. str .. c.string
end

-- Turn control characters into their byte rep,
-- preserving escapes
local function ctrl_pr(str)
   if byte(str) ~= 27 then
      return e(\"\\\\\" .. byte(str))
   else
      return str
   end
end

scrub = function (str)
   return str:gsub(\"\\27\", e \"\\\\x1b\")
             :gsub('\"',  e '\\\\\"')
             :gsub(\"'\",  e \"\\\\'\")
             :gsub(\"\\a\", e \"\\\\a\")
             :gsub(\"\\b\", e \"\\\\b\")
             :gsub(\"\\f\", e \"\\\\f\")
             :gsub(\"\\n\", e \"\\\\n\")
             :gsub(\"\\r\", e \"\\\\r\")
             :gsub(\"\\t\", e \"\\\\t\")
             :gsub(\"\\v\", e \"\\\\v\")
             :gsub(\"%c\", ctrl_pr)
end"]
// END RANK codeblock_118

section_68 -> { header_126 prose_127 codeblock_128 codeblock_129}
{rank=same; header_126 prose_127 codeblock_128 codeblock_129}

header_126 [label="3 : ts"]

prose_127 [label="prose"]

codeblock_128 [label="code block 258-317"]

codeblock_129 [label="code block 319-321"]


// END RANK section_68

header_126 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** ts"]
// END RANK header_126

prose_127 -> { raw_131}
{rank=same; raw_131}

raw_131 [label="raw"]


// END RANK prose_127

raw_131 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Lots of small, nice things in this one.
"]
// END RANK raw_131

codeblock_128 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ts = function (value, hint)
   local str = scrub(tostring(value))
   -- For cases more specific than mere type,
   -- we have hints:
   if hint == \"\" then
      return str -- or just use tostring()?
   end
   if hint then
      if hint == \"tab_name\" then
         local tab_name = anti_G[value] or \"t:\" .. sub(str, -6)
         return c.table(tab_name)
      elseif hint == \"mt\" then
         local mt_name = anti_G[value] or \"mt:\" .. sub(str, -6)
         return c.metatable(\"⟨\" .. mt_name .. \"⟩\")
      else
         return hints[hint](str)
      end
   end

   local typica = type(value)
   if typica == \"number\" then
      str = c.number(str)
   elseif typica == \"table\" then
      str = tabulate(value)
   elseif typica == \"function\" then
      local func_name = anti_G[value] or \"f:\" .. sub(str, -6)
      str = c.func(func_name)
   elseif typica == \"boolean\" then
      str = value and c.truth(str) or c.falsehood(str)
   elseif typica == \"string\" then
      str = c.string(str)
   elseif typica == \"nil\" then
      str = c.nilness(str)
   elseif typica == \"thread\" then
      local coro_name = anti_G[value] and \"coro:\" .. anti_G[value]
                                      or  \"coro:\" .. sub(str, -6)
      str = c.thread(coro_name)
   elseif typica == \"userdata\" then
      if anti_G[value] then
         str = c.userdata(anti_G[value])
      else
         local name = find(str, \":\")
         if name then
            str = c.userdata(sub(str, 1, name - 1))
         else
            str = c.userdata(str)
         end
      end
   elseif typica == \"cdata\" then
      if anti_G[value] then
         str = c.cdata(anti_G[value])
      else
         str = c.cdata(str)
      end
   end
   return str
end
C.ts = ts"]
// END RANK codeblock_128

codeblock_129 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return C"]
// END RANK codeblock_129


}
