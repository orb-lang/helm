digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 719"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-610"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 section_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13 section_14 section_15 section_16}
{rank=same; header_2 prose_3 prose_4 prose_5 section_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13 section_14 section_15 section_16}

header_2 [label="1 : Repr"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

section_6 [label="section: 14-24"]

section_7 [label="section: 25-36"]

section_8 [label="section: 37-49"]

section_9 [label="section: 50-116"]

section_10 [label="section: 135-168"]

section_11 [label="section: 169-206"]

section_12 [label="section: 207-295"]

section_13 [label="section: 296-392"]

section_14 [label="section: 508-548"]

section_15 [label="section: 549-610"]

section_16 [label="section: 611-719"]


// END RANK section_1

header_2 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Repr"]
// END RANK header_2

prose_3 -> { raw_18 prespace_19 literal_20 raw_21}
{rank=same; raw_18 prespace_19 literal_20 raw_21}

raw_18 [label="raw"]

prespace_19 [label="prespace"]

literal_20 [label="literal"]

raw_21 [label="raw"]


// END RANK prose_3

raw_18 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_18

prespace_19 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_19

literal_20 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="repr"]
// END RANK literal_20

raw_21 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is our general-purpose pretty-printer.
"]
// END RANK raw_21

prose_4 -> { raw_26}
{rank=same; raw_26}

raw_26 [label="raw"]


// END RANK prose_4

raw_26 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is undergoing a huge refactor to make it iterable, so it yields one
line at a time and won't get hung up on enormous tables.
"]
// END RANK raw_26

prose_5 -> { raw_28}
{rank=same; raw_28}

raw_28 [label="raw"]


// END RANK prose_5

raw_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Currently we yield most things, and are working our way toward providing an
iterator that itself returns one line at a time until it reaches the end of
the repr.

"]
// END RANK raw_28

section_6 -> { header_30 prose_31 codeblock_32}
{rank=same; header_30 prose_31 codeblock_32}

header_30 [label="4 : imports"]

prose_31 [label="prose"]

codeblock_32 [label="code block 16-22"]


// END RANK section_6

header_30 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** imports"]
// END RANK header_30

prose_31 -> { raw_34}
{rank=same; raw_34}

raw_34 [label="raw"]


// END RANK prose_31

raw_34 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_34

codeblock_32 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local a = require \"anterm\"

local core = require \"core\"

local C = require \"color\""]
// END RANK codeblock_32

section_7 -> { header_37 prose_38 codeblock_39}
{rank=same; header_37 prose_38 codeblock_39}

header_37 [label="4 : setup"]

prose_38 [label="prose"]

codeblock_39 [label="code block 27-34"]


// END RANK section_7

header_37 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** setup"]
// END RANK header_37

prose_38 -> { raw_41}
{rank=same; raw_41}

raw_41 [label="raw"]


// END RANK prose_38

raw_41 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_41

codeblock_39 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local repr = {}

local hints = C.color.hints

local c = C.color"]
// END RANK codeblock_39

section_8 -> { header_44 prose_45 codeblock_46 prose_47}
{rank=same; header_44 prose_45 codeblock_46 prose_47}

header_44 [label="3 : anti_G"]

prose_45 [label="prose"]

codeblock_46 [label="code block 43-45"]

prose_47 [label="prose"]


// END RANK section_8

header_44 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** anti_G"]
// END RANK header_44

prose_45 -> { raw_49 prespace_50 literal_51 raw_52 prespace_53 literal_54 raw_55 prespace_56 literal_57 raw_58}
{rank=same; raw_49 prespace_50 literal_51 raw_52 prespace_53 literal_54 raw_55 prespace_56 literal_57 raw_58}

raw_49 [label="raw"]

prespace_50 [label="prespace"]

literal_51 [label="literal"]

raw_52 [label="raw"]

prespace_53 [label="prespace"]

literal_54 [label="literal"]

raw_55 [label="raw"]

prespace_56 [label="prespace"]

literal_57 [label="literal"]

raw_58 [label="raw"]


// END RANK prose_45

raw_49 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

In order to provide names for values, we want to trawl through"]
// END RANK raw_49

prespace_50 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_50

literal_51 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_G"]
// END RANK literal_51

raw_52 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and
acquire them.  This table is from value to key where"]
// END RANK raw_52

prespace_53 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_53

literal_54 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_G"]
// END RANK literal_54

raw_55 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is key to value,
hence,"]
// END RANK raw_55

prespace_56 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_56

literal_57 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="anti_G"]
// END RANK literal_57

raw_58 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_58

codeblock_46 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local anti_G = { _G = \"_G\" }"]
// END RANK codeblock_46

prose_47 -> { raw_70}
{rank=same; raw_70}

raw_70 [label="raw"]


// END RANK prose_47

raw_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Now to populate it:

"]
// END RANK raw_70

section_9 -> { header_72 prose_73 prose_74 section_75 section_76}
{rank=same; header_72 prose_73 prose_74 section_75 section_76}

header_72 [label="3 : C.allNames()"]

prose_73 [label="prose"]

prose_74 [label="prose"]

section_75 [label="section: 59-116"]

section_76 [label="section: 117-134"]


// END RANK section_9

header_72 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** C.allNames()"]
// END RANK header_72

prose_73 -> { raw_78 prespace_79 literal_80 raw_81}
{rank=same; raw_78 prespace_79 literal_80 raw_81}

raw_78 [label="raw"]

prespace_79 [label="prespace"]

literal_80 [label="literal"]

raw_81 [label="raw"]


// END RANK prose_73

raw_78 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Ransacks"]
// END RANK raw_78

prespace_79 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_79

literal_80 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_G"]
// END RANK literal_80

raw_81 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" looking for names to put on things.
"]
// END RANK raw_81

prose_74 -> { raw_86}
{rank=same; raw_86}

raw_86 [label="raw"]


// END RANK prose_74

raw_86 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To really dig out a good name for metatables we're going to need to write
some kind of reflection function that will dig around in upvalues to find
local names for things.

"]
// END RANK raw_86

section_75 -> { header_88 prose_89 codeblock_90}
{rank=same; header_88 prose_89 codeblock_90}

header_88 [label="4 : tie_break(old, new)"]

prose_89 [label="prose"]

codeblock_90 [label="code block 63-114"]


// END RANK section_75

header_88 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** tie_break(old, new)"]
// END RANK header_88

prose_89 -> { raw_92}
{rank=same; raw_92}

raw_92 [label="raw"]


// END RANK prose_89

raw_92 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A helper function to decide which name is better.
"]
// END RANK raw_92

codeblock_90 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function tie_break(old, new)
   return #old > #new
end

local function addName(t, aG, pre)
   pre = pre or \"\"
   aG = aG or anti_G
   if pre ~= \"\" then
      pre = pre .. \".\"
   end
   for k, v in pairs(t) do
      local T = type(v)
      if (T == \"table\") then
         local key = pre ..
            (type(k) == \"string\" and k or \"<\" .. type(k) .. \">\")
         if not aG[v] then
            aG[v] = key
            if not (pre == \"\" and k == \"package\") then
               addName(v, aG, key)
            end
         else
            local kv = aG[v]
            if tie_break(kv, key) then
               -- quadradic lol
               aG[v] = key
               addName(v, aG, key)
            end
         end
         local _M = getmetatable(v)
         local _M_id = _M and \"⟨\" .. key.. \"⟩\" or \"\"
         if _M then
            if not aG[_M] then
               addName(_M, aG, _M_id)
               aG[_M] = _M_id
            else
               local aG_M_id = aG[_M]
               if tie_break(aG_M_id, _M_id) then
                  addName(_M, aG, _M_id)
                  aG[_M] = _M_id
               end
            end
         end
      elseif T == \"function\" or
         T == \"thread\" or
         T == \"userdata\" then
         aG[v] = pre .. k
      end
   end
   return aG
end"]
// END RANK codeblock_90

section_76 -> { header_95 prose_96 codeblock_97}
{rank=same; header_95 prose_96 codeblock_97}

header_95 [label="4 : repr.allNames(), repr.clearNames()"]

prose_96 [label="prose"]

codeblock_97 [label="code block 122-132"]


// END RANK section_76

header_95 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** repr.allNames(), repr.clearNames()"]
// END RANK header_95

prose_96 -> { raw_99 prespace_100 literal_101 raw_102 prespace_103 literal_104 raw_105}
{rank=same; raw_99 prespace_100 literal_101 raw_102 prespace_103 literal_104 raw_105}

raw_99 [label="raw"]

prespace_100 [label="prespace"]

literal_101 [label="literal"]

raw_102 [label="raw"]

prespace_103 [label="prespace"]

literal_104 [label="literal"]

raw_105 [label="raw"]


// END RANK prose_96

raw_99 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The trick here is that we scan"]
// END RANK raw_99

prespace_100 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_100

literal_101 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="package.loaded"]
// END RANK literal_101

raw_102 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" after"]
// END RANK raw_102

prespace_103 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_103

literal_104 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_G"]
// END RANK literal_104

raw_105 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", which gives
better names for things.
"]
// END RANK raw_105

codeblock_97 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function repr.allNames(tab)
   tab = tab or _G
   return addName(package.loaded, addName(tab))
end

function repr.clearNames()
   anti_G = {_G = \"_G\"}
   return anti_G
end"]
// END RANK codeblock_97

section_10 -> { header_114 prose_115 prose_116 codeblock_117}
{rank=same; header_114 prose_115 prose_116 codeblock_117}

header_114 [label="3 : tabulator"]

prose_115 [label="prose"]

prose_116 [label="prose"]

codeblock_117 [label="code block 143-166"]


// END RANK section_10

header_114 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** tabulator"]
// END RANK header_114

prose_115 -> { raw_119}
{rank=same; raw_119}

raw_119 [label="raw"]


// END RANK prose_115

raw_119 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is fundamentally [[Tim Caswell's][https://github.com/creationix]] code.
"]
// END RANK raw_119

prose_116 -> { raw_121}
{rank=same; raw_121}

raw_121 [label="raw"]


// END RANK prose_116

raw_121 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I've dressed it up a bit. Okay, a lot.
"]
// END RANK raw_121

codeblock_117 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local ts, ts_coro

local SORT_LIMIT = 500  -- This won't be necessary #todo remove

local coro = coro or coroutine

local yield, wrap = coro.yield, coro.wrap

local concat, insert, remove = table.concat, table.insert, table.remove

local function _keysort(a, b)
   if (type(a) == \"string\" and type(b) == \"string\")
      or (type(a) == \"number\" and type(b) == \"number\") then
      return a < b
   elseif type(a) == \"number\" and type(b) == \"string\" then
      return true
   elseif type(a) == \"string\" and type(b) == \"number\" then
      return false
   else
      return false
   end
end"]
// END RANK codeblock_117

section_11 -> { header_124 prose_125 prose_126 prose_127 prose_128 codeblock_129}
{rank=same; header_124 prose_125 prose_126 prose_127 prose_128 codeblock_129}

header_124 [label="3 : _yieldReprs(tab, disp)"]

prose_125 [label="prose"]

prose_126 [label="prose"]

prose_127 [label="prose"]

prose_128 [label="prose"]

codeblock_129 [label="code block 183-205"]


// END RANK section_11

header_124 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** _yieldReprs(tab, disp)"]
// END RANK header_124

prose_125 -> { raw_131 prespace_132 literal_133 raw_134 prespace_135 literal_136 raw_137}
{rank=same; raw_131 prespace_132 literal_133 raw_134 prespace_135 literal_136 raw_137}

raw_131 [label="raw"]

prespace_132 [label="prespace"]

literal_133 [label="literal"]

raw_134 [label="raw"]

prespace_135 [label="prespace"]

literal_136 [label="literal"]

raw_137 [label="raw"]


// END RANK prose_125

raw_131 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

I want to deliver"]
// END RANK raw_131

prespace_132 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_132

literal_133 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__repr"]
// END RANK literal_133

raw_134 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="s from inside the funky coroutine brew,
because, well, because."]
// END RANK raw_134

prespace_135 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_135

literal_136 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ts"]
// END RANK literal_136

raw_137 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is meant to be general.
"]
// END RANK raw_137

prose_126 -> { raw_145}
{rank=same; raw_145}

raw_145 [label="raw"]


// END RANK prose_126

raw_145 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I also want a lot of flexibility in how reprs are written, so we need to
handle several cases.
"]
// END RANK raw_145

prose_127 -> { raw_147}
{rank=same; raw_147}

raw_147 [label="raw"]


// END RANK prose_127

raw_147 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We're going to start with returning a string, and returning an iterator.
"]
// END RANK raw_147

prose_128 -> { raw_149}
{rank=same; raw_149}

raw_149 [label="raw"]


// END RANK prose_128

raw_149 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I might get around to returning tables with tokens in them and other intel,
I might not; I do have plans that are broader than merely writing an
incredibly intricate repl.
"]
// END RANK raw_149

codeblock_129 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function _yieldReprs(tab, phrase)
   local _repr = getmetatable(tab).__repr
   assert(c, \"must have a value for c\")
   local repr = _repr(tab, phrase, c)
   local yielder
   if type(repr) == \"string\" then
      yielder = string.lines(repr)
   else
      yielder = repr
   end
   while true do
      local line, len = yielder()
      if line ~= nil then
         len = len or #line
         yield(line, len, \"repr_line\")
      else
         break
      end
   end
end
"]
// END RANK codeblock_129

section_12 -> { header_152 prose_153 prose_154 codeblock_155 prose_156 prose_157}
{rank=same; header_152 prose_153 prose_154 codeblock_155 prose_156 prose_157}

header_152 [label="3 : _tabulate(tab, depth, cycle, phrase)"]

prose_153 [label="prose"]

prose_154 [label="prose"]

codeblock_155 [label="code block 214-285"]

prose_156 [label="prose"]

prose_157 [label="prose"]


// END RANK section_12

header_152 -> leaf_158
leaf_158  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** _tabulate(tab, depth, cycle, phrase)"]
// END RANK header_152

prose_153 -> { raw_159 prespace_160 literal_161 raw_162}
{rank=same; raw_159 prespace_160 literal_161 raw_162}

raw_159 [label="raw"]

prespace_160 [label="prespace"]

literal_161 [label="literal"]

raw_162 [label="raw"]


// END RANK prose_153

raw_159 -> leaf_163
leaf_163  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This"]
// END RANK raw_159

prespace_160 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_160

literal_161 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label="yield()s"]
// END RANK literal_161

raw_162 -> leaf_166
leaf_166  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" pieces of a table, recursively, one at a time.
"]
// END RANK raw_162

prose_154 -> { raw_167}
{rank=same; raw_167}

raw_167 [label="raw"]


// END RANK prose_154

raw_167 -> leaf_168
leaf_168  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Second return value is the printed width, third, if any, is a string
representing what we're opening and/or closing.
"]
// END RANK raw_167

codeblock_155 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local O_BRACE = function() return c.base \"{\" end
local C_BRACE = function() return c.base \"}\" end
local COMMA, COM_LEN = function() return c.base \", \" end, 2

local function _tabulate(tab, depth, cycle, phrase)
   cycle = cycle or {}
   depth = depth or 0
   if type(tab) ~= \"table\" then
      ts_coro(tab, nil, phrase)
      return nil
   end
   if depth > C.depth or cycle[tab] then
      ts_coro(tab, \"tab_name\", phrase)
      return nil
   end
   cycle[tab] = true
   -- if we have a metatable, get it first
   local _M = getmetatable(tab)
   if _M then
      ---[[special case tables with __repr
      if _M.__repr then
         _yieldReprs(tab, phrase)
         return nil
      end
      --]]
      --otherwise print the metatable normally
      ts_coro(tab, \"mt\", phrase)
      yield(c.base(\" = \"), 3)
      _tabulate(_M, depth + 1, cycle, phrase)
   end
   -- Check to see if this is an array
   local is_array = true
   local i = 1
   for k,_ in pairs(tab) do
      is_array = is_array and (k == i)
      i = i + 1
   end

   local keys
   if not is_array then
      keys = table.keys(tab)
      if #keys <= SORT_LIMIT then
         table.sort(keys, _keysort)
      end
   else
      keys = tab
   end
   yield(O_BRACE(), 1, (is_array and \"array\" or \"map\"))

   for j, key in ipairs(keys) do
      if is_array then
         _tabulate(key, depth + 1, cycle, phrase)
      else
         val = tab[key]
         if type(key) == \"string\" and key:find(\"^[%a_][%a%d_]*$\") then
            ts_coro(key, nil, phrase)
            yield(c.base(\" = \"), 3)
         else
            yield(c.base(\"[\"), 1)
               -- we want names or hashes for any lvalue table,
               -- 100 triggers this
            _tabulate(key, 100, cycle, phrase)
            yield(c.base(\"] = \"), 4)
         end
         _tabulate(val, depth + 1, cycle, phrase)
      end
   end
   yield(C_BRACE(), 1, \"end\")
   return nil
end"]
// END RANK codeblock_155

prose_156 -> { raw_170}
{rank=same; raw_170}

raw_170 [label="raw"]


// END RANK prose_156

raw_170 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
line-buffer goes here
"]
// END RANK raw_170

prose_157 -> { raw_172 prespace_173 literal_174 raw_175 prespace_176 literal_177 raw_178 prespace_179 literal_180 raw_181 prespace_182 literal_183 raw_184}
{rank=same; raw_172 prespace_173 literal_174 raw_175 prespace_176 literal_177 raw_178 prespace_179 literal_180 raw_181 prespace_182 literal_183 raw_184}

raw_172 [label="raw"]

prespace_173 [label="prespace"]

literal_174 [label="literal"]

raw_175 [label="raw"]

prespace_176 [label="prespace"]

literal_177 [label="literal"]

raw_178 [label="raw"]

prespace_179 [label="prespace"]

literal_180 [label="literal"]

raw_181 [label="raw"]

prespace_182 [label="prespace"]

literal_183 [label="literal"]

raw_184 [label="raw"]


// END RANK prose_157

raw_172 -> leaf_185
leaf_185  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
needs to decide when things are 'wide enough' so each yield needs to return"]
// END RANK raw_172

prespace_173 -> leaf_186
leaf_186  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_173

literal_174 -> leaf_187
leaf_187  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str, len, done"]
// END RANK literal_174

raw_175 -> leaf_188
leaf_188  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", where"]
// END RANK raw_175

prespace_176 -> leaf_189
leaf_189  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_176

literal_177 -> leaf_190
leaf_190  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
// END RANK literal_177

raw_178 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is the fragment of string,"]
// END RANK raw_178

prespace_179 -> leaf_192
leaf_192  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_179

literal_180 -> leaf_193
leaf_193  [color=Gray,shape=rectangle,fontname=Inconsolata,label="len"]
// END RANK literal_180

raw_181 -> leaf_194
leaf_194  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is a number
representing its printable width (don't @ me) and"]
// END RANK raw_181

prespace_182 -> leaf_195
leaf_195  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_182

literal_183 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label="done"]
// END RANK literal_183

raw_184 -> leaf_197
leaf_197  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is a boolean for if
this is the last bit of the repr of a given thing. Table, userdata, what
have you.

"]
// END RANK raw_184

section_13 -> { header_198 prose_199 prose_200 prose_201 prose_202 section_203 section_204}
{rank=same; header_198 prose_199 prose_200 prose_201 prose_202 section_203 section_204}

header_198 [label="3 : tabulate(tab, depth, cycle)"]

prose_199 [label="prose"]

prose_200 [label="prose"]

prose_201 [label="prose"]

prose_202 [label="prose"]

section_203 [label="section: 313-392"]

section_204 [label="section: 393-507"]


// END RANK section_13

header_198 -> leaf_205
leaf_205  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** tabulate(tab, depth, cycle)"]
// END RANK header_198

prose_199 -> { raw_206}
{rank=same; raw_206}

raw_206 [label="raw"]


// END RANK prose_199

raw_206 -> leaf_207
leaf_207  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is going to undergo several metamorpheses as we make progress.
"]
// END RANK raw_206

prose_200 -> { raw_208 prespace_209 literal_210 raw_211}
{rank=same; raw_208 prespace_209 literal_210 raw_211}

raw_208 [label="raw"]

prespace_209 [label="prespace"]

literal_210 [label="literal"]

raw_211 [label="raw"]


// END RANK prose_200

raw_208 -> leaf_212
leaf_212  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
For now, we have the"]
// END RANK raw_208

prespace_209 -> leaf_213
leaf_213  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_209

literal_210 -> leaf_214
leaf_214  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_tabulate"]
// END RANK literal_210

raw_211 -> leaf_215
leaf_215  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" function yielding pieces of a table as it
generates them, as well as the printed length (not valid across all Unicode,
but let's shave one yak at a time, shall we?).
"]
// END RANK raw_211

prose_201 -> { raw_216}
{rank=same; raw_216}

raw_216 [label="raw"]


// END RANK prose_201

raw_216 -> leaf_217
leaf_217  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Now for the real fun: we need to keep track of indentation levels, and break
'long' maps and arrays up into chunks.
"]
// END RANK raw_216

prose_202 -> { raw_218 prespace_219 literal_220 raw_221}
{rank=same; raw_218 prespace_219 literal_220 raw_221}

raw_218 [label="raw"]

prespace_219 [label="prespace"]

literal_220 [label="literal"]

raw_221 [label="raw"]


// END RANK prose_202

raw_218 -> leaf_222
leaf_222  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We're yielding a \"map\" string for k/v type tables and an \"array\" string for
array-type, and just \"end\" for the end of either.  What we need is a classic
push-down automaton, and some kind of buffer that's more sophisticated than
just tossing everything into a"]
// END RANK raw_218

prespace_219 -> leaf_223
leaf_223  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_219

literal_220 -> leaf_224
leaf_224  [color=Gray,shape=rectangle,fontname=Inconsolata,label="phrase"]
// END RANK literal_220

raw_221 -> leaf_225
leaf_225  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" table.

"]
// END RANK raw_221

section_203 -> { header_226 prose_227 codeblock_228}
{rank=same; header_226 prose_227 codeblock_228}

header_226 [label="4 : oneLine(phrase, long)"]

prose_227 [label="prose"]

codeblock_228 [label="code block 318-390"]


// END RANK section_203

header_226 -> leaf_229
leaf_229  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** oneLine(phrase, long)"]
// END RANK header_226

prose_227 -> { raw_230 prespace_231 literal_232 raw_233 prespace_234 literal_235 raw_236 prespace_237 literal_238 raw_239}
{rank=same; raw_230 prespace_231 literal_232 raw_233 prespace_234 literal_235 raw_236 prespace_237 literal_238 raw_239}

raw_230 [label="raw"]

prespace_231 [label="prespace"]

literal_232 [label="literal"]

raw_233 [label="raw"]

prespace_234 [label="prespace"]

literal_235 [label="literal"]

raw_236 [label="raw"]

prespace_237 [label="prespace"]

literal_238 [label="literal"]

raw_239 [label="raw"]


// END RANK prose_227

raw_230 -> leaf_240
leaf_240  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Returns one line from"]
// END RANK raw_230

prespace_231 -> leaf_241
leaf_241  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_231

literal_232 -> leaf_242
leaf_242  [color=Gray,shape=rectangle,fontname=Inconsolata,label="phrase"]
// END RANK literal_232

raw_233 -> leaf_243
leaf_243  [color=Gray,shape=rectangle,fontname=Inconsolata,label="."]
// END RANK raw_233

prespace_234 -> leaf_244
leaf_244  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_234

literal_235 -> leaf_245
leaf_245  [color=Gray,shape=rectangle,fontname=Inconsolata,label="long"]
// END RANK literal_235

raw_236 -> leaf_246
leaf_246  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" determines whether we're doing long
lines or short lines, which is determined by"]
// END RANK raw_236

prespace_237 -> leaf_247
leaf_247  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_237

literal_238 -> leaf_248
leaf_248  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lineGen"]
// END RANK literal_238

raw_239 -> leaf_249
leaf_249  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", the caller.
"]
// END RANK raw_239

codeblock_228 -> leaf_250
leaf_250  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function _disp(phrase)
   local displacement = 0
   for i = 1, #phrase.disp do
      displacement = displacement + phrase.disp[i]
   end
   return displacement
end

local function _spill(phrase, line, disps)
   assert(#line == #disps, \"#line must == #disps\")
   for i = 0, #line do
      phrase[i] = line[i]
      phrase.disp[i] = disps[i]
   end
   phrase.yielding = true
   return false
end

local function oneLine(phrase, long)
   local line = {}
   local disps = {}
   if #phrase == 0 then
      phrase.yielding = true
      return false
   end
   while true do
      local frag, disp = remove(phrase, 1), remove(phrase.disp, 1)
      -- remove commas before closing braces
      if frag == COMMA() then
         if phrase[1] == C_BRACE() then
            frag = \"\"
            disp = 0
         elseif #phrase == 0 then
            insert(line, frag)
            insert(disps, disp)
            return _spill(phrase, line, disps)
         end
      end
      -- and after opening braces
      if frag == O_BRACE() and phrase[1] == COMMA() then
         remove(phrase, 1)
         remove(phrase.disp, 1)
      end
      -- pad with a space inside the braces
      if frag == C_BRACE() then
         insert(line, \" \")
         insert(disps, 1)
      end
      insert(line, frag)
      insert(disps, disp)
      if frag == O_BRACE() then
         insert(line, \" \")
         insert(disps, 1)
      end
      -- adjust stack for next round
      if frag == O_BRACE() then
         phrase.level = phrase.level + 1
      elseif frag == C_BRACE() then
         phrase.level = phrase.level - 1
      end
      if (frag == COMMA() and long)
         or (#phrase == 0 and not phrase.more) then
         local indent = phrase.dent == 0 and \"\" or (\"  \"):rep(phrase.dent)
         phrase.dent = phrase.level
         return indent.. concat(line)
      elseif #phrase == 0 and phrase.more then
         -- spill our fragments back
         return _spill(phrase, line, disps)
      end
   end
end"]
// END RANK codeblock_228

section_204 -> { header_251 prose_252 codeblock_253}
{rank=same; header_251 prose_252 codeblock_253}

header_251 [label="4 : lineGen"]

prose_252 [label="prose"]

codeblock_253 [label="code block 398-505"]


// END RANK section_204

header_251 -> leaf_254
leaf_254  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** lineGen"]
// END RANK header_251

prose_252 -> { raw_255}
{rank=same; raw_255}

raw_255 [label="raw"]


// END RANK prose_252

raw_255 -> leaf_256
leaf_256  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This function sets up an iterator, which returns one line at a time of the
table.
"]
// END RANK raw_255

codeblock_253 -> leaf_257
leaf_257  [color=Gray,shape=rectangle,fontname=Inconsolata,label="assert(readOnly, \"must have readOnly from core\")

local function _remains(phrase)
   return phrase.width - _disp(phrase)
end

local function lineGen(tab, depth, cycle, disp_width)
   assert(disp_width, \"lineGen must have a disp_width\")
   local phrase = {}
   phrase.disp = {}
   local iter = wrap(_tabulate)
   local stage = {}              -- stage stack
   phrase.remains = _remains
   phrase.width = disp_width
   phrase.stage = stage
   phrase.level = 0              -- how many levels of recursion are we on
   phrase.dent = 0               -- indent level (lags by one line)
   phrase.more = true            -- are their more frags to come
   local map_counter = 0         -- counts where commas go
   phrase.yielding = true
   local long = false            -- long or short printing

   -- make a read-only phrase table for fetching values
   local phrase_ro = readOnly(phrase)
   -- return an iterator function which yields one line at a time.
   return function()
      ::start::
      while phrase.yielding do
         local line, len, event = iter(tab, depth, cycle, phrase_ro)
         if line == nil then
            phrase.yielding = false
            phrase.more = false
            break
         end
         phrase[#phrase + 1] = line
         phrase.disp[#phrase.disp + 1] = len
         if event then
            if event == \"repr_line\" then
               -- remove from the phrase and send directly
               phrase[#phrase] = nil
               phrase.disp[#phrase.disp] = nil
               return line
            end
            if event == \"map\" then
               map_counter = 0
            end
            if event == \"array\" or event == \"map\" then
               insert(stage, event)
            elseif event == \"end\" then
               remove(stage)
               if stage[#stage] == \"map\" then
                  map_counter = 3
               end
            elseif event == \"mt_name\" then
               -- gotta drop that comma
               map_counter = 1
            end
         end

         -- special-case for non-string values, which
         -- yield an extra piece
         if line == c.base(\"] = \") then
            map_counter = map_counter - 1
         end
         -- insert commas
         if stage[#stage] ==\"map\"  then
            if map_counter == 3 then
               phrase[#phrase + 1] = COMMA()
               phrase.disp[#phrase.disp + 1] = COM_LEN
               map_counter = 1
            else
               map_counter = map_counter + 1
            end
         elseif stage[#stage] == \"array\"then
            phrase[#phrase + 1] = COMMA()
            phrase.disp[#phrase.disp + 1] = COM_LEN
            map_counter = map_counter + 1
         end
         if _disp(phrase) >= disp_width then
            long = true
            phrase.yielding = false
            break
         else
            long = false
         end
      end
      if #phrase > 0 then
         local ln = oneLine(phrase, long)
         if ln then
            return ln
         else
            goto start
         end
      elseif phrase.more == false then
         return nil
      else
         phrase.yielding = true
         goto start
      end
   end
end

function repr.lineGen(tab, disp)
   disp = disp or 80
   return lineGen(tab, nil, nil, disp)
end"]
// END RANK codeblock_253

section_14 -> { header_258 prose_259 prose_260 prose_261 prose_262 prose_263 codeblock_264 codeblock_265}
{rank=same; header_258 prose_259 prose_260 prose_261 prose_262 prose_263 codeblock_264 codeblock_265}

header_258 [label="3 : repr.lineGenBW(tab, depth, cycle, disp_width)"]

prose_259 [label="prose"]

prose_260 [label="prose"]

prose_261 [label="prose"]

prose_262 [label="prose"]

prose_263 [label="prose"]

codeblock_264 [label="code block 521-535"]

codeblock_265 [label="code block 537-546"]


// END RANK section_14

header_258 -> leaf_266
leaf_266  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** repr.lineGenBW(tab, depth, cycle, disp_width)"]
// END RANK header_258

prose_259 -> { raw_267}
{rank=same; raw_267}

raw_267 [label="raw"]


// END RANK prose_259

raw_267 -> leaf_268
leaf_268  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This generates lines, but with no color.
"]
// END RANK raw_267

prose_260 -> { raw_269 prespace_270 literal_271 raw_272}
{rank=same; raw_269 prespace_270 literal_271 raw_272}

raw_269 [label="raw"]

prespace_270 [label="prespace"]

literal_271 [label="literal"]

raw_272 [label="raw"]


// END RANK prose_260

raw_269 -> leaf_273
leaf_273  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To keep it from interfering with other uses of the"]
// END RANK raw_269

prespace_270 -> leaf_274
leaf_274  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_270

literal_271 -> leaf_275
leaf_275  [color=Gray,shape=rectangle,fontname=Inconsolata,label="repr"]
// END RANK literal_271

raw_272 -> leaf_276
leaf_276  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" library, we turn
color off and back on with each line.
"]
// END RANK raw_272

prose_261 -> { raw_277}
{rank=same; raw_277}

raw_277 [label="raw"]


// END RANK prose_261

raw_277 -> leaf_278
leaf_278  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Global state is annoying!
"]
// END RANK raw_277

prose_262 -> { raw_279}
{rank=same; raw_279}

raw_279 [label="raw"]


// END RANK prose_262

raw_279 -> leaf_280
leaf_280  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I mean, module-local global.
"]
// END RANK raw_279

prose_263 -> { raw_281}
{rank=same; raw_281}

raw_281 [label="raw"]


// END RANK prose_263

raw_281 -> leaf_282
leaf_282  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
But still.
"]
// END RANK raw_281

codeblock_264 -> leaf_283
leaf_283  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function repr.lineGenBW(tab, disp_width)
   local lg = lineGen(tab, nil, nil, disp_width)
   return function()
      c = C.no_color
      local line = lg()
      if line ~= nil then
         c = C.color
         return line
      end
      c = C.color
      return nil
   end
end"]
// END RANK codeblock_264

codeblock_265 -> leaf_284
leaf_284  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function tabulate(tab, depth, cycle, disp_width)
   disp_width = disp_width or 80
   local phrase = {}
   for line in lineGen(tab, depth, cycle, disp_width) do
      phrase[#phrase + 1] = line
   end
   return concat(phrase, \"\\n\")
end"]
// END RANK codeblock_265

section_15 -> { header_285 prose_286 codeblock_287 prose_288 prose_289 prose_290 codeblock_291}
{rank=same; header_285 prose_286 codeblock_287 prose_288 prose_289 prose_290 codeblock_291}

header_285 [label="3 : string and cdata pretty-printing"]

prose_286 [label="prose"]

codeblock_287 [label="code block 554-585"]

prose_288 [label="prose"]

prose_289 [label="prose"]

prose_290 [label="prose"]

codeblock_291 [label="code block 597-608"]


// END RANK section_15

header_285 -> leaf_292
leaf_292  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** string and cdata pretty-printing"]
// END RANK header_285

prose_286 -> { raw_293}
{rank=same; raw_293}

raw_293 [label="raw"]


// END RANK prose_286

raw_293 -> leaf_294
leaf_294  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

We make a small wrapper function which resets string color in between
escapes, then gsub the daylights out of it.
"]
// END RANK raw_293

codeblock_287 -> leaf_295
leaf_295  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local find, sub, gsub, byte = string.find, string.sub,
                              string.gsub, string.byte

local e = function(str)
   return c.stresc .. str .. c.string
end

-- Turn control characters into their byte rep,
-- preserving escapes
local function ctrl_pr(str)
   if byte(str) ~= 27 then
      return e(\"\\\\\" .. byte(str))
   else
      return str
   end
end

local function scrub (str)
   return str:gsub(\"\\27\", e \"\\\\x1b\")
             :gsub('\"',  e '\\\\\"')
             :gsub(\"'\",  e \"\\\\'\")
             :gsub(\"\\a\", e \"\\\\a\")
             :gsub(\"\\b\", e \"\\\\b\")
             :gsub(\"\\f\", e \"\\\\f\")
             :gsub(\"\\n\", e \"\\\\n\")
             :gsub(\"\\r\", e \"\\\\r\")
             :gsub(\"\\t\", e \"\\\\t\")
             :gsub(\"\\v\", e \"\\\\v\")
             :gsub(\"%c\", ctrl_pr)
end"]
// END RANK codeblock_287

prose_288 -> { raw_296}
{rank=same; raw_296}

raw_296 [label="raw"]


// END RANK prose_288

raw_296 -> leaf_297
leaf_297  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Note: the reflect library appears to be broken for LuaJIT 2.1 so we're
not going to use it.
"]
// END RANK raw_296

prose_289 -> { raw_298}
{rank=same; raw_298}

raw_298 [label="raw"]


// END RANK prose_289

raw_298 -> leaf_299
leaf_299  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'm leaving in the code for now, because I'd like to repair and use it...
"]
// END RANK raw_298

prose_290 -> { raw_300}
{rank=same; raw_300}

raw_300 [label="raw"]


// END RANK prose_290

raw_300 -> leaf_301
leaf_301  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
lol
"]
// END RANK raw_300

codeblock_291 -> leaf_302
leaf_302  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function c_data(value, str, phrase)
   --local meta = reflect.getmetatable(value)
   yield(str, #str)
   --[[
   if meta then
      yield(c.base \" = \", 3)
      ts_coro(meta, nil, phrase)
   end
   --]]
end"]
// END RANK codeblock_291

section_16 -> { header_303 prose_304 codeblock_305 codeblock_306 codeblock_307}
{rank=same; header_303 prose_304 codeblock_305 codeblock_306 codeblock_307}

header_303 [label="3 : ts_coro"]

prose_304 [label="prose"]

codeblock_305 [label="code block 615-701"]

codeblock_306 [label="code block 705-712"]

codeblock_307 [label="code block 714-716"]


// END RANK section_16

header_303 -> leaf_308
leaf_308  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** ts_coro"]
// END RANK header_303

prose_304 -> { raw_309}
{rank=same; raw_309}

raw_309 [label="raw"]


// END RANK prose_304

raw_309 -> leaf_310
leaf_310  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Lots of small, nice things in this one.
"]
// END RANK raw_309

codeblock_305 -> leaf_311
leaf_311  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ts_coro = function (value, hint, phrase)
   local strval = tostring(value) or \"\"
   local len = #strval
   local str = scrub(strval)

   -- For cases more specific than mere type,
   -- we have hints:
   if hint then
      if hint == \"tab_name\" then
         local tab_name = anti_G[value] or \"t:\" .. sub(str, -6)
         len = #tab_name
         yield(c.table(tab_name), len)
         return nil
      elseif hint == \"mt\" then
         local mt_name = anti_G[value] or \"mt:\" .. sub(str, -6)
         len = #mt_name + 2
         yield(c.metatable(\"⟨\" .. mt_name .. \"⟩\"), len, \"mt_name\")
         return nil
      elseif hints[hint] then
         yield(hints[hint](str), len)
         return nil
      elseif c[hint] then
         yield(c[hint](str), len)
         return nil
      end
   end

   local typica = type(value)

   if typica == \"table\" then
      _tabulate(value, nil, nil, phrase)
      return nil
   elseif typica == \"function\" then
      local f_label = sub(str,11)
      f_label = sub(f_label,1,5) == \"built\"
                and f_label
                or \"f:\" .. sub(str, -6)
      local func_name = anti_G[value] or f_label
      len = #func_name
      str = c.func(func_name)
   elseif typica == \"boolean\" then
      str = value and c.truth(str) or c.falsehood(str)
   elseif typica == \"string\" then
      if value == \"\" then
         str = c.string('\"\"')
         len = 2
      else
         str = c.string(str)
      end
   elseif typica == \"number\" then
      str = c.number(str)
   elseif typica == \"nil\" then
      str = c.nilness(str)
   elseif typica == \"thread\" then
      local coro_name = anti_G[value] and \"coro:\" .. anti_G[value]
                                      or  \"coro:\" .. sub(str, -6)
      len = #coro_name
      str = c.thread(coro_name)
   elseif typica == \"userdata\" then
      if anti_G[value] then
         str = c.userdata(anti_G[value])
         len = #anti_G[value]
      else
         local name = find(str, \":\")
         if name then
            name = sub(str, 1, name - 1)
            len = #name
            str = c.userdata(name)
         else
            str = c.userdata(str)
         end
      end
   elseif typica == \"cdata\" then
      if anti_G[value] then
         str = c.cdata(anti_G[value])
         len = anti_G[value]
      else
         str = c.cdata(str)
      end
      str, len = c_data(value, str)
   end
   yield(str, len)
end

repr.ts = tabulate"]
// END RANK codeblock_305

codeblock_306 -> leaf_312
leaf_312  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function repr.ts_bw(value)
   c = C.no_color
   local to_string = tabulate(value)
   c = C.color
   return to_string
end"]
// END RANK codeblock_306

codeblock_307 -> leaf_313
leaf_313  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return repr"]
// END RANK codeblock_307


}
