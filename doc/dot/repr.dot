digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 546"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-430"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 section_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13 section_14}
{rank=same; header_2 prose_3 prose_4 prose_5 section_6 section_7 section_8 section_9 section_10 section_11 section_12 section_13 section_14}

header_2 [label="1 : Repr"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

section_6 [label="section: 14-26"]

section_7 [label="section: 27-38"]

section_8 [label="section: 39-51"]

section_9 [label="section: 52-118"]

section_10 [label="section: 136-171"]

section_11 [label="section: 172-264"]

section_12 [label="section: 265-379"]

section_13 [label="section: 380-430"]

section_14 [label="section: 431-546"]


// END RANK section_1

header_2 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Repr"]
// END RANK header_2

prose_3 -> { raw_16 prespace_17 literal_18 raw_19}
{rank=same; raw_16 prespace_17 literal_18 raw_19}

raw_16 [label="raw"]

prespace_17 [label="prespace"]

literal_18 [label="literal"]

raw_19 [label="raw"]


// END RANK prose_3

raw_16 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


 "]
// END RANK raw_16

prespace_17 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_17

literal_18 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="repr"]
// END RANK literal_18

raw_19 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is our general-purpose pretty-printer.
"]
// END RANK raw_19

prose_4 -> { raw_24}
{rank=same; raw_24}

raw_24 [label="raw"]


// END RANK prose_4

raw_24 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is undergoing a huge refactor to make it iterable, so it yields one
line at a time and won't get hung up on enormous tables.
"]
// END RANK raw_24

prose_5 -> { raw_26}
{rank=same; raw_26}

raw_26 [label="raw"]


// END RANK prose_5

raw_26 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Currently we yield most things, and are working our way toward providing an
iterator that itself returns one line at a time until it reaches the end of
the repr.

"]
// END RANK raw_26

section_6 -> { header_28 prose_29 codeblock_30}
{rank=same; header_28 prose_29 codeblock_30}

header_28 [label="4 : imports"]

prose_29 [label="prose"]

codeblock_30 [label="code block 16-24"]


// END RANK section_6

header_28 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** imports"]
// END RANK header_28

prose_29 -> { raw_32}
{rank=same; raw_32}

raw_32 [label="raw"]


// END RANK prose_29

raw_32 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_32

codeblock_30 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local a = require \"anterm\"

local core = require \"core\"

local reflect = require \"reflect\"

local C = require \"color\""]
// END RANK codeblock_30

section_7 -> { header_35 prose_36 codeblock_37}
{rank=same; header_35 prose_36 codeblock_37}

header_35 [label="4 : setup"]

prose_36 [label="prose"]

codeblock_37 [label="code block 29-36"]


// END RANK section_7

header_35 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** setup"]
// END RANK header_35

prose_36 -> { raw_39}
{rank=same; raw_39}

raw_39 [label="raw"]


// END RANK prose_36

raw_39 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_39

codeblock_37 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local repr = {}

local hints = C.color.hints

local c = C.color"]
// END RANK codeblock_37

section_8 -> { header_42 prose_43 codeblock_44 prose_45}
{rank=same; header_42 prose_43 codeblock_44 prose_45}

header_42 [label="3 : anti_G"]

prose_43 [label="prose"]

codeblock_44 [label="code block 45-47"]

prose_45 [label="prose"]


// END RANK section_8

header_42 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** anti_G"]
// END RANK header_42

prose_43 -> { raw_47 prespace_48 literal_49 raw_50 prespace_51 literal_52 raw_53 prespace_54 literal_55 raw_56}
{rank=same; raw_47 prespace_48 literal_49 raw_50 prespace_51 literal_52 raw_53 prespace_54 literal_55 raw_56}

raw_47 [label="raw"]

prespace_48 [label="prespace"]

literal_49 [label="literal"]

raw_50 [label="raw"]

prespace_51 [label="prespace"]

literal_52 [label="literal"]

raw_53 [label="raw"]

prespace_54 [label="prespace"]

literal_55 [label="literal"]

raw_56 [label="raw"]


// END RANK prose_43

raw_47 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

In order to provide names for values, we want to trawl through"]
// END RANK raw_47

prespace_48 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_48

literal_49 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_G"]
// END RANK literal_49

raw_50 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and
acquire them.  This table is from value to key where"]
// END RANK raw_50

prespace_51 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_51

literal_52 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_G"]
// END RANK literal_52

raw_53 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is key to value,
hence,"]
// END RANK raw_53

prespace_54 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_54

literal_55 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="anti_G"]
// END RANK literal_55

raw_56 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_56

codeblock_44 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local anti_G = { _G = \"_G\" }"]
// END RANK codeblock_44

prose_45 -> { raw_68}
{rank=same; raw_68}

raw_68 [label="raw"]


// END RANK prose_45

raw_68 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Now to populate it:

"]
// END RANK raw_68

section_9 -> { header_70 prose_71 prose_72 section_73 section_74}
{rank=same; header_70 prose_71 prose_72 section_73 section_74}

header_70 [label="3 : C.allNames()"]

prose_71 [label="prose"]

prose_72 [label="prose"]

section_73 [label="section: 61-118"]

section_74 [label="section: 119-135"]


// END RANK section_9

header_70 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** C.allNames()"]
// END RANK header_70

prose_71 -> { raw_76 prespace_77 literal_78 raw_79}
{rank=same; raw_76 prespace_77 literal_78 raw_79}

raw_76 [label="raw"]

prespace_77 [label="prespace"]

literal_78 [label="literal"]

raw_79 [label="raw"]


// END RANK prose_71

raw_76 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Ransacks"]
// END RANK raw_76

prespace_77 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_77

literal_78 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_G"]
// END RANK literal_78

raw_79 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" looking for names to put on things.
"]
// END RANK raw_79

prose_72 -> { raw_84}
{rank=same; raw_84}

raw_84 [label="raw"]


// END RANK prose_72

raw_84 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To really dig out a good name for metatables we're going to need to write
some kind of reflection function that will dig around in upvalues to find
local names for things.

"]
// END RANK raw_84

section_73 -> { header_86 prose_87 codeblock_88}
{rank=same; header_86 prose_87 codeblock_88}

header_86 [label="4 : tie_break(old, new)"]

prose_87 [label="prose"]

codeblock_88 [label="code block 65-116"]


// END RANK section_73

header_86 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** tie_break(old, new)"]
// END RANK header_86

prose_87 -> { raw_90}
{rank=same; raw_90}

raw_90 [label="raw"]


// END RANK prose_87

raw_90 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

A helper function to decide which name is better.
"]
// END RANK raw_90

codeblock_88 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function tie_break(old, new)
   return #old > #new
end


local function addName(t, aG, pre)
   pre = pre or \"\"
   aG = aG or anti_G
   if pre ~= \"\" then
      pre = pre .. \".\"
   end
   for k, v in pairs(t) do
      local T = type(v)
      if (T == \"table\") then
         local key = pre .. (type(k) == \"string\" and k or \"<\" .. type(k) .. \">\")
         if not aG[v] then
            aG[v] = key
            if not (pre == \"\" and k == \"package\") then
               addName(v, aG, key)
            end
         else
            local kv = aG[v]
            if tie_break(kv, key) then
               -- quadradic lol
               aG[v] = key
               addName(v, aG, key)
            end
         end
         local _M = getmetatable(v)
         local _M_id = _M and \"⟨\" .. key.. \"⟩\" or \"\"
         if _M then
            if not aG[_M] then
               addName(_M, aG, _M_id)
               aG[_M] = _M_id
            else
               local aG_M_id = aG[_M]
               if tie_break(aG_M_id, _M_id) then
                  addName(_M, aG, _M_id)
                  aG[_M] = _M_id
               end
            end
         end
      elseif T == \"function\" or
         T == \"thread\" or
         T == \"userdata\" then
         aG[v] = pre .. k
      end
   end
   return aG
end"]
// END RANK codeblock_88

section_74 -> { header_93 prose_94 codeblock_95}
{rank=same; header_93 prose_94 codeblock_95}

header_93 [label="4 : repr.allNames(), repr.clearNames()"]

prose_94 [label="prose"]

codeblock_95 [label="code block 124-134"]


// END RANK section_74

header_93 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** repr.allNames(), repr.clearNames()"]
// END RANK header_93

prose_94 -> { raw_97 prespace_98 literal_99 raw_100 prespace_101 literal_102 raw_103}
{rank=same; raw_97 prespace_98 literal_99 raw_100 prespace_101 literal_102 raw_103}

raw_97 [label="raw"]

prespace_98 [label="prespace"]

literal_99 [label="literal"]

raw_100 [label="raw"]

prespace_101 [label="prespace"]

literal_102 [label="literal"]

raw_103 [label="raw"]


// END RANK prose_94

raw_97 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The trick here is that we scan"]
// END RANK raw_97

prespace_98 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_98

literal_99 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="package.loaded"]
// END RANK literal_99

raw_100 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" after"]
// END RANK raw_100

prespace_101 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_101

literal_102 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_G"]
// END RANK literal_102

raw_103 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", which gives
better names for things.
"]
// END RANK raw_103

codeblock_95 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function repr.allNames(tab)
   tab = tab or _G
   return addName(package.loaded, addName(tab))
end

function repr.clearNames()
   anti_G = {_G = \"_G\"}
   return anti_G
end"]
// END RANK codeblock_95

section_10 -> { header_112 prose_113 prose_114 codeblock_115}
{rank=same; header_112 prose_113 prose_114 codeblock_115}

header_112 [label="3 : tabulator"]

prose_113 [label="prose"]

prose_114 [label="prose"]

codeblock_115 [label="code block 144-169"]


// END RANK section_10

header_112 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** tabulator"]
// END RANK header_112

prose_113 -> { raw_117}
{rank=same; raw_117}

raw_117 [label="raw"]


// END RANK prose_113

raw_117 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is fundamentally [[Tim Caswell's][https://github.com/creationix]] code.
"]
// END RANK raw_117

prose_114 -> { raw_119}
{rank=same; raw_119}

raw_119 [label="raw"]


// END RANK prose_114

raw_119 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I've dressed it up a bit. Okay, a lot.
"]
// END RANK raw_119

codeblock_115 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local ts, ts_coro

local SORT_LIMIT = 500  -- This won't be necessary #todo remove

local coro = coro or coroutine

local yield, wrap = coro.yield, coro.wrap

local collect = assert(table.collect)

local concat = table.concat

local function _keysort(a, b)
   if type(a) == \"number\" and type(b) == \"string\" then
      return true
   elseif type(a) == \"string\" and type(b) == \"number\" then
      return false
   elseif (type(a) == \"string\" and type(b) == \"string\")
      or (type(a) == \"number\" and type(b) == \"number\") then
      return a < b
   else
      return false
   end
end"]
// END RANK codeblock_115

section_11 -> { header_122 prose_123 prose_124 prose_125 codeblock_126 prose_127 prose_128}
{rank=same; header_122 prose_123 prose_124 prose_125 codeblock_126 prose_127 prose_128}

header_122 [label="3 : _tabulate(tab, depth, cycle)"]

prose_123 [label="prose"]

prose_124 [label="prose"]

prose_125 [label="prose"]

codeblock_126 [label="code block 181-254"]

prose_127 [label="prose"]

prose_128 [label="prose"]


// END RANK section_11

header_122 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** _tabulate(tab, depth, cycle)"]
// END RANK header_122

prose_123 -> { raw_130 prespace_131 literal_132 raw_133}
{rank=same; raw_130 prespace_131 literal_132 raw_133}

raw_130 [label="raw"]

prespace_131 [label="prespace"]

literal_132 [label="literal"]

raw_133 [label="raw"]


// END RANK prose_123

raw_130 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This"]
// END RANK raw_130

prespace_131 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_131

literal_132 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label="yield()s"]
// END RANK literal_132

raw_133 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" pieces of a table, recursively, one at a time.
"]
// END RANK raw_133

prose_124 -> { raw_138}
{rank=same; raw_138}

raw_138 [label="raw"]


// END RANK prose_124

raw_138 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Second return value is the printed width, third, if any, is a string
representing what we're opening and/or closing.
"]
// END RANK raw_138

prose_125 -> { raw_140}
{rank=same; raw_140}

raw_140 [label="raw"]


// END RANK prose_125

raw_140 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
At this point it works, time to start breaking it out into an iterator.
"]
// END RANK raw_140

codeblock_126 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local O_BRACE = c.base \"{\"
local C_BRACE = c.base \"}\"

local function _tabulate(tab, depth, cycle)
   cycle = cycle or {}
   depth = depth or 0
   if type(tab) ~= \"table\" then
      ts_coro(tab)
      return nil
   end
   if depth > C.depth or cycle[tab] then
      yield(ts(tab, \"tab_name\"))
      return nil
   end

   cycle[tab] = true
   -- Check to see if this is an array
   local is_array = true
   local i = 1
   for k,_ in pairs(tab) do
      is_array = is_array and (k == i)
      i = i + 1
   end
   -- if we have a metatable, get it first
   local mt = \"\"
   local _M = getmetatable(tab)
   if _M then
      -- fix metatable stuff

      local mt_rep, mt_len = ts(tab, \"mt\")
      yield(mt_rep, mt_len)
      yield(c.base(\" = \"), 3)
      _tabulate(_M, depth + 1, cycle)
   end
   local estimated = 0
   local keys
   if not is_array then
      keys = table.keys(tab)
      if #keys <= SORT_LIMIT then
         table.sort(keys, _keysort)
      else
         -- bail
         yield(\"{ !!! }\", 7, \"end\"); return nil
      end
   else
      if #tab > SORT_LIMIT then
         yield(\"{ #!!! }\", 8, \"end\"); return nil
      end
      keys = tab
   end
   yield(O_BRACE, 1, (is_array and \"array\" or \"map\"))
   for j, key in ipairs(keys) do
      if is_array then
         _tabulate(key, depth + 1, cycle)
      else
         val = tab[key]
         if type(key) == \"string\" and key:find(\"^[%a_][%a%d_]*$\") then
            ts_coro(key)
            yield(c.base(\" = \"), 3)
         else
            yield(c.base(\"[\"), 1)
               -- we want names or hashes for any lvalue table,
               -- 100 triggers this
            _tabulate(key, 100, cycle)
            yield(c.base(\"] = \"), 4)
         end
         _tabulate(val, depth + 1, cycle)
      end
   end
   yield(C_BRACE, 1, \"end\")
   return nil
end"]
// END RANK codeblock_126

prose_127 -> { raw_143}
{rank=same; raw_143}

raw_143 [label="raw"]


// END RANK prose_127

raw_143 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
line-buffer goes here
"]
// END RANK raw_143

prose_128 -> { raw_145 prespace_146 literal_147 raw_148 prespace_149 literal_150 raw_151 prespace_152 literal_153 raw_154 prespace_155 literal_156 raw_157}
{rank=same; raw_145 prespace_146 literal_147 raw_148 prespace_149 literal_150 raw_151 prespace_152 literal_153 raw_154 prespace_155 literal_156 raw_157}

raw_145 [label="raw"]

prespace_146 [label="prespace"]

literal_147 [label="literal"]

raw_148 [label="raw"]

prespace_149 [label="prespace"]

literal_150 [label="literal"]

raw_151 [label="raw"]

prespace_152 [label="prespace"]

literal_153 [label="literal"]

raw_154 [label="raw"]

prespace_155 [label="prespace"]

literal_156 [label="literal"]

raw_157 [label="raw"]


// END RANK prose_128

raw_145 -> leaf_158
leaf_158  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
needs to decide when things are 'wide enough' so each yield needs to return"]
// END RANK raw_145

prespace_146 -> leaf_159
leaf_159  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_146

literal_147 -> leaf_160
leaf_160  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str, len, done"]
// END RANK literal_147

raw_148 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", where"]
// END RANK raw_148

prespace_149 -> leaf_162
leaf_162  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_149

literal_150 -> leaf_163
leaf_163  [color=Gray,shape=rectangle,fontname=Inconsolata,label="str"]
// END RANK literal_150

raw_151 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is the fragment of string,"]
// END RANK raw_151

prespace_152 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_152

literal_153 -> leaf_166
leaf_166  [color=Gray,shape=rectangle,fontname=Inconsolata,label="len"]
// END RANK literal_153

raw_154 -> leaf_167
leaf_167  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is a number
representing its printable width (don't @ me) and"]
// END RANK raw_154

prespace_155 -> leaf_168
leaf_168  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_155

literal_156 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label="done"]
// END RANK literal_156

raw_157 -> leaf_170
leaf_170  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is a boolean for if
this is the last bit of the repr of a given thing. Table, userdata, what
have you.

"]
// END RANK raw_157

section_12 -> { header_171 prose_172 prose_173 prose_174 prose_175 codeblock_176}
{rank=same; header_171 prose_172 prose_173 prose_174 prose_175 codeblock_176}

header_171 [label="3 : tabulate(...)"]

prose_172 [label="prose"]

prose_173 [label="prose"]

prose_174 [label="prose"]

prose_175 [label="prose"]

codeblock_176 [label="code block 281-377"]


// END RANK section_12

header_171 -> leaf_177
leaf_177  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** tabulate(...)"]
// END RANK header_171

prose_172 -> { raw_178}
{rank=same; raw_178}

raw_178 [label="raw"]


// END RANK prose_172

raw_178 -> leaf_179
leaf_179  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is going to undergo several metamorpheses as we make progress.
"]
// END RANK raw_178

prose_173 -> { raw_180 prespace_181 literal_182 raw_183}
{rank=same; raw_180 prespace_181 literal_182 raw_183}

raw_180 [label="raw"]

prespace_181 [label="prespace"]

literal_182 [label="literal"]

raw_183 [label="raw"]


// END RANK prose_173

raw_180 -> leaf_184
leaf_184  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
For now, we have the"]
// END RANK raw_180

prespace_181 -> leaf_185
leaf_185  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_181

literal_182 -> leaf_186
leaf_186  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_tabulate"]
// END RANK literal_182

raw_183 -> leaf_187
leaf_187  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" function yielding pieces of a table as it
generates them, as well as the printed length (not valid across all Unicode,
but let's shave one yak at a time, shall we?).
"]
// END RANK raw_183

prose_174 -> { raw_188}
{rank=same; raw_188}

raw_188 [label="raw"]


// END RANK prose_174

raw_188 -> leaf_189
leaf_189  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Now for the real fun: we need to keep track of indentation levels, and break
'long' maps and arrays up into chunks.
"]
// END RANK raw_188

prose_175 -> { raw_190 prespace_191 literal_192 raw_193}
{rank=same; raw_190 prespace_191 literal_192 raw_193}

raw_190 [label="raw"]

prespace_191 [label="prespace"]

literal_192 [label="literal"]

raw_193 [label="raw"]


// END RANK prose_175

raw_190 -> leaf_194
leaf_194  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We're yielding a \"map\" string for k/v type tables and an \"array\" string for
array-type, and just \"end\" for the end of either.  What we need is a classic
push-down automaton, and some kind of buffer that's more sophisticated than
just tossing everything into a"]
// END RANK raw_190

prespace_191 -> leaf_195
leaf_195  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_191

literal_192 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label="phrase"]
// END RANK literal_192

raw_193 -> leaf_197
leaf_197  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" table.
"]
// END RANK raw_193

codeblock_176 -> leaf_198
leaf_198  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local COMMA, COM_LEN = c.base \", \", 2

local function lineGen(...)
   local arg_v = {...}
   local phrase = {}
   local iter = wrap(_tabulate)
   local stage = \"\"
   local map_counter = 0         -- this counts where commas go
   local skip_comma = false      -- no comma at end of array/map
   local stack, old_stack = 0, 0 -- level of recursion
   local disp = 0                -- column displacement
   local yielding = true
   -- return an iterator function that currently yields the entire
   -- line but will eventually yield one line at a time.
   return function()
      while yielding do
         local line, len, event = iter(unpack(arg_v))
         if line == nil then
            break
         end
         phrase[#phrase + 1] = line
         disp = disp + len
         if event then
            if event == \"map\" then
               map_counter = 0
            end
            if event == \"array\" or event == \"map\" then
               stack = stack + 1
               skip_comma = true
            elseif event == \"end\" then
               stack = stack - 1
               assert(stack >= 0, \"(tabulate) stack underflow\")
            end
            -- don't think I need the conditional below
            if stage ~= event then
               skip_comma = true
            end
            if (stage == \"array\" or stage == \"map\")
               and event == \"end\" then
               skip_comma = true
            end
            -- this is seriously esoteric but fixes cases like {{},{}}
            if old_stack < stack and phrase[#phrase -1] == C_BRACE then
               table.insert(phrase, #phrase, COMMA)
               disp = disp + COM_LEN
            end
            stage = event
         end
         -- special-case for non-string values, which
         -- yield an extra piece
         if line == c.base(\"] = \") then
            map_counter = map_counter - 1
         end
         -- insert commas
         if stage ==\"map\"  then
            if map_counter == 3 then
               phrase[#phrase + 1] = COMMA
               disp = disp + COM_LEN
               map_counter = 1
            else
               map_counter = map_counter + 1
            end
         elseif stage == \"array\" and not skip_comma then
            phrase[#phrase + 1] = COMMA
            disp = disp + COM_LEN
            map_counter = map_counter + 1
         end
         skip_comma = false
         -- if we had a comma before ending a map/array (this is normal)
         -- then remove it
         -- #nb there may be a way to do this using skip_comma but this
         -- works, dammit.
         if stage == \"end\" and phrase[#phrase - 1] == COMMA then
            table.remove(phrase, #phrase - 1)
            disp = disp - COM_LEN
         end
         old_stack = stack
      end
      if yielding then
         yielding = false
         return table.concat(phrase)
      else
         return nil
      end
   end
end

local function tabulate(...)
   local phrase = {}
   for line in lineGen(...) do
      phrase[#phrase + 1] = line
   end
   return table.concat(phrase)
end"]
// END RANK codeblock_176

section_13 -> { header_199 prose_200 codeblock_201 codeblock_202}
{rank=same; header_199 prose_200 codeblock_201 codeblock_202}

header_199 [label="3 : string and cdata pretty-printing"]

prose_200 [label="prose"]

codeblock_201 [label="code block 385-416"]

codeblock_202 [label="code block 418-429"]


// END RANK section_13

header_199 -> leaf_203
leaf_203  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** string and cdata pretty-printing"]
// END RANK header_199

prose_200 -> { raw_204}
{rank=same; raw_204}

raw_204 [label="raw"]


// END RANK prose_200

raw_204 -> leaf_205
leaf_205  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

We make a small wrapper function which resets string color in between
escapes, then gsub the daylights out of it.
"]
// END RANK raw_204

codeblock_201 -> leaf_206
leaf_206  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local find, sub, gsub, byte = string.find, string.sub,
                              string.gsub, string.byte

local e = function(str)
   return c.stresc .. str .. c.string
end

-- Turn control characters into their byte rep,
-- preserving escapes
local function ctrl_pr(str)
   if byte(str) ~= 27 then
      return e(\"\\\\\" .. byte(str))
   else
      return str
   end
end

local function scrub (str)
   return str:gsub(\"\\27\", e \"\\\\x1b\")
             :gsub('\"',  e '\\\\\"')
             :gsub(\"'\",  e \"\\\\'\")
             :gsub(\"\\a\", e \"\\\\a\")
             :gsub(\"\\b\", e \"\\\\b\")
             :gsub(\"\\f\", e \"\\\\f\")
             :gsub(\"\\n\", e \"\\\\n\")
             :gsub(\"\\r\", e \"\\\\r\")
             :gsub(\"\\t\", e \"\\\\t\")
             :gsub(\"\\v\", e \"\\\\v\")
             :gsub(\"%c\", ctrl_pr)
end"]
// END RANK codeblock_201

codeblock_202 -> leaf_207
leaf_207  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function c_data(value, str)
   local meta = reflect.getmetatable(value)
   if meta then
      local mt_str, meta_len = ts(meta)
      meta_len = meta_len or #mt_str
      return str .. \" = \" .. mt_str, meta_len
   else
      return str, #str
   end
end"]
// END RANK codeblock_202

section_14 -> { header_208 prose_209 codeblock_210 codeblock_211 codeblock_212}
{rank=same; header_208 prose_209 codeblock_210 codeblock_211 codeblock_212}

header_208 [label="3 : ts"]

prose_209 [label="prose"]

codeblock_210 [label="code block 435-530"]

codeblock_211 [label="code block 532-539"]

codeblock_212 [label="code block 541-543"]


// END RANK section_14

header_208 -> leaf_213
leaf_213  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** ts"]
// END RANK header_208

prose_209 -> { raw_214}
{rank=same; raw_214}

raw_214 [label="raw"]


// END RANK prose_209

raw_214 -> leaf_215
leaf_215  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Lots of small, nice things in this one.
"]
// END RANK raw_214

codeblock_210 -> leaf_216
leaf_216  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ts_coro = function (value, hint)
   local strval = tostring(value) or \"\"
   local len = #strval
   local str = scrub(strval)

   -- For cases more specific than mere type,
   -- we have hints:
   if hint then
      if hint == \"tab_name\" then
         local tab_name = anti_G[value] or \"t:\" .. sub(str, -6)
         len = #tab_name
         yield(c.table(tab_name), len)
      elseif hint == \"mt\" then
         local mt_name = anti_G[value] or \"mt:\" .. sub(str, -6)
         len = #mt_name + 2
         yield(c.metatable(\"⟨\" .. mt_name .. \"⟩\"), len); return nil
      elseif hints[hint] then
         yield(hints[hint](str), len)
      elseif c[hint] then
         yield(c[hint](str), len)
      end
   end

   local typica = type(value)

   if typica == \"table\" then
      -- check for a __repr metamethod
      local _M = getmetatable(value)
      if _M and _M.__repr and not (hint == \"raw\") then
         local repr_len
         str, repr_len  = _M.__repr(value, c)
         len = repr_len or len
         assert(type(str) == \"string\")
      else
         str = tabulate(value)
      end
   elseif typica == \"function\" then
      local f_label = sub(str,11)
      f_label = sub(f_label,1,5) == \"built\"
                and f_label
                or \"f:\" .. sub(str, -6)
      local func_name = anti_G[value] or f_label
      len = #func_name
      str = c.func(func_name)
   elseif typica == \"boolean\" then
      str = value and c.truth(str) or c.falsehood(str)
   elseif typica == \"string\" then
      if value == \"\" then
         str = c.string('\"\"')
         len = 2
      else
         str = c.string(str)
      end
   elseif typica == \"number\" then
      str = c.number(str)
   elseif typica == \"nil\" then
      str = c.nilness(str)
   elseif typica == \"thread\" then
      local coro_name = anti_G[value] and \"coro:\" .. anti_G[value]
                                      or  \"coro:\" .. sub(str, -6)
      len = #coro_name
      str = c.thread(coro_name)
   elseif typica == \"userdata\" then
      if anti_G[value] then
         str = c.userdata(anti_G[value])
         len = #anti_G[value]
      else
         local name = find(str, \":\")
         if name then
            name = sub(str, 1, name - 1)
            len = #name
            str = c.userdata(name)
         else
            str = c.userdata(str)
         end
      end
   elseif typica == \"cdata\" then
      if anti_G[value] then
         str = c.cdata(anti_G[value])
         len = anti_G[value]
      else
         str = c.cdata(str)
      end
      str, len = c_data(value, str)
   end
   yield(str, len)
end

ts = function(...)
      local rep, len, done = wrap(ts_coro)(...)
      return rep, len, done
end

repr.ts = ts"]
// END RANK codeblock_210

codeblock_211 -> leaf_217
leaf_217  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function repr.ts_bw(value)
   c = C.no_color
   local to_string = ts(value)
   c = C.color
   return to_string
end"]
// END RANK codeblock_211

codeblock_212 -> leaf_218
leaf_218  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return repr"]
// END RANK codeblock_212


}
