digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 140"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-35"]


// END RANK doc_0

section_1 -> { header_2 prose_3 structure_4 prose_5 prose_6 prose_7 prose_8 prose_9 prose_10 prose_11 section_12}
{rank=same; header_2 prose_3 structure_4 prose_5 prose_6 prose_7 prose_8 prose_9 prose_10 prose_11 section_12}

header_2 [label="1 : Rainbuf"]

prose_3 [label="prose"]

structure_4 [label="structure"]

prose_5 [label="prose"]

prose_6 [label="prose"]

prose_7 [label="prose"]

prose_8 [label="prose"]

prose_9 [label="prose"]

prose_10 [label="prose"]

prose_11 [label="prose"]

section_12 [label="section: 36-140"]


// END RANK section_1

header_2 -> leaf_13
leaf_13  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Rainbuf"]
// END RANK header_2

prose_3 -> { raw_14}
{rank=same; raw_14}

raw_14 [label="raw"]


// END RANK prose_3

raw_14 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
// END RANK raw_14

structure_4 -> { hashline_16}
{rank=same; hashline_16}

hashline_16 [label="hashline"]


// END RANK structure_4

hashline_16 -> { hashtag_17}
{rank=same; hashtag_17}

hashtag_17 [label="hashtag"]


// END RANK hashline_16

hashtag_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="NB"]
// END RANK hashtag_17

prose_5 -> { prespace_19 literal_20 raw_21}
{rank=same; prespace_19 literal_20 raw_21}

prespace_19 [label="prespace"]

literal_20 [label="literal"]

raw_21 [label="raw"]


// END RANK prose_5

prespace_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_19

literal_20 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="status = uv.write(table.concat(rainbuf))"]
// END RANK literal_20

raw_21 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_21

prose_6 -> { raw_25}
{rank=same; raw_25}

raw_25 [label="raw"]


// END RANK prose_6

raw_25 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Additionally, we want good estimates of size (but see below).  Displacement,
really, which is why we want to figure those things out as late as possible.
"]
// END RANK raw_25

prose_7 -> { raw_27}
{rank=same; raw_27}

raw_27 [label="raw"]


// END RANK prose_7

raw_27 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Rainbuf is a Phrase-like class with some awareness of what's an ANSI code and
what isn't.  Each array is a line, and also includes an array with the
displacement estimate.
"]
// END RANK raw_27

prose_8 -> { raw_29}
{rank=same; raw_29}

raw_29 [label="raw"]


// END RANK prose_8

raw_29 -> leaf_30
leaf_30  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Which is 0 for an ANSI sequence and otherwise varies.  Here we will pretend
that it's 1 cell per byte, which is unlikely to get us in trouble right away.
"]
// END RANK raw_29

prose_9 -> { raw_31 prespace_32 literal_33 raw_34}
{rank=same; raw_31 prespace_32 literal_33 raw_34}

raw_31 [label="raw"]

prespace_32 [label="prespace"]

literal_33 [label="literal"]

raw_34 [label="raw"]


// END RANK prose_9

raw_31 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The utilities to determine displacement will probably go in"]
// END RANK raw_31

prespace_32 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_32

literal_33 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="anterm"]
// END RANK literal_33

raw_34 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". I have
a very general solution in mind.
"]
// END RANK raw_34

prose_10 -> { raw_39 prespace_40 literal_41 raw_42}
{rank=same; raw_39 prespace_40 literal_41 raw_42}

raw_39 [label="raw"]

prespace_40 [label="prespace"]

literal_41 [label="literal"]

raw_42 [label="raw"]


// END RANK prose_10

raw_39 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To assist in this, we'll want to patch the"]
// END RANK raw_39

prespace_40 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_40

literal_41 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label="anterm"]
// END RANK literal_41

raw_42 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" color metatable to return
a rainbuf.  The Phrase class takes whatever shape it's formed into, convenient
for AST generators.  A rainbuf is for painting an terminal, so concatenating
them always fills the leftmost.
"]
// END RANK raw_42

prose_11 -> { raw_47 prespace_48 literal_49 raw_50}
{rank=same; raw_47 prespace_48 literal_49 raw_50}

raw_47 [label="raw"]

prespace_48 [label="prespace"]

literal_49 [label="literal"]

raw_50 [label="raw"]


// END RANK prose_11

raw_47 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I suspect I'm going to find, working with"]
// END RANK raw_47

prespace_48 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_48

literal_49 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="uv"]
// END RANK literal_49

raw_50 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", that there's seldom any
advantage in concatenating strings further out than about tokens.  Downsides,
really, since any \"blagh \" is the same string but a \"blagh whuppy\" and a
\"blagh winkedy\" are unique strings.

"]
// END RANK raw_50

section_12 -> { header_55 prose_56 prose_57 prose_58 prose_59 prose_60 prose_61 prose_62 prose_63 prose_64 prose_65 prose_66 prose_67 codeblock_68 codeblock_69 codeblock_70}
{rank=same; header_55 prose_56 prose_57 prose_58 prose_59 prose_60 prose_61 prose_62 prose_63 prose_64 prose_65 prose_66 prose_67 codeblock_68 codeblock_69 codeblock_70}

header_55 [label="3 : Structure"]

prose_56 [label="prose"]

prose_57 [label="prose"]

prose_58 [label="prose"]

prose_59 [label="prose"]

prose_60 [label="prose"]

prose_61 [label="prose"]

prose_62 [label="prose"]

prose_63 [label="prose"]

prose_64 [label="prose"]

prose_65 [label="prose"]

prose_66 [label="prose"]

prose_67 [label="prose"]

codeblock_68 [label="code block 89-94"]

codeblock_69 [label="code block 101-129"]

codeblock_70 [label="code block 138-140"]


// END RANK section_12

header_55 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Structure"]
// END RANK header_55

prose_56 -> { raw_72 prespace_73 literal_74 raw_75 prespace_76 literal_77 raw_78}
{rank=same; raw_72 prespace_73 literal_74 raw_75 prespace_76 literal_77 raw_78}

raw_72 [label="raw"]

prespace_73 [label="prespace"]

literal_74 [label="literal"]

raw_75 [label="raw"]

prespace_76 [label="prespace"]

literal_77 [label="literal"]

raw_78 [label="raw"]


// END RANK prose_56

raw_72 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Rainbufs are database-shaped.  The simplest"]
// END RANK raw_72

prespace_73 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_73

literal_74 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label="r.idEst = Rainbuf"]
// END RANK literal_74

raw_75 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is an
array of strings, with a second array, keyed as"]
// END RANK raw_75

prespace_76 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_76

literal_77 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="r.wid"]
// END RANK literal_77

raw_78 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", showing the expected
displacement of the string: That is, how far left (positive) or right
(negative) the cursor is expected to move on a given print.
"]
// END RANK raw_78

prose_57 -> { raw_86 prespace_87 literal_88 raw_89}
{rank=same; raw_86 prespace_87 literal_88 raw_89}

raw_86 [label="raw"]

prespace_87 [label="prespace"]

literal_88 [label="literal"]

raw_89 [label="raw"]


// END RANK prose_57

raw_86 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is equivalent to"]
// END RANK raw_86

prespace_87 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_87

literal_88 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#tostring(r)"]
// END RANK literal_88

raw_89 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" for printable ASCII, and then starts to
diverge wildly.  Notably, any ANSI color sequence is of zero displacement.
"]
// END RANK raw_89

prose_58 -> { raw_94 prespace_95 literal_96 raw_97 prespace_98 literal_99 raw_100 prespace_101 literal_102 raw_103 prespace_104 literal_105 raw_106}
{rank=same; raw_94 prespace_95 literal_96 raw_97 prespace_98 literal_99 raw_100 prespace_101 literal_102 raw_103 prespace_104 literal_105 raw_106}

raw_94 [label="raw"]

prespace_95 [label="prespace"]

literal_96 [label="literal"]

raw_97 [label="raw"]

prespace_98 [label="prespace"]

literal_99 [label="literal"]

raw_100 [label="raw"]

prespace_101 [label="prespace"]

literal_102 [label="literal"]

raw_103 [label="raw"]

prespace_104 [label="prespace"]

literal_105 [label="literal"]

raw_106 [label="raw"]


// END RANK prose_58

raw_94 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Values of"]
// END RANK raw_94

prespace_95 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_95

literal_96 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="wid"]
// END RANK literal_96

raw_97 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" can either be numbers, in which case it is displacement by
column, or an array, in which case"]
// END RANK raw_97

prespace_98 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_98

literal_99 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="wid[0]"]
// END RANK literal_99

raw_100 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is by column and"]
// END RANK raw_100

prespace_101 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_101

literal_102 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="wid[1]"]
// END RANK literal_102

raw_103 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is by
row. "]
// END RANK raw_103

prespace_104 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_104

literal_105 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="wid"]
// END RANK literal_105

raw_106 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" can also be a string. If so it must start with \"?\". If there are
additional characters it must be a signed integer value.
"]
// END RANK raw_106

prose_59 -> { raw_120 prespace_121 bold_122 raw_123 prespace_124 literal_125 raw_126 prespace_127 literal_128 raw_129}
{rank=same; raw_120 prespace_121 bold_122 raw_123 prespace_124 literal_125 raw_126 prespace_127 literal_128 raw_129}

raw_120 [label="raw"]

prespace_121 [label="prespace"]

bold_122 [label="bold"]

raw_123 [label="raw"]

prespace_124 [label="prespace"]

literal_125 [label="literal"]

raw_126 [label="raw"]

prespace_127 [label="prespace"]

literal_128 [label="literal"]

raw_129 [label="raw"]


// END RANK prose_59

raw_120 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Rainbufs do"]
// END RANK raw_120

prespace_121 -> leaf_131
leaf_131  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_121

bold_122 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label="not"]
// END RANK bold_122

raw_123 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" contain"]
// END RANK raw_123

prespace_124 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_124

literal_125 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\\n"]
// END RANK literal_125

raw_126 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" or"]
// END RANK raw_126

prespace_127 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_127

literal_128 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label="\\r"]
// END RANK literal_128

raw_129 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  A rainbuf printer is expected to
perform newlining at the end of each rainbuf, respecting local context.  There
is no guarantee that the 1 position in a rainbuf is the 1 position on-screen.
"]
// END RANK raw_129

prose_60 -> { raw_140 prespace_141 italic_142 raw_143}
{rank=same; raw_140 prespace_141 italic_142 raw_143}

raw_140 [label="raw"]

prespace_141 [label="prespace"]

italic_142 [label="italic"]

raw_143 [label="raw"]


// END RANK prose_60

raw_140 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Rainbufs can contain sequences of unknown widlacement.  In such a case, the
displacement is"]
// END RANK raw_140

prespace_141 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_141

italic_142 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="measured"]
// END RANK italic_142

raw_143 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and recorded persistently in a database.
"]
// END RANK raw_143

prose_61 -> { raw_148 prespace_149 literal_150 raw_151}
{rank=same; raw_148 prespace_149 literal_150 raw_151}

raw_148 [label="raw"]

prespace_149 [label="prespace"]

literal_150 [label="literal"]

raw_151 [label="raw"]


// END RANK prose_61

raw_148 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If we get the string \"Hi! ðŸ¤ª\" it has a"]
// END RANK raw_148

prespace_149 -> leaf_153
leaf_153  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_149

literal_150 -> leaf_154
leaf_154  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#"]
// END RANK literal_150

raw_151 -> leaf_155
leaf_155  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" of 8. So the wid will be \"?8\",
and the actual widlacement turns out to be 6, correctly, and 5 on my tty,
which will double-print the emoji and the closing string!
"]
// END RANK raw_151

prose_62 -> { raw_156 prespace_157 literal_158 raw_159}
{rank=same; raw_156 prespace_157 literal_158 raw_159}

raw_156 [label="raw"]

prespace_157 [label="prespace"]

literal_158 [label="literal"]

raw_159 [label="raw"]


// END RANK prose_62

raw_156 -> leaf_160
leaf_160  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Solving that quirk is a bit out of scope; the point is that we'll have an
estimation engine, and that all it needs to do right now is distinguish color
sequences (0) and text (#str).  Usually the"]
// END RANK raw_156

prespace_157 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_157

literal_158 -> leaf_162
leaf_162  [color=Gray,shape=rectangle,fontname=Inconsolata,label="wc_width()"]
// END RANK literal_158

raw_159 -> leaf_163
leaf_163  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" will be correct, and
measurement will be to compensate for terminals not knowing what they've done.
"]
// END RANK raw_159

prose_63 -> { raw_164 prespace_165 bold_166 raw_167 prespace_168 bold_169 raw_170}
{rank=same; raw_164 prespace_165 bold_166 raw_167 prespace_168 bold_169 raw_170}

raw_164 [label="raw"]

prespace_165 [label="prespace"]

bold_166 [label="bold"]

raw_167 [label="raw"]

prespace_168 [label="prespace"]

bold_169 [label="bold"]

raw_170 [label="raw"]


// END RANK prose_63

raw_164 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A rainbuf that contains strings as array members may"]
// END RANK raw_164

prespace_165 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_165

bold_166 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label="only"]
// END RANK bold_166

raw_167 -> leaf_174
leaf_174  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" have strings as
array members.  This is called a line, and a rainbuf which contains a line
as an array member may"]
// END RANK raw_167

prespace_168 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_168

bold_169 -> leaf_176
leaf_176  [color=Gray,shape=rectangle,fontname=Inconsolata,label="only"]
// END RANK bold_169

raw_170 -> leaf_177
leaf_177  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" have lines as members.
"]
// END RANK raw_170

prose_64 -> { raw_178}
{rank=same; raw_178}

raw_178 [label="raw"]


// END RANK prose_64

raw_178 -> leaf_179
leaf_179  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
These we call blocks. Every aggregate beyond this is also a block, and there
is no limit on these levels of detail, but every rainbuf member of a block
must have the same depth, so that in all cases, the same number of lookups
lead to a string.
"]
// END RANK raw_178

prose_65 -> { raw_180 prespace_181 literal_182 raw_183 prespace_184 literal_185 raw_186 prespace_187 literal_188 raw_189}
{rank=same; raw_180 prespace_181 literal_182 raw_183 prespace_184 literal_185 raw_186 prespace_187 literal_188 raw_189}

raw_180 [label="raw"]

prespace_181 [label="prespace"]

literal_182 [label="literal"]

raw_183 [label="raw"]

prespace_184 [label="prespace"]

literal_185 [label="literal"]

raw_186 [label="raw"]

prespace_187 [label="prespace"]

literal_188 [label="literal"]

raw_189 [label="raw"]


// END RANK prose_65

raw_180 -> leaf_190
leaf_190  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
In code these distinctions are made with a single field"]
// END RANK raw_180

prespace_181 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_181

literal_182 -> leaf_192
leaf_192  [color=Gray,shape=rectangle,fontname=Inconsolata,label="d"]
// END RANK literal_182

raw_183 -> leaf_193
leaf_193  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", an unsigned
integer.  Lines have a"]
// END RANK raw_183

prespace_184 -> leaf_194
leaf_194  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_184

literal_185 -> leaf_195
leaf_195  [color=Gray,shape=rectangle,fontname=Inconsolata,label="d"]
// END RANK literal_185

raw_186 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" of one,"]
// END RANK raw_186

prespace_187 -> leaf_197
leaf_197  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_187

literal_188 -> leaf_198
leaf_198  [color=Gray,shape=rectangle,fontname=Inconsolata,label="d = 0"]
// END RANK literal_188

raw_189 -> leaf_199
leaf_199  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is the strings themselves.
"]
// END RANK raw_189

prose_66 -> { raw_200}
{rank=same; raw_200}

raw_200 [label="raw"]


// END RANK prose_66

raw_200 -> leaf_201
leaf_201  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There will be other fields; rainbuf is the last stop before the terminal, and
needs to convey various hints to the renderer so that e.g. mouse targets line
up with the correct regions.  It is cleaner for things like elided blocks to
live in the rainbuf than to be synced by the renderer.
"]
// END RANK raw_200

prose_67 -> { raw_202}
{rank=same; raw_202}

raw_202 [label="raw"]


// END RANK prose_67

raw_202 -> leaf_203
leaf_203  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I think.  Because we're operating on an event loop, the rainbuf has to both
soley own write access to itself, and only lend out one read pointer after
an atomic update.  That implies two different views must be separate rainbufs
fed from the same quipu, and renderers are rainbuf interpreters.
"]
// END RANK raw_202

codeblock_68 -> leaf_204
leaf_204  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Txtbuf = require \"txtbuf\"
local byte = assert(string.byte)

local Rainbuf = meta {}"]
// END RANK codeblock_68

codeblock_69 -> leaf_205
leaf_205  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(txtbuf)
   local rainbuf = meta(Rainbuf)
   local wid = {}
   rainbuf.wid = wid
   if type(txtbuf) == \"string\" then
      txtbuf = Txtbuf(txtbuf)
   elseif type(txtbuf) == \"table\" then
      if txtbuf.idEst == Txtbuf then
         _from_txtbuf(rainbuf, txtbuf)
      else
         for i,v in ipairs(txtbuf) do
            if type(v) == \"string\" then
               rainbuf[i] = v
               if byte(v) == 0x1b then
                  wid[i] = 0
               else
                  wid[i] = v
               end
            else
               error(\"content of table in Rainbuf must be strings\")
            end
         end
      end
   end
   return rainbuf
end
Rainbuf.idEst = new"]
// END RANK codeblock_69

codeblock_70 -> leaf_206
leaf_206  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]
// END RANK codeblock_70


}
