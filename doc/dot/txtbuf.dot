digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 349"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-33"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 prose_7 section_8 section_9}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 prose_7 section_8 section_9}

header_2 [label="1 : Txtbuf"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

prose_7 [label="prose"]

section_8 [label="section: 17-21"]

section_9 [label="section: 34-318"]


// END RANK section_1

header_2 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Txtbuf"]
// END RANK header_2

prose_3 -> { raw_11}
{rank=same; raw_11}

raw_11 [label="raw"]


// END RANK prose_3

raw_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

We're not going to have one of these right away.
"]
// END RANK raw_11

prose_4 -> { raw_13}
{rank=same; raw_13}

raw_13 [label="raw"]


// END RANK prose_4

raw_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is not much more than an ordinary array of lines that has a bit of
awareness, mostly about which lines have cursors and which don't.
"]
// END RANK raw_13

prose_5 -> { raw_15}
{rank=same; raw_15}

raw_15 [label="raw"]


// END RANK prose_5

raw_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'll circle back for quipu but I want a basic editor as soon as possible. The
interaction dynamics need to be worked out right away, plus I want to use it!
"]
// END RANK raw_15

prose_6 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


// END RANK prose_6

raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Plan: A line that has a cursor on it, and there can be many, gets 'opened'
into a grid of characters.  These in turn get 'closed' when the cursor leaves.
"]
// END RANK raw_17

prose_7 -> { raw_19}
{rank=same; raw_19}

raw_19 [label="raw"]


// END RANK prose_7

raw_19 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A closed line is just a string.

"]
// END RANK raw_19

section_8 -> { header_21 prose_22 section_23}
{rank=same; header_21 prose_22 section_23}

header_21 [label="2 : Interface"]

prose_22 [label="prose"]

section_23 [label="section: 22-33"]


// END RANK section_8

header_21 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Interface"]
// END RANK header_21

prose_22 -> { raw_25}
{rank=same; raw_25}

raw_25 [label="raw"]


// END RANK prose_22

raw_25 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  A txtbuf is a drop-in replacement for a txtbuf, used when there's more than
one line to buffer.
"]
// END RANK raw_25

section_23 -> { header_27 prose_28 prose_29 prose_30 prose_31}
{rank=same; header_27 prose_28 prose_29 prose_30 prose_31}

header_27 [label="3 : Instance fields"]

prose_28 [label="prose"]

prose_29 [label="prose"]

prose_30 [label="prose"]

prose_31 [label="prose"]


// END RANK section_23

header_27 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Instance fields"]
// END RANK header_27

prose_28 -> { raw_33}
{rank=same; raw_33}

raw_33 [label="raw"]


// END RANK prose_28

raw_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

- lines :  An array of arrays containing codepoints (string fragments).
"]
// END RANK raw_33

prose_29 -> { raw_35}
{rank=same; raw_35}

raw_35 [label="raw"]


// END RANK prose_29

raw_35 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- cursor :  Number of fragments to skip before an insertion.
"]
// END RANK raw_35

prose_30 -> { raw_37}
{rank=same; raw_37}

raw_37 [label="raw"]


// END RANK prose_30

raw_37 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- cur_row :  Row containing the cursor.
"]
// END RANK raw_37

prose_31 -> { raw_39}
{rank=same; raw_39}

raw_39 [label="raw"]


// END RANK prose_31

raw_39 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- disp :  Array of numbers, representing the furthest-right column which
          may be reached by printing the corresponding row.

"]
// END RANK raw_39

section_9 -> { header_41 prose_42 prose_43 prose_44 prose_45 section_46 section_47 section_48 section_49 section_50 section_51 section_52 section_53 section_54 section_55 section_56}
{rank=same; header_41 prose_42 prose_43 prose_44 prose_45 section_46 section_47 section_48 section_49 section_50 section_51 section_52 section_53 section_54 section_55 section_56}

header_41 [label="2 : Methods"]

prose_42 [label="prose"]

prose_43 [label="prose"]

prose_44 [label="prose"]

prose_45 [label="prose"]

section_46 [label="section: 49-61"]

section_47 [label="section: 62-93"]

section_48 [label="section: 94-128"]

section_49 [label="section: 129-141"]

section_50 [label="section: 142-171"]

section_51 [label="section: 172-180"]

section_52 [label="section: 181-196"]

section_53 [label="section: 197-213"]

section_54 [label="section: 214-245"]

section_55 [label="section: 246-318"]

section_56 [label="section: 319-349"]


// END RANK section_9

header_41 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Methods"]
// END RANK header_41

prose_42 -> { raw_58}
{rank=same; raw_58}

raw_58 [label="raw"]


// END RANK prose_42

raw_58 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Initially these are only the methods of txtbuf.
"]
// END RANK raw_58

prose_43 -> { raw_60}
{rank=same; raw_60}

raw_60 [label="raw"]


// END RANK prose_43

raw_60 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I think the way forward is to treat txtbuf as a special case until it's at
feature parity, and we have the other aspects such as resizing the result
field working correctly.
"]
// END RANK raw_60

prose_44 -> { raw_62 prespace_63 literal_64 raw_65 prespace_66 literal_67 raw_68}
{rank=same; raw_62 prespace_63 literal_64 raw_65 prespace_66 literal_67 raw_68}

raw_62 [label="raw"]

prespace_63 [label="prespace"]

literal_64 [label="literal"]

raw_65 [label="raw"]

prespace_66 [label="prespace"]

literal_67 [label="literal"]

raw_68 [label="raw"]


// END RANK prose_44

raw_62 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Then we will simply switch to using"]
// END RANK raw_62

prespace_63 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_63

literal_64 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="txtbuf"]
// END RANK literal_64

raw_65 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="s of a single line instead of the
two separate classes, and factor out"]
// END RANK raw_65

prespace_66 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_66

literal_67 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="txtbuf"]
// END RANK literal_67

raw_68 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_68

prose_45 -> { raw_76 prespace_77 literal_78 raw_79}
{rank=same; raw_76 prespace_77 literal_78 raw_79}

raw_76 [label="raw"]

prespace_77 [label="prespace"]

literal_78 [label="literal"]

raw_79 [label="raw"]


// END RANK prose_45

raw_76 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This amounts to porting the existing"]
// END RANK raw_76

prespace_77 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_77

literal_78 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="txtbuf"]
// END RANK literal_78

raw_79 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", as I think about it. A single
line isn't even a special case for the logic.

"]
// END RANK raw_79

section_46 -> { header_84 prose_85 codeblock_86 codeblock_87}
{rank=same; header_84 prose_85 codeblock_86 codeblock_87}

header_84 [label="4 : dependencies"]

prose_85 [label="prose"]

codeblock_86 [label="code block 51-56"]

codeblock_87 [label="code block 58-60"]


// END RANK section_46

header_84 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** dependencies"]
// END RANK header_84

prose_85 -> { raw_89}
{rank=same; raw_89}

raw_89 [label="raw"]


// END RANK prose_85

raw_89 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_89

codeblock_86 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="assert(meta)
local collect = assert(table.collect)
local lines = assert(string.lines)
local codepoints = assert(string.codepoints)"]
// END RANK codeblock_86

codeblock_87 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Txtbuf = meta {}"]
// END RANK codeblock_87

section_47 -> { header_93 prose_94 codeblock_95 codeblock_96}
{rank=same; header_93 prose_94 codeblock_95 codeblock_96}

header_93 [label="3 : Txtbuf.__tostring(txtbuf)"]

prose_94 [label="prose"]

codeblock_95 [label="code block 64-80"]

codeblock_96 [label="code block 82-91"]


// END RANK section_47

header_93 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf.__tostring(txtbuf)"]
// END RANK header_93

prose_94 -> { raw_98}
{rank=same; raw_98}

raw_98 [label="raw"]


// END RANK prose_94

raw_98 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_98

codeblock_95 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local concat = assert(table.concat)

local function cat(l)
   if type(l) == \"string\" then
      return l
   elseif type(l) == \"table\" then
      if l[1] ~= nil then
         return concat(l)
      else
         return \"\"
      end
   end

   error(\"called private fn cat with type\" .. type(l))
end"]
// END RANK codeblock_95

codeblock_96 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.__tostring(txtbuf)
   local phrase = \"\"
   for i = 1, #txtbuf.lines - 1 do
      phrase = phrase .. cat(txtbuf.lines[i]) .. \"\\n\"
   end

   return phrase .. cat(txtbuf.lines[#txtbuf.lines])
end"]
// END RANK codeblock_96

section_48 -> { header_102 prose_103 codeblock_104}
{rank=same; header_102 prose_103 codeblock_104}

header_102 [label="3 : Txtbuf:insert(frag)"]

prose_103 [label="prose"]

codeblock_104 [label="code block 96-126"]


// END RANK section_48

header_102 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:insert(frag)"]
// END RANK header_102

prose_103 -> { raw_106}
{rank=same; raw_106}

raw_106 [label="raw"]


// END RANK prose_103

raw_106 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_106

codeblock_104 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local t_insert, splice = assert(table.insert), assert(table.splice)
local utf8, codepoints = string.utf8, string.codepoints

function Txtbuf.insert(txtbuf, frag)
   local line = txtbuf.lines[txtbuf.cur_row]
   if type(line) == \"string\" then
      line = codepoints(line)
      txtbuf.line = line
   end
   local wide_frag = utf8(frag)
   if wide_frag < #frag then -- a paste
      -- Normalize whitespace
      frag = gsub(frag, \"\\r\\n\", \"\\n\"):gsub(\"\\r\", \"\\n\"):gsub(\"\\t\", \"   \")
      wide_frag = codepoints(frag)
   else
      wide_frag = false
   end
   if not wide_frag then
      t_insert(line, txtbuf.cursor, frag)
      txtbuf.cursor = txtbuf.cursor + 1
      return true
   else
      splice(line, txtbuf.cursor, wide_frag)
      txtbuf.cursor = txtbuf.cursor + #wide_frag
      return true
   end

   return false
end"]
// END RANK codeblock_104

section_49 -> { header_109 prose_110 codeblock_111}
{rank=same; header_109 prose_110 codeblock_111}

header_109 [label="3 : Txtbuf:advance()"]

prose_110 [label="prose"]

codeblock_111 [label="code block 131-139"]


// END RANK section_49

header_109 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:advance()"]
// END RANK header_109

prose_110 -> { raw_113}
{rank=same; raw_113}

raw_113 [label="raw"]


// END RANK prose_110

raw_113 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_113

codeblock_111 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local ts_bw = (require \"color\").ts_bw

function Txtbuf.advance(txtbuf)
   txtbuf.lines[#txtbuf.lines + 1] = {}
   txtbuf.cur_row = #txtbuf.lines
   txtbuf.cursor = 1
end"]
// END RANK codeblock_111

section_50 -> { header_116 prose_117 codeblock_118}
{rank=same; header_116 prose_117 codeblock_118}

header_116 [label="3 : Txtbuf:d_back()"]

prose_117 [label="prose"]

codeblock_118 [label="code block 147-169"]


// END RANK section_50

header_116 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:d_back()"]
// END RANK header_116

prose_117 -> { raw_120}
{rank=same; raw_120}

raw_120 [label="raw"]


// END RANK prose_117

raw_120 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The return value tells us if we have one less line, since we need to
clear it off the screen.
"]
// END RANK raw_120

codeblock_118 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local remove = assert(table.remove)

function Txtbuf.d_back(txtbuf)
   local cursor, cur_row = txtbuf.cursor, txtbuf.cur_row
   if cursor > 1 then
      remove(txtbuf.lines[cur_row], cursor - 1)
      txtbuf.cursor = cursor - 1
      return false
   elseif cur_row == 1 then
      return false
   else
      local new_line = concat(txtbuf.lines[cur_row - 1])
                       .. concat(txtbuf.lines[cur_row])
      local new_cursor = #txtbuf.lines[cur_row - 1]
      txtbuf.lines[cur_row - 1] = codepoints(new_line)
      remove(txtbuf.lines, cur_row)
      txtbuf.cur_row = cur_row - 1
      txtbuf.cursor = new_cursor
      return true
   end
end"]
// END RANK codeblock_118

section_51 -> { header_123 prose_124 codeblock_125}
{rank=same; header_123 prose_124 codeblock_125}

header_123 [label="3 : Txtbuf:d_fwd()"]

prose_124 [label="prose"]

codeblock_125 [label="code block 174-178"]


// END RANK section_51

header_123 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:d_fwd()"]
// END RANK header_123

prose_124 -> { raw_127}
{rank=same; raw_127}

raw_127 [label="raw"]


// END RANK prose_124

raw_127 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_127

codeblock_125 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.d_fwd(txtbuf)
   remove(txtbuf.lines[txtbuf.cur_row], txtbuf.cursor)
end"]
// END RANK codeblock_125

section_52 -> { header_130 prose_131 codeblock_132}
{rank=same; header_130 prose_131 codeblock_132}

header_130 [label="3 : Txtbuf:left(disp)"]

prose_131 [label="prose"]

codeblock_132 [label="code block 183-194"]


// END RANK section_52

header_130 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:left(disp)"]
// END RANK header_130

prose_131 -> { raw_134}
{rank=same; raw_134}

raw_134 [label="raw"]


// END RANK prose_131

raw_134 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_134

codeblock_132 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.left(txtbuf, disp)
   local disp = disp or 1
   if txtbuf.cursor - disp >= 1 then
      txtbuf.cursor = txtbuf.cursor - disp
   else
      txtbuf.cursor = 1
   end

   return txtbuf.cursor
end"]
// END RANK codeblock_132

section_53 -> { header_137 prose_138 codeblock_139}
{rank=same; header_137 prose_138 codeblock_139}

header_137 [label="3 : Txtbuf:right(disp)"]

prose_138 [label="prose"]

codeblock_139 [label="code block 199-211"]


// END RANK section_53

header_137 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:right(disp)"]
// END RANK header_137

prose_138 -> { raw_141}
{rank=same; raw_141}

raw_141 [label="raw"]


// END RANK prose_138

raw_141 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_141

codeblock_139 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.right(txtbuf, disp)
   disp = disp or 1
   local line = txtbuf.lines[txtbuf.cur_row]
   if txtbuf.cursor + disp <= #line + 1 then
      txtbuf.cursor = txtbuf.cursor + disp
   else
      txtbuf.cursor = #line + 1
   end

   return txtbuf.cursor
end"]
// END RANK codeblock_139

section_54 -> { header_144 prose_145 codeblock_146 codeblock_147}
{rank=same; header_144 prose_145 codeblock_146 codeblock_147}

header_144 [label="3 : Txtbuf:up(), Txtbuf:down()"]

prose_145 [label="prose"]

codeblock_146 [label="code block 216-229"]

codeblock_147 [label="code block 231-244"]


// END RANK section_54

header_144 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:up(), Txtbuf:down()"]
// END RANK header_144

prose_145 -> { raw_149}
{rank=same; raw_149}

raw_149 [label="raw"]


// END RANK prose_145

raw_149 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_149

codeblock_146 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.up(txtbuf)
   local cur_row = txtbuf.cur_row
   if cur_row == 1 then
      return false
   else
      txtbuf.cur_row = cur_row - 1
      if txtbuf.cursor > #txtbuf.lines[txtbuf.cur_row] + 1 then
         txtbuf.cursor = #txtbuf.lines[txtbuf.cur_row] + 1
      end
      return true
   end
end"]
// END RANK codeblock_146

codeblock_147 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.down(txtbuf)
   local cur_row = txtbuf.cur_row
   if cur_row == #txtbuf.lines then
      return false
   else
      txtbuf.cur_row = cur_row + 1
      if txtbuf.cursor > #txtbuf.lines[txtbuf.cur_row] + 1 then
         txtbuf.cursor = #txtbuf.lines[txtbuf.cur_row] + 1
      end
      return true
   end
end"]
// END RANK codeblock_147

section_55 -> { header_153 prose_154 codeblock_155 codeblock_156 codeblock_157 codeblock_158}
{rank=same; header_153 prose_154 codeblock_155 codeblock_156 codeblock_157 codeblock_158}

header_153 [label="3 : Txtbuf:nl()"]

prose_154 [label="prose"]

codeblock_155 [label="code block 250-281"]

codeblock_156 [label="code block 284-292"]

codeblock_157 [label="code block 294-304"]

codeblock_158 [label="code block 306-316"]


// END RANK section_55

header_153 -> leaf_159
leaf_159  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:nl()"]
// END RANK header_153

prose_154 -> { raw_160}
{rank=same; raw_160}

raw_160 [label="raw"]


// END RANK prose_154

raw_160 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Either splits a line or (more usually) evaluates.
"]
// END RANK raw_160

codeblock_155 -> leaf_162
leaf_162  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local sub = assert(string.sub)
local insert = assert(table.insert)
function Txtbuf.nl(txtbuf)
   -- Most txtbufs are one line, so we always evaluate from
   -- a one-liner, regardless of cursor location.
   local linum = #txtbuf.lines
   if linum == 1 then
      return true
   end
   local cursor = txtbuf.cursor
   local cur_row = txtbuf.cur_row
   -- these are the two default positions for up and down
   -- history search
   if cur_row == 1 and cursor > #txtbuf.lines[1] then
      return true
   end
   if cur_row == linum and cursor > #txtbuf.lines[linum] then
      return true
   end
   -- split the line
   local cur_line = concat(txtbuf.lines[txtbuf.cur_row])
   local first = sub(cur_line, 1, cursor - 1)
   local second = sub(cur_line, cursor)
   txtbuf.lines[cur_row] = codepoints(first)
   insert(txtbuf.lines, cur_row + 1, codepoints(second))
   txtbuf.cursor = 1
   txtbuf.cur_row = cur_row + 1

   return false
end"]
// END RANK codeblock_155

codeblock_156 -> leaf_163
leaf_163  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.suspend(txtbuf)
   for i,v in ipairs(txtbuf.lines) do
      txtbuf.lines[i] = tostring(v)
   end

   return txtbuf
end"]
// END RANK codeblock_156

codeblock_157 -> leaf_164
leaf_164  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.resume(txtbuf)
   for i, line in ipairs(txtbuf.lines) do
      txtbuf.lines[i] = codepoints(line)
   end
   txtbuf.cursor = #txtbuf.lines[#txtbuf.lines] + 1
   txtbuf.cur_row = #txtbuf.lines

   return txtbuf
end"]
// END RANK codeblock_157

codeblock_158 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local cl = assert(table.clone, \"table.clone must be provided\")

function Txtbuf.clone(txtbuf)
   local tb = cl(txtbuf, 3)
   if type(tb.lines[1]) == \"string\" then
      return tb:resume()
   end
   return tb
end"]
// END RANK codeblock_158

section_56 -> { header_166 prose_167 codeblock_168 codeblock_169}
{rank=same; header_166 prose_167 codeblock_168 codeblock_169}

header_166 [label="3 : new"]

prose_167 [label="prose"]

codeblock_168 [label="code block 321-345"]

codeblock_169 [label="code block 347-349"]


// END RANK section_56

header_166 -> leaf_170
leaf_170  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** new"]
// END RANK header_166

prose_167 -> { raw_171}
{rank=same; raw_171}

raw_171 [label="raw"]


// END RANK prose_167

raw_171 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_171

codeblock_168 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function into_codepoints(lines)
   local cp = {}
   for i,v in ipairs(lines) do
      cp[i] = codepoints(v)
   end

   return cp
end

local function new(line)
   local txtbuf = meta(Txtbuf)
   local __l = line or \"\"
   local _lines = into_codepoints(collect(lines, __l))
   if #_lines == 0 then
      _lines[1] = {}
   end
   txtbuf.cursor = line and #_lines[#_lines] + 1 or 1
   txtbuf.cur_row = line and #_lines  or 1
   txtbuf.lines = _lines
   return txtbuf
end

Txtbuf.idEst = new"]
// END RANK codeblock_168

codeblock_169 -> leaf_174
leaf_174  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]
// END RANK codeblock_169


}
