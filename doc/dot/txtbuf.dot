digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 246"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-33"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 prose_5 prose_6 prose_7 section_8 section_9}
{rank=same; header_2 prose_3 prose_4 prose_5 prose_6 prose_7 section_8 section_9}

header_2 [label="1 : Txtbuf"]

prose_3 [label="prose"]

prose_4 [label="prose"]

prose_5 [label="prose"]

prose_6 [label="prose"]

prose_7 [label="prose"]

section_8 [label="section: 17-21"]

section_9 [label="section: 34-213"]


// END RANK section_1

header_2 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Txtbuf"]
// END RANK header_2

prose_3 -> { raw_11}
{rank=same; raw_11}

raw_11 [label="raw"]


// END RANK prose_3

raw_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

We're not going to have one of these right away.
"]
// END RANK raw_11

prose_4 -> { raw_13}
{rank=same; raw_13}

raw_13 [label="raw"]


// END RANK prose_4

raw_13 -> leaf_14
leaf_14  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is not much more than an ordinary array of lines that has a bit of
awareness, mostly about which lines have cursors and which don't.
"]
// END RANK raw_13

prose_5 -> { raw_15}
{rank=same; raw_15}

raw_15 [label="raw"]


// END RANK prose_5

raw_15 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'll circle back for quipu but I want a basic editor as soon as possible. The
interaction dynamics need to be worked out right away, plus I want to use it!
"]
// END RANK raw_15

prose_6 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


// END RANK prose_6

raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Plan: A line that has a cursor on it, and there can be many, gets 'opened'
into a grid of characters.  These in turn get 'closed' when the cursor leaves.
"]
// END RANK raw_17

prose_7 -> { raw_19}
{rank=same; raw_19}

raw_19 [label="raw"]


// END RANK prose_7

raw_19 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
A closed line is just a string.

"]
// END RANK raw_19

section_8 -> { header_21 prose_22 section_23}
{rank=same; header_21 prose_22 section_23}

header_21 [label="2 : Interface"]

prose_22 [label="prose"]

section_23 [label="section: 22-33"]


// END RANK section_8

header_21 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Interface"]
// END RANK header_21

prose_22 -> { raw_25}
{rank=same; raw_25}

raw_25 [label="raw"]


// END RANK prose_22

raw_25 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  A txtbuf is a drop-in replacement for a linebuf, used when there's more than
one line to buffer.
"]
// END RANK raw_25

section_23 -> { header_27 prose_28 prose_29 prose_30 prose_31}
{rank=same; header_27 prose_28 prose_29 prose_30 prose_31}

header_27 [label="3 : Instance fields"]

prose_28 [label="prose"]

prose_29 [label="prose"]

prose_30 [label="prose"]

prose_31 [label="prose"]


// END RANK section_23

header_27 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Instance fields"]
// END RANK header_27

prose_28 -> { raw_33}
{rank=same; raw_33}

raw_33 [label="raw"]


// END RANK prose_28

raw_33 -> leaf_34
leaf_34  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

- lines :  An array of arrays containing codepoints (string fragments).
"]
// END RANK raw_33

prose_29 -> { raw_35}
{rank=same; raw_35}

raw_35 [label="raw"]


// END RANK prose_29

raw_35 -> leaf_36
leaf_36  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- cursor :  Number of fragments to skip before an insertion.
"]
// END RANK raw_35

prose_30 -> { raw_37}
{rank=same; raw_37}

raw_37 [label="raw"]


// END RANK prose_30

raw_37 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- cur_row :  Row containing the cursor.
"]
// END RANK raw_37

prose_31 -> { raw_39}
{rank=same; raw_39}

raw_39 [label="raw"]


// END RANK prose_31

raw_39 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
- disp :  Array of numbers, representing the furthest-right column which
          may be reached by printing the corresponding row.

"]
// END RANK raw_39

section_9 -> { header_41 prose_42 prose_43 prose_44 prose_45 section_46 section_47 section_48 section_49 section_50 section_51 section_52 section_53}
{rank=same; header_41 prose_42 prose_43 prose_44 prose_45 section_46 section_47 section_48 section_49 section_50 section_51 section_52 section_53}

header_41 [label="2 : Methods"]

prose_42 [label="prose"]

prose_43 [label="prose"]

prose_44 [label="prose"]

prose_45 [label="prose"]

section_46 [label="section: 49-61"]

section_47 [label="section: 62-86"]

section_48 [label="section: 87-120"]

section_49 [label="section: 121-132"]

section_50 [label="section: 133-141"]

section_51 [label="section: 142-157"]

section_52 [label="section: 158-213"]

section_53 [label="section: 214-246"]


// END RANK section_9

header_41 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Methods"]
// END RANK header_41

prose_42 -> { raw_55}
{rank=same; raw_55}

raw_55 [label="raw"]


// END RANK prose_42

raw_55 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Initially these are only the methods of linebuf.
"]
// END RANK raw_55

prose_43 -> { raw_57}
{rank=same; raw_57}

raw_57 [label="raw"]


// END RANK prose_43

raw_57 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I think the way forward is to treat txtbuf as a special case until it's at
feature parity, and we have the other aspects such as resizing the result
field working correctly.
"]
// END RANK raw_57

prose_44 -> { raw_59 prespace_60 literal_61 raw_62 prespace_63 literal_64 raw_65}
{rank=same; raw_59 prespace_60 literal_61 raw_62 prespace_63 literal_64 raw_65}

raw_59 [label="raw"]

prespace_60 [label="prespace"]

literal_61 [label="literal"]

raw_62 [label="raw"]

prespace_63 [label="prespace"]

literal_64 [label="literal"]

raw_65 [label="raw"]


// END RANK prose_44

raw_59 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Then we will simply switch to using"]
// END RANK raw_59

prespace_60 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_60

literal_61 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="txtbuf"]
// END RANK literal_61

raw_62 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="s of a single line instead of the
two separate classes, and factor out"]
// END RANK raw_62

prespace_63 -> leaf_70
leaf_70  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_63

literal_64 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="linebuf"]
// END RANK literal_64

raw_65 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_65

prose_45 -> { raw_73 prespace_74 literal_75 raw_76}
{rank=same; raw_73 prespace_74 literal_75 raw_76}

raw_73 [label="raw"]

prespace_74 [label="prespace"]

literal_75 [label="literal"]

raw_76 [label="raw"]


// END RANK prose_45

raw_73 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This amounts to porting the existing"]
// END RANK raw_73

prespace_74 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_74

literal_75 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label="linebuf"]
// END RANK literal_75

raw_76 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", as I think about it. A single
line isn't even a special case for the logic.

"]
// END RANK raw_76

section_46 -> { header_81 prose_82 codeblock_83 codeblock_84}
{rank=same; header_81 prose_82 codeblock_83 codeblock_84}

header_81 [label="4 : dependencies"]

prose_82 [label="prose"]

codeblock_83 [label="code block 51-56"]

codeblock_84 [label="code block 58-60"]


// END RANK section_46

header_81 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** dependencies"]
// END RANK header_81

prose_82 -> { raw_86}
{rank=same; raw_86}

raw_86 [label="raw"]


// END RANK prose_82

raw_86 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_86

codeblock_83 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="assert(meta)
local collect = assert(table.collect)
local lines = assert(string.lines)
local codepoints = assert(string.codepoints)"]
// END RANK codeblock_83

codeblock_84 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local Txtbuf = meta {}"]
// END RANK codeblock_84

section_47 -> { header_90 prose_91 codeblock_92}
{rank=same; header_90 prose_91 codeblock_92}

header_90 [label="3 : Txtbuf.__tostring(txtbuf)"]

prose_91 [label="prose"]

codeblock_92 [label="code block 64-85"]


// END RANK section_47

header_90 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf.__tostring(txtbuf)"]
// END RANK header_90

prose_91 -> { raw_94}
{rank=same; raw_94}

raw_94 [label="raw"]


// END RANK prose_91

raw_94 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_94

codeblock_92 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local concat = assert(table.concat)

local function cat(l)
   if type(l) == \"string\" then
      return l
   elseif type(l) == \"table\" then
      return concat(l)
   end

   error(\"called private fn cat with type\" .. type(l))
end

function Txtbuf.__tostring(txtbuf)
   local phrase = \"\"
   for i = 1, #txtbuf.lines - 1 do
      phrase = phrase .. cat(txtbuf.lines[i]) .. \"\\n\"
   end

   return phrase .. cat(txtbuf.lines[#txtbuf.lines])
end"]
// END RANK codeblock_92

section_48 -> { header_97 prose_98 codeblock_99}
{rank=same; header_97 prose_98 codeblock_99}

header_97 [label="3 : Txtbuf:insert(frag)"]

prose_98 [label="prose"]

codeblock_99 [label="code block 89-119"]


// END RANK section_48

header_97 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:insert(frag)"]
// END RANK header_97

prose_98 -> { raw_101}
{rank=same; raw_101}

raw_101 [label="raw"]


// END RANK prose_98

raw_101 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_101

codeblock_99 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local t_insert, splice = assert(table.insert), assert(table.splice)
local utf8, codepoints = string.utf8, string.codepoints

function Txtbuf.insert(txtbuf, frag)
   local line = txtbuf.lines[txtbuf.cur_row]
   if type(line) == \"string\" then
      line = codepoints(line)
      txtbuf.line = line
   end
   local wide_frag = utf8(frag)
   if wide_frag < #frag then -- a paste
      -- Normalize whitespace
      frag = gsub(frag, \"\\r\\n\", \"\\n\"):gsub(\"\\r\", \"\\n\"):gsub(\"\\t\", \"   \")
      wide_frag = codepoints(frag)
   else
      wide_frag = false
   end
   if not wide_frag then
      t_insert(line, txtbuf.cursor, frag)
      txtbuf.cursor = txtbuf.cursor + 1
      return true
   else
      splice(line, txtbuf.cursor, wide_frag)
      txtbuf.cursor = txtbuf.cursor + #wide_frag
      return true
   end

   return false
end"]
// END RANK codeblock_99

section_49 -> { header_104 prose_105 codeblock_106}
{rank=same; header_104 prose_105 codeblock_106}

header_104 [label="3 : Txtbuf:d_back()"]

prose_105 [label="prose"]

codeblock_106 [label="code block 123-130"]


// END RANK section_49

header_104 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:d_back()"]
// END RANK header_104

prose_105 -> { raw_108}
{rank=same; raw_108}

raw_108 [label="raw"]


// END RANK prose_105

raw_108 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_108

codeblock_106 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local remove = assert(table.remove)

function Txtbuf.d_back(txtbuf)
   remove(txtbuf.lines[txtbuf.cur_row], txtbuf.cursor - 1)
   txtbuf.cursor = txtbuf.cursor > 1 and txtbuf.cursor - 1 or 1
end"]
// END RANK codeblock_106

section_50 -> { header_111 prose_112 codeblock_113}
{rank=same; header_111 prose_112 codeblock_113}

header_111 [label="3 : Txtbuf:d_fwd()"]

prose_112 [label="prose"]

codeblock_113 [label="code block 135-139"]


// END RANK section_50

header_111 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:d_fwd()"]
// END RANK header_111

prose_112 -> { raw_115}
{rank=same; raw_115}

raw_115 [label="raw"]


// END RANK prose_112

raw_115 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_115

codeblock_113 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.d_fwd(txtbuf)
   remove(txtbuf.lines[txtbuf.cur_row], txtbuf.cursor)
end"]
// END RANK codeblock_113

section_51 -> { header_118 prose_119 codeblock_120}
{rank=same; header_118 prose_119 codeblock_120}

header_118 [label="3 : Txtbuf:left(disp)"]

prose_119 [label="prose"]

codeblock_120 [label="code block 144-155"]


// END RANK section_51

header_118 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:left(disp)"]
// END RANK header_118

prose_119 -> { raw_122}
{rank=same; raw_122}

raw_122 [label="raw"]


// END RANK prose_119

raw_122 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_122

codeblock_120 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.left(txtbuf, disp)
   local disp = disp or 1
   if txtbuf.cursor - disp >= 1 then
      txtbuf.cursor = txtbuf.cursor - disp
   else
      txtbuf.cursor = 1
   end

   return txtbuf.cursor
end"]
// END RANK codeblock_120

section_52 -> { header_125 prose_126 codeblock_127 codeblock_128 codeblock_129 codeblock_130}
{rank=same; header_125 prose_126 codeblock_127 codeblock_128 codeblock_129 codeblock_130}

header_125 [label="3 : Txtbuf:right(disp)"]

prose_126 [label="prose"]

codeblock_127 [label="code block 160-172"]

codeblock_128 [label="code block 175-183"]

codeblock_129 [label="code block 185-195"]

codeblock_130 [label="code block 197-211"]


// END RANK section_52

header_125 -> leaf_131
leaf_131  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Txtbuf:right(disp)"]
// END RANK header_125

prose_126 -> { raw_132}
{rank=same; raw_132}

raw_132 [label="raw"]


// END RANK prose_126

raw_132 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_132

codeblock_127 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.right(txtbuf, disp)
   disp = disp or 1
   local line = txtbuf.lines[txtbuf.cur_row]
   if txtbuf.cursor + disp <= #line + 1 then
      txtbuf.cursor = txtbuf.cursor + disp
   else
      txtbuf.cursor = #line + 1
   end

   return txtbuf.cursor
end"]
// END RANK codeblock_127

codeblock_128 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.suspend(txtbuf)
   for i,v in ipairs(txtbuf.lines) do
      txtbuf.lines[i] = tostring(v)
   end

   return txtbuf
end"]
// END RANK codeblock_128

codeblock_129 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function Txtbuf.resume(txtbuf)
   for i, line in ipairs(txtbuf.lines) do
      txtbuf.lines[i] = codepoints(line)
   end
   txtbuf.cursor = #txtbuf.lines[#txtbuf.lines] + 1
   txtbuf.cur_row = #txtbuf.lines

   return txtbuf
end"]
// END RANK codeblock_129

codeblock_130 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local cl = assert(table.clone, \"table.clone must be provided\")

-- #todo rewrite this

function Txtbuf.clone(txtbuf)
   local lb = cl(txtbuf)
   if type(lb.line) == \"table\" then
      lb.line = cl(lb.line)
   elseif type(lb.line) == \"string\" then
      lb:resume()
   end
   return lb
end"]
// END RANK codeblock_130

section_53 -> { header_138 prose_139 codeblock_140 codeblock_141}
{rank=same; header_138 prose_139 codeblock_140 codeblock_141}

header_138 [label="3 : new"]

prose_139 [label="prose"]

codeblock_140 [label="code block 216-242"]

codeblock_141 [label="code block 244-246"]


// END RANK section_53

header_138 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** new"]
// END RANK header_138

prose_139 -> { raw_143}
{rank=same; raw_143}

raw_143 [label="raw"]


// END RANK prose_139

raw_143 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_143

codeblock_140 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function into_codepoints(lines)
   local cp = {}
   for i,v in ipairs(lines) do
      cp[i] = codepoints(v)
   end

   return cp
end

local function new(line)
   local txtbuf = meta(Txtbuf)
   local __l = line or \"\"
   local _lines
   if line then
      _lines = into_codepoints(collect(lines, __l))
   else
      _lines = {{}}
   end
   txtbuf.cursor = line and #_lines[#_lines] + 1 or 1
   txtbuf.cur_row = line and #_lines  or 1
   txtbuf.lines = _lines
   return txtbuf
end

Txtbuf.idEst = new"]
// END RANK codeblock_140

codeblock_141 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]
// END RANK codeblock_141


}
