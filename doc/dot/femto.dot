digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 398"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-193"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 section_5 section_6 section_7}
{rank=same; header_2 prose_3 prose_4 section_5 section_6 section_7}

header_2 [label="1 : Femto"]

prose_3 [label="prose"]

prose_4 [label="prose"]

section_5 [label="section: 9-28"]

section_6 [label="section: 35-193"]

section_7 [label="section: 194-284"]


// END RANK section_1

header_2 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*  Femto"]
// END RANK header_2

prose_3 -> { raw_9}
{rank=same; raw_9}

raw_9 [label="raw"]


// END RANK prose_3

raw_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


I just got orb stood up in the pylon bootloader distribution.
"]
// END RANK raw_9

prose_4 -> { raw_11}
{rank=same; raw_11}

raw_11 [label="raw"]


// END RANK prose_4

raw_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I am excited about this.

"]
// END RANK raw_11

section_5 -> { header_13 prose_14 prose_15 prose_16 codeblock_17 section_18}
{rank=same; header_13 prose_14 prose_15 prose_16 codeblock_17 section_18}

header_13 [label="2 : includes"]

prose_14 [label="prose"]

prose_15 [label="prose"]

prose_16 [label="prose"]

codeblock_17 [label="code block 18-26"]

section_18 [label="section: 29-34"]


// END RANK section_5

header_13 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**  includes"]
// END RANK header_13

prose_14 -> { raw_20}
{rank=same; raw_20}

raw_20 [label="raw"]


// END RANK prose_14

raw_20 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This all goes into global space for now.  Our more sophisticated loader will
handle namespace isolation. Meanwhile we're building a repl, so.
"]
// END RANK raw_20

prose_15 -> { raw_22}
{rank=same; raw_22}

raw_22 [label="raw"]


// END RANK prose_15

raw_22 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
First we load everything that might reasonable expect a stock namespace.
"]
// END RANK raw_22

prose_16 -> { raw_24}
{rank=same; raw_24}

raw_24 [label="raw"]


// END RANK prose_16

raw_24 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
All of these are exceedingly well-behaved.
"]
// END RANK raw_24

codeblock_17 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sql = require \"sqlite\"
L = require \"lpeg\"
lfs = require \"lfs\"
ffi = require \"ffi\"
bit = require \"bit\"
ffi.reflect = require \"reflect\"
uv = require \"luv\""]
// END RANK codeblock_17

section_18 -> { header_27 prose_28}
{rank=same; header_27 prose_28}

header_27 [label="3 : Djikstra Insertion Point"]

prose_28 [label="prose"]


// END RANK section_18

header_27 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Djikstra Insertion Point"]
// END RANK header_27

prose_28 -> { raw_30}
{rank=same; raw_30}

raw_30 [label="raw"]


// END RANK prose_28

raw_30 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Although we're not doing so yet, this is where we will set up Djikstra mode
for participating code.  We then push that up through the layers, and it lands
as close to C level as practical.
"]
// END RANK raw_30

section_6 -> { header_32 prose_33 prose_34 codeblock_35 prose_36 prose_37 codeblock_38 prose_39 prose_40 codeblock_41 prose_42 codeblock_43 codeblock_44 codeblock_45}
{rank=same; header_32 prose_33 prose_34 codeblock_35 prose_36 prose_37 codeblock_38 prose_39 prose_40 codeblock_41 prose_42 codeblock_43 codeblock_44 codeblock_45}

header_32 [label="2 : core"]

prose_33 [label="prose"]

prose_34 [label="prose"]

codeblock_35 [label="code block 42-48"]

prose_36 [label="prose"]

prose_37 [label="prose"]

codeblock_38 [label="code block 55-62"]

prose_39 [label="prose"]

prose_40 [label="prose"]

codeblock_41 [label="code block 69-90"]

prose_42 [label="prose"]

codeblock_43 [label="code block 94-96"]

codeblock_44 [label="code block 98-178"]

codeblock_45 [label="code block 180-191"]


// END RANK section_6

header_32 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** core"]
// END RANK header_32

prose_33 -> { raw_47 prespace_48 literal_49 raw_50}
{rank=same; raw_47 prespace_48 literal_49 raw_50}

raw_47 [label="raw"]

prespace_48 [label="prespace"]

literal_49 [label="literal"]

raw_50 [label="raw"]


// END RANK prose_33

raw_47 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The"]
// END RANK raw_47

prespace_48 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_48

literal_49 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="core"]
// END RANK literal_49

raw_50 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" library is shaping up as a place to keep alterations to the global
namespace and standard library.
"]
// END RANK raw_50

prose_34 -> { raw_55 prespace_56 literal_57 raw_58 prespace_59 literal_60 raw_61}
{rank=same; raw_55 prespace_56 literal_57 raw_58 prespace_59 literal_60 raw_61}

raw_55 [label="raw"]

prespace_56 [label="prespace"]

literal_57 [label="literal"]

raw_58 [label="raw"]

prespace_59 [label="prespace"]

literal_60 [label="literal"]

raw_61 [label="raw"]


// END RANK prose_34

raw_55 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This prelude belongs in"]
// END RANK raw_55

prespace_56 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_56

literal_57 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="pylon"]
// END RANK literal_57

raw_58 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="; it, and"]
// END RANK raw_58

prespace_59 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_59

literal_60 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="core"]
// END RANK literal_60

raw_61 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", will eventually end up there.
"]
// END RANK raw_61

codeblock_35 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local core = require \"core\"
string.cleave, string.litpat = core.cleave, core.litpat
meta = core.meta
getmeta, setmeta = getmetatable, setmetatable
coro = coroutine"]
// END RANK codeblock_35

prose_36 -> { raw_70}
{rank=same; raw_70}

raw_70 [label="raw"]


// END RANK prose_36

raw_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Primitives for terminal manipulation.
"]
// END RANK raw_70

prose_37 -> { raw_72 prespace_73 literal_74 raw_75}
{rank=same; raw_72 prespace_73 literal_74 raw_75}

raw_72 [label="raw"]

prespace_73 [label="prespace"]

literal_74 [label="literal"]

raw_75 [label="raw"]


// END RANK prose_37

raw_72 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Arguably don't belong here."]
// END RANK raw_72

prespace_73 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_73

literal_74 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="watch"]
// END RANK literal_74

raw_75 -> leaf_79
leaf_79  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is unused at present, it will be useful
in Orb relatively soon.
"]
// END RANK raw_75

codeblock_38 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="a = require \"anterm\"
color = require \"color\"
ts = color.ts
c = color.color
watch = require \"watcher\"
"]
// END RANK codeblock_38

prose_39 -> { raw_81 prespace_82 literal_83 raw_84}
{rank=same; raw_81 prespace_82 literal_83 raw_84}

raw_81 [label="raw"]

prespace_82 [label="prespace"]

literal_83 [label="literal"]

raw_84 [label="raw"]


// END RANK prose_39

raw_81 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is all from the"]
// END RANK raw_81

prespace_82 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_82

literal_83 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="luv"]
// END RANK literal_83

raw_84 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" repl example, which has been an excellent launching
off point.  Thanks Tim Caswell!
"]
// END RANK raw_84

prose_40 -> { raw_89}
{rank=same; raw_89}

raw_89 [label="raw"]


// END RANK prose_40

raw_89 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's getting phased out bit by bit.
"]
// END RANK raw_89

codeblock_41 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local usecolors
stdout = \"\"

if uv.guess_handle(1) == \"tty\" then
  stdout = uv.new_tty(1, false)
  usecolors = true
else
  stdout = uv.new_pipe(false)
  uv.pipe_open(utils.stdout, 1)
  usecolors = false
end

if not usecolors then
   ts = tostring
   -- #todo make this properly black and white ts
end

function write(str)
   uv.write(stdout, str)
end"]
// END RANK codeblock_41

prose_42 -> { raw_92}
{rank=same; raw_92}

raw_92 [label="raw"]


// END RANK prose_42

raw_92 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Modeselektor
"]
// END RANK raw_92

codeblock_43 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local modeS = require \"modeselektor\" ()"]
// END RANK codeblock_43

codeblock_44 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function print(...)
  local n = select('#', ...)
  local arguments = {...}
  for i = 1, n do
    arguments[i] = tostring(arguments[i])
  end
  uv.write(stdout, table.concat(arguments, \"\\t\") .. \"\\n\")
end


--  *** tty setup

if uv.guess_handle(0) ~= \"tty\" or
   uv.guess_handle(1) ~= \"tty\" then
  -- Entry point for other consumers!
  error \"stdio must be a tty\"
end

local stdin = uv.new_tty(0, true)


--  *** utilities

local function gatherResults(success, ...)
  local n = select('#', ...)
  return success, { n = n, ... }
end

local function printResults(results)
  for i = 1, results.n do
    results[i] = ts(results[i])
  end
  print(table.concat(results, '\\t'))
end

local buffer = ''

local function evaluateLine(line)
   if string.byte(line) == 17 then -- ^Q
      uv.stop()
      return 0
   end
   local chunk  = buffer .. line
   local f, err = loadstring('return ' .. chunk, 'REPL') -- first we prefix return

   if not f then
      f, err = loadstring(chunk, 'REPL') -- try again without return
   end

   if f then
      buffer = ''
      local success, results = gatherResults(xpcall(f, debug.traceback))

      if success then
      -- successful call
         if results.n > 0 then
            printResults(results)
         end
      else
      -- error
         print(results[1])
      end
   else
      if err:match \"'<eof>'$\" then
         -- Lua expects some more input; stow it away for next time
         buffer = chunk .. '\\n'
         return '...'
      else
         print(err)
         buffer = ''
      end
   end

   return 'ðŸ‘‰  '
end

local function displayPrompt(prompt)
  uv.write(stdout, prompt)
end"]
// END RANK codeblock_44

codeblock_45 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- Deprecated, but useful if I want, y'know, a REPL
local function onread(err, line)
  if err then error(err) end
  if line then
    local prompt = evaluateLine(line)
    displayPrompt(prompt)
  else
    uv.close(stdin)
  end
end"]
// END RANK codeblock_45

section_7 -> { header_97 prose_98 section_99 section_100 section_101 section_102}
{rank=same; header_97 prose_98 section_99 section_100 section_101 section_102}

header_97 [label="2 : Reader"]

prose_98 [label="prose"]

section_99 [label="section: 200-223"]

section_100 [label="section: 224-281"]

section_101 [label="section: 282-284"]

section_102 [label="section: 285-398"]


// END RANK section_7

header_97 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Reader"]
// END RANK header_97

prose_98 -> { raw_104 prespace_105 literal_106 raw_107}
{rank=same; raw_104 prespace_105 literal_106 raw_107}

raw_104 [label="raw"]

prespace_105 [label="prespace"]

literal_106 [label="literal"]

raw_107 [label="raw"]


// END RANK prose_98

raw_104 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The reader takes a stream of data from"]
// END RANK raw_104

prespace_105 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_105

literal_106 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="stdin"]
// END RANK literal_106

raw_107 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", asynchronously, and
processes it into tokens, which stream to the recognizer.

"]
// END RANK raw_107

section_99 -> { header_112 prose_113 prose_114 prose_115 codeblock_116}
{rank=same; header_112 prose_113 prose_114 prose_115 codeblock_116}

header_112 [label="4 : keybuf"]

prose_113 [label="prose"]

prose_114 [label="prose"]

prose_115 [label="prose"]

codeblock_116 [label="code block 211-221"]


// END RANK section_99

header_112 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** keybuf"]
// END RANK header_112

prose_113 -> { raw_118}
{rank=same; raw_118}

raw_118 [label="raw"]


// END RANK prose_113

raw_118 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 Currently the keybuf is a simple array that holds bytes until we have
enough for the lexer.
"]
// END RANK raw_118

prose_114 -> { raw_120}
{rank=same; raw_120}

raw_120 [label="raw"]


// END RANK prose_114

raw_120 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It is cleared and reused, to avoid a glut of allocations and allow the tracer
to follow it.
"]
// END RANK raw_120

prose_115 -> { raw_122 prespace_123 literal_124 raw_125}
{rank=same; raw_122 prespace_123 literal_124 raw_125}

raw_122 [label="raw"]

prespace_123 [label="prespace"]

literal_124 [label="literal"]

raw_125 [label="raw"]


// END RANK prose_115

raw_122 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Soon I'll move the remaining local state into an instance table, to make"]
// END RANK raw_122

prespace_123 -> leaf_127
leaf_127  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_123

literal_124 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label="femto"]
// END RANK literal_124

raw_125 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" re-entrant.
"]
// END RANK raw_125

codeblock_116 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local keybuf = {}
local sub, byte = string.sub, string.byte
local concat = table.concat

local linebuf = { line = \"\",
                  ndx  = 0 }

local max_row, mac_col = uv.tty_get_winsize(stdin)
"]
// END RANK codeblock_116

section_100 -> { header_131 prose_132 codeblock_133 prose_134 codeblock_135}
{rank=same; header_131 prose_132 codeblock_133 prose_134 codeblock_135}

header_131 [label="3 : helper functions"]

prose_132 [label="prose"]

codeblock_133 [label="code block 229-265"]

prose_134 [label="prose"]

codeblock_135 [label="code block 269-279"]


// END RANK section_100

header_131 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** helper functions"]
// END RANK header_131

prose_132 -> { raw_137}
{rank=same; raw_137}

raw_137 [label="raw"]


// END RANK prose_132

raw_137 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Writes will eventually happen in their own library.  Right now we're building
the minimum viable loop.
"]
// END RANK raw_137

codeblock_133 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- device report parsing goes in anterm
--
local function cursor_pos(str)
   local row, col = core.cleave(str, \";\")
   return tonumber(row), tonumber(col)
end

local STATCOL = 81
local STAT_TOP = 1
local STAT_RUN = 2

-- more like jumpwrite at this point but w/e
local function colwrite(str, col, row)
   col = col or STATCOL
   row = row or STAT_TOP
   local dash = a.stash()
             .. a.cursor.hide()
             .. a.jump(row, col)
             .. a.erase.right()
             .. str
             .. a.pop()
             .. a.cursor.show()
   write(dash)
end

local STAT_ICON = \"â—‰\"

local function isnum(char)
   return char >= \"0\" and char <= \"9\"
end

local function isalpha(char)
   return (char >= \"A\" and char <= \"z\")
      or  (char >= \"a\" and char <= \"z\")
end"]
// END RANK codeblock_133

prose_134 -> { raw_140}
{rank=same; raw_140}

raw_140 [label="raw"]


// END RANK prose_134

raw_140 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is a handy dandy mouse printer.
"]
// END RANK raw_140

codeblock_135 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function pr_mouse(m)
   local phrase = a.magenta(m.button) .. \": \"
                     .. a.bright(kind) .. \" \" .. ts(m.shift)
                     .. \" \" .. ts(m.meta)
                     .. \" \" .. ts(m.ctrl) .. \" \" .. ts(m.moving) .. \" \"
                     .. ts(m.scrolling) .. \" \"
                     .. a.cyan(m.col) .. \",\" .. a.cyan(m.row)
   return phrase
end"]
// END RANK codeblock_135

section_101 -> { header_143 prose_144}
{rank=same; header_143 prose_144}

header_143 [label="3 : process_escapes(seq)"]

prose_144 [label="prose"]


// END RANK section_101

header_143 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** process_escapes(seq)"]
// END RANK header_143

prose_144 -> { raw_146}
{rank=same; raw_146}

raw_146 [label="raw"]


// END RANK prose_144

raw_146 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

"]
// END RANK raw_146

section_102 -> { header_148 prose_149 codeblock_150 codeblock_151}
{rank=same; header_148 prose_149 codeblock_150 codeblock_151}

header_148 [label="3 : act"]

prose_149 [label="prose"]

codeblock_150 [label="code block 289-363"]

codeblock_151 [label="code block 365-398"]


// END RANK section_102

header_148 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** act"]
// END RANK header_148

prose_149 -> { raw_153 prespace_154 literal_155 raw_156}
{rank=same; raw_153 prespace_154 literal_155 raw_156}

raw_153 [label="raw"]

prespace_154 [label="prespace"]

literal_155 [label="literal"]

raw_156 [label="raw"]


// END RANK prose_149

raw_153 -> leaf_157
leaf_157  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This will be phased out and replaced with"]
// END RANK raw_153

prespace_154 -> leaf_158
leaf_158  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_154

literal_155 -> leaf_159
leaf_159  [color=Gray,shape=rectangle,fontname=Inconsolata,label="modeselektor"]
// END RANK literal_155

raw_156 -> leaf_160
leaf_160  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_156

codeblock_150 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function mk_paint(label, shade)
   return function(action)
      return shade(label .. \" \" .. action)
   end
end

local act_map = { MOUSE  = pr_mouse,
                  NAV    = mk_paint(\"NAV:\", a.italic),
                  CTRL   = mk_paint(\"CTRL:\", c.field),
                  ALT    = mk_paint(\"ALT:\", a.underscore),
                  INSERT = mk_paint(\"INS:\", c.field)}
                  -- Device reports, function keys...

-- I believe the kids call that 'currying'

local function act(category, action)
   if act_map[category] then
      colwrite(act_map[category](action), STATCOL, STAT_RUN)
   else
      colwrite(category .. \":\" ..action, STATCOL, STAT_RUN)
   end
end

local m_parse, is_mouse = a.mouse.parse_fast, a.mouse.ismousemove
local navigation, is_nav = a.navigation, a.is_nav

local function process_escapes(seq)
   if is_nav(seq) then
      modeS(\"NAV\", navigation[seq] )
   elseif #seq == 1 then
      modeS(\"NAV\", \"ESC\") -- I think of escape as navigation in modal systems
   end
   if is_mouse(seq) then
      local m = m_parse(seq)
      act(\"MOUSE\", m)
   elseif #seq == 2 and byte(sub(seq,2,2)) < 128 then
      -- Meta
      local key = \"M-\" .. sub(seq,2,2)
      modeS(\"ALT\", key)
   end
end

local navigation = a.navigation

local function onseq(err,seq)
   if err then error(err) end
   local head = byte(seq)
   -- ^Q hard coded as quit, for now
   if head == 17 then
      femto.cooked()
      write(a.mouse.track(false))
      uv.stop()
      return 0
   end
   -- Escape sequences
   if head == 27 then
      local color
      if navigation[seq] or #seq == 1 then
         color = c.userdata
      else
         color = a.red
      end
      return process_escapes(seq)
   end
   -- Control sequences
   if head <= 31 and not navigation[seq] then
      local ctrl = \"^\" .. string.char(head + 64)
      return modeS(\"CTRL\", ctrl)
   elseif navigation[seq] then
      return modeS(\"NAV\", navigation[seq])
   end
   return modeS(\"INSERT\", seq)
end"]
// END RANK codeblock_150

codeblock_151 -> leaf_162
leaf_162  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- Get names for as many values as possible
-- into the colorizer
color.allNames()
-- This switches screens and does a wipe,
-- then puts the cursor at 1,1.
write \"\\x1b[?47h\\x1b[2J\\x1b[H\"
print \"an repl, plz reply uwu ðŸ‘€\"
displayPrompt 'ðŸ‘‰  '
-- Crude hack to choose raw mode at runtime
if arg[1] == \"-r\" then
   femto.raw()
   --uv.tty_set_mode(stdin, 2)
   -- mouse mode
   write(a.mouse.track(true))
   uv.read_start(stdin, onseq)
else
   uv.read_start(stdin, onread)
end



-- main loop
local retcode =  uv.run('default')
-- Restore main screen
print '\\x1b[?47l'

if retcode ~= true then
   error(retcode)
end

print(\"kthxbye\")
return retcode"]
// END RANK codeblock_151


}
