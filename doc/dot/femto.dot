digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 174"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-8"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 section_5}
{rank=same; header_2 prose_3 prose_4 section_5}

header_2 [label="1 : Femto"]

prose_3 [label="prose"]

prose_4 [label="prose"]

section_5 [label="section: 9-31"]


// END RANK section_1

header_2 -> leaf_6
leaf_6  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*  Femto"]
// END RANK header_2

prose_3 -> { raw_7}
{rank=same; raw_7}

raw_7 [label="raw"]


// END RANK prose_3

raw_7 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


I just got orb stood up in the pylon bootloader distribution.
"]
// END RANK raw_7

prose_4 -> { raw_9}
{rank=same; raw_9}

raw_9 [label="raw"]


// END RANK prose_4

raw_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I am excited about this.

"]
// END RANK raw_9

section_5 -> { header_11 prose_12 codeblock_13 section_14}
{rank=same; header_11 prose_12 codeblock_13 section_14}

header_11 [label="2 : includes"]

prose_12 [label="prose"]

codeblock_13 [label="code block 14-29"]

section_14 [label="section: 32-174"]


// END RANK section_5

header_11 -> leaf_15
leaf_15  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**  includes"]
// END RANK header_11

prose_12 -> { raw_16}
{rank=same; raw_16}

raw_16 [label="raw"]


// END RANK prose_12

raw_16 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This all goes into global space for now.  Our more sophisticated loader will
handle namespace isolation. Meanwhile we're building a repl, so.
"]
// END RANK raw_16

codeblock_13 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sql = require \"sqlite\"

lfs = require \"lfs\"
ffi = require \"ffi\"

uv = require \"luv\"

L = require \"lpeg\"

a = require \"src/anterm\"

c = require \"src/color\"

watch = require \"src/watcher\""]
// END RANK codeblock_13

section_14 -> { header_19 prose_20 codeblock_21}
{rank=same; header_19 prose_20 codeblock_21}

header_19 [label="4 : utils"]

prose_20 [label="prose"]

codeblock_21 [label="code block 34-174"]


// END RANK section_14

header_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** utils"]
// END RANK header_19

prose_20 -> { raw_23}
{rank=same; raw_23}

raw_23 [label="raw"]


// END RANK prose_20

raw_23 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_23

codeblock_21 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local usecolors
stdout = \"\"

if uv.guess_handle(1) == \"tty\" then
  stdout = uv.new_tty(1, false)
  usecolors = true
else
  stdout = uv.new_pipe(false)
  uv.pipe_open(utils.stdout, 1)
  usecolors = false
end

if not usecolors then
   c.ts = tostring
   -- #todo make this properly black and white ts
end

function print(...)
  local n = select('#', ...)
  local arguments = {...}
  for i = 1, n do
    arguments[i] = tostring(arguments[i])
  end
  uv.write(stdout, table.concat(arguments, \"\\t\") .. \"\\n\")
end

function write(str)
   uv.write(stdout, str)
end


--  *** tty setup

if uv.guess_handle(0) ~= \"tty\" or
   uv.guess_handle(1) ~= \"tty\" then
  -- Entry point for other consumers!
  error \"stdio must be a tty\"
end

local stdin = uv.new_tty(0, true)


--[[

I'll keep this around for a bit, it looks nice


--]]

--  *** utilities

local function gatherResults(success, ...)
  local n = select('#', ...)
  return success, { n = n, ... }
end

local function printResults(results)
  for i = 1, results.n do
    results[i] = c.ts(results[i])
  end
  print(table.concat(results, '\\t'))
end

local buffer = ''

local function evaluateLine(line)
  if line == \"<3\\n\" then
    print(\"I \" .. a.red(\"â™¥\") .. \" you too!\")
    return '>'
  end
  local chunk  = buffer .. line
  local f, err = loadstring('return ' .. chunk, 'REPL') -- first we prefix return

  if not f then
    f, err = loadstring(chunk, 'REPL') -- try again without return
  end

  if f then
    buffer = ''
    local success, results = gatherResults(xpcall(f, debug.traceback))

    if success then
      -- successful call
      if results.n > 0 then
        printResults(results)
      end
    else
      -- error
      print(results[1])
    end
  else

    if err:match \"'<eof>'$\" then
      -- Lua expects some more input; stow it away for next time
      buffer = chunk .. '\\n'
      return '...'
    else
      print(err)
      buffer = ''
    end
  end

  return 'ðŸ‘‰ '
end

local function displayPrompt(prompt)
  uv.write(stdout, prompt)
end

local function onread(err, line)
  if err then error(err) end
  if line then
    local prompt = evaluateLine(line)
    displayPrompt(prompt)
  else
    uv.close(stdin)
  end
end

-- Alternate screen

coroutine.wrap(function()
   -- This switches screens and does a wipe,
   -- then puts the cursor at 1,1.
   write '\\27[?47h\\27[2J\\27[H'
   print \"an repl, plz reply uwu ðŸ‘€\"
   displayPrompt 'ðŸ‘‰ '
   uv.read_start(stdin, onread)
end)()

uv.run('default')

-- Restore

print '\\27[?47l'

print(\"kthxbye\")
return 0"]
// END RANK codeblock_21


}
