digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 375"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-154"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 section_5 section_6}
{rank=same; header_2 prose_3 prose_4 section_5 section_6}

header_2 [label="1 : Femto"]

prose_3 [label="prose"]

prose_4 [label="prose"]

section_5 [label="section: 9-36"]

section_6 [label="section: 155-223"]


// END RANK section_1

header_2 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*  Femto"]
// END RANK header_2

prose_3 -> { raw_8}
{rank=same; raw_8}

raw_8 [label="raw"]


// END RANK prose_3

raw_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


I just got orb stood up in the pylon bootloader distribution.
"]
// END RANK raw_8

prose_4 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


// END RANK prose_4

raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I am excited about this.

"]
// END RANK raw_10

section_5 -> { header_12 prose_13 codeblock_14 section_15}
{rank=same; header_12 prose_13 codeblock_14 section_15}

header_12 [label="2 : includes"]

prose_13 [label="prose"]

codeblock_14 [label="code block 14-34"]

section_15 [label="section: 37-154"]


// END RANK section_5

header_12 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**  includes"]
// END RANK header_12

prose_13 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


// END RANK prose_13

raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This all goes into global space for now.  Our more sophisticated loader will
handle namespace isolation. Meanwhile we're building a repl, so.
"]
// END RANK raw_17

codeblock_14 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sql = require \"sqlite\"

lfs = require \"lfs\"
ffi = require \"ffi\"

ffi.reflect = require \"reflect\"

uv = require \"luv\"

L = require \"lpeg\"

a = require \"anterm\"

c = require \"color\"
ts = c.ts

core = require \"core\"

watch = require \"watcher\""]
// END RANK codeblock_14

section_15 -> { header_20 prose_21 codeblock_22}
{rank=same; header_20 prose_21 codeblock_22}

header_20 [label="4 : utils"]

prose_21 [label="prose"]

codeblock_22 [label="code block 39-152"]


// END RANK section_15

header_20 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** utils"]
// END RANK header_20

prose_21 -> { raw_24}
{rank=same; raw_24}

raw_24 [label="raw"]


// END RANK prose_21

raw_24 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_24

codeblock_22 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local usecolors
stdout = \"\"

if uv.guess_handle(1) == \"tty\" then
  stdout = uv.new_tty(1, false)
  usecolors = true
else
  stdout = uv.new_pipe(false)
  uv.pipe_open(utils.stdout, 1)
  usecolors = false
end

if not usecolors then
   c.ts = tostring
   -- #todo make this properly black and white ts
end

function print(...)
  local n = select('#', ...)
  local arguments = {...}
  for i = 1, n do
    arguments[i] = tostring(arguments[i])
  end
  uv.write(stdout, table.concat(arguments, \"\\t\") .. \"\\n\")
end

function write(str)
   uv.write(stdout, str)
end


--  *** tty setup

if uv.guess_handle(0) ~= \"tty\" or
   uv.guess_handle(1) ~= \"tty\" then
  -- Entry point for other consumers!
  error \"stdio must be a tty\"
end

local stdin = uv.new_tty(0, true)


--  *** utilities

local function gatherResults(success, ...)
  local n = select('#', ...)
  return success, { n = n, ... }
end

local function printResults(results)
  for i = 1, results.n do
    results[i] = c.ts(results[i])
  end
  print(table.concat(results, '\\t'))
end

local buffer = ''

local function evaluateLine(line)
   if string.byte(line) == 17 then -- ^Q
      uv.stop()
      return 0
   end
   local chunk  = buffer .. line
   local f, err = loadstring('return ' .. chunk, 'REPL') -- first we prefix return

   if not f then
      f, err = loadstring(chunk, 'REPL') -- try again without return
   end

   if f then
      buffer = ''
      local success, results = gatherResults(xpcall(f, debug.traceback))

      if success then
      -- successful call
         if results.n > 0 then
            printResults(results)
         end
      else
      -- error
         print(results[1])
      end
   else
      if err:match \"'<eof>'$\" then
         -- Lua expects some more input; stow it away for next time
         buffer = chunk .. '\\n'
         return '...'
      else
         print(err)
         buffer = ''
      end
   end

   return 'ðŸ‘‰  '
end

local function displayPrompt(prompt)
  uv.write(stdout, prompt)
end

-- Deprecated, but useful if I want, y'know, a REPL
local function onread(err, line)
  if err then error(err) end
  if line then
    local prompt = evaluateLine(line)
    displayPrompt(prompt)
  else
    uv.close(stdin)
  end
end"]
// END RANK codeblock_22

section_6 -> { header_27 prose_28 section_29 section_30 section_31}
{rank=same; header_27 prose_28 section_29 section_30 section_31}

header_27 [label="2 : Reader"]

prose_28 [label="prose"]

section_29 [label="section: 161-184"]

section_30 [label="section: 185-223"]

section_31 [label="section: 224-375"]


// END RANK section_6

header_27 -> leaf_32
leaf_32  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Reader"]
// END RANK header_27

prose_28 -> { raw_33 prespace_34 literal_35 raw_36}
{rank=same; raw_33 prespace_34 literal_35 raw_36}

raw_33 [label="raw"]

prespace_34 [label="prespace"]

literal_35 [label="literal"]

raw_36 [label="raw"]


// END RANK prose_28

raw_33 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The reader takes a stream of data from"]
// END RANK raw_33

prespace_34 -> leaf_38
leaf_38  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_34

literal_35 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="stdin"]
// END RANK literal_35

raw_36 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", asynchronously, and
processes it into tokens, which stream to the recognizer.

"]
// END RANK raw_36

section_29 -> { header_41 prose_42 prose_43 prose_44 codeblock_45}
{rank=same; header_41 prose_42 prose_43 prose_44 codeblock_45}

header_41 [label="4 : keybuf"]

prose_42 [label="prose"]

prose_43 [label="prose"]

prose_44 [label="prose"]

codeblock_45 [label="code block 172-182"]


// END RANK section_29

header_41 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** keybuf"]
// END RANK header_41

prose_42 -> { raw_47}
{rank=same; raw_47}

raw_47 [label="raw"]


// END RANK prose_42

raw_47 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 Currently the keybuf is a simple array that holds bytes until we have
enough for the lexer.
"]
// END RANK raw_47

prose_43 -> { raw_49}
{rank=same; raw_49}

raw_49 [label="raw"]


// END RANK prose_43

raw_49 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It is cleared and reused, to avoid a glut of allocations and allow the tracer
to follow it.
"]
// END RANK raw_49

prose_44 -> { raw_51 prespace_52 literal_53 raw_54}
{rank=same; raw_51 prespace_52 literal_53 raw_54}

raw_51 [label="raw"]

prespace_52 [label="prespace"]

literal_53 [label="literal"]

raw_54 [label="raw"]


// END RANK prose_44

raw_51 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Soon I'll move the remaining local state into an instance table, to make"]
// END RANK raw_51

prespace_52 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_52

literal_53 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="femto"]
// END RANK literal_53

raw_54 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" re-entrant.
"]
// END RANK raw_54

codeblock_45 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local keybuf = {}
local sub, byte = string.sub, string.byte
local concat = table.concat

local linebuf = { line = \"\",
                  ndx  = 0 }

local max_row, mac_col = uv.tty_get_winsize(stdin)
"]
// END RANK codeblock_45

section_30 -> { header_60 prose_61 codeblock_62}
{rank=same; header_60 prose_61 codeblock_62}

header_60 [label="3 : helper functions"]

prose_61 [label="prose"]

codeblock_62 [label="code block 190-221"]


// END RANK section_30

header_60 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** helper functions"]
// END RANK header_60

prose_61 -> { raw_64}
{rank=same; raw_64}

raw_64 [label="raw"]


// END RANK prose_61

raw_64 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Writes will eventually happen in their own library.  Right now we're building
the minimum viable loop.
"]
// END RANK raw_64

codeblock_62 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- This will be called parse_digits and be substantially more complex.
--
local function cursor_pos(str)
   local row, col = core.cleave(str, \";\")
   return tonumber(row), tonumber(col)
end

-- more like jumpwrite at this point but w/
local function colwrite(str, col, row)
   col = col or 81
   row = row or 1
   local dash = a.stash()
             .. a.jump(row, col)
             .. a.erase.right()
             .. str
             .. a.pop()

   write(dash)
end

local STAT_ICON = \"â—‰\"

local function isnum(char)
   return char >= \"0\" and char <= \"9\"
end

local function isalpha(char)
   return (char >= \"A\" and char <= \"z\")
      or  (char >= \"a\" and char <= \"z\")
end"]
// END RANK codeblock_62

section_31 -> { header_67 prose_68 prose_69 prose_70 prose_71 prose_72 codeblock_73 codeblock_74}
{rank=same; header_67 prose_68 prose_69 prose_70 prose_71 prose_72 codeblock_73 codeblock_74}

header_67 [label="3 : process_escapes(seq)"]

prose_68 [label="prose"]

prose_69 [label="prose"]

prose_70 [label="prose"]

prose_71 [label="prose"]

prose_72 [label="prose"]

codeblock_73 [label="code block 239-343"]

codeblock_74 [label="code block 345-375"]


// END RANK section_31

header_67 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** process_escapes(seq)"]
// END RANK header_67

prose_68 -> { raw_76 prespace_77 literal_78 raw_79}
{rank=same; raw_76 prespace_77 literal_78 raw_79}

raw_76 [label="raw"]

prespace_77 [label="prespace"]

literal_78 [label="literal"]

raw_79 [label="raw"]


// END RANK prose_68

raw_76 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

After flailing about and writing what was no doubt a good parser for
individual byte sequences, I discovered that"]
// END RANK raw_76

prespace_77 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_77

literal_78 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="uv"]
// END RANK literal_78

raw_79 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" gives them to me a seq at a
time.
"]
// END RANK raw_79

prose_69 -> { raw_84}
{rank=same; raw_84}

raw_84 [label="raw"]


// END RANK prose_69

raw_84 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Because of course it does.
"]
// END RANK raw_84

prose_70 -> { raw_86 prespace_87 literal_88 raw_89}
{rank=same; raw_86 prespace_87 literal_88 raw_89}

raw_86 [label="raw"]

prespace_87 [label="prespace"]

literal_88 [label="literal"]

raw_89 [label="raw"]


// END RANK prose_70

raw_86 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
So we're just going to make this a jump table that translates"]
// END RANK raw_86

prespace_87 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_87

literal_88 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="xterm"]
// END RANK literal_88

raw_89 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" directly
to english.
"]
// END RANK raw_89

prose_71 -> { raw_94 prespace_95 literal_96 raw_97}
{rank=same; raw_94 prespace_95 literal_96 raw_97}

raw_94 [label="raw"]

prespace_95 [label="prespace"]

literal_96 [label="literal"]

raw_97 [label="raw"]


// END RANK prose_71

raw_94 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'm also going to switch to"]
// END RANK raw_94

prespace_95 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_95

literal_96 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="x1b"]
// END RANK literal_96

raw_97 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", which is more visually distinguished.
"]
// END RANK raw_97

prose_72 -> { raw_102}
{rank=same; raw_102}

raw_102 [label="raw"]


// END RANK prose_72

raw_102 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To avoid extraneous quoting, we define the tokens as keys, and their escape
strings as values."]
// END RANK raw_102

codeblock_73 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
--

local __navigation = { UP       = \"\\x1b[A\",
                        DOWN     = \"\\x1b[B\",
                        RIGHT    = \"\\x1b[C\",
                        LEFT     = \"\\x1b[D\",
                        SHIFT_UP = \"\\x1b[1;2A\",
                        SHIFT_DOWN = \"\\x1b[1;2B\",
                        SHIFT_RIGHT = \"\\x1b[1;2C\",
                        SHIFT_LEFT  = \"\\x1b[1;2D\",
                        HYPER_UP    = \"\\x1b[5~\",
                        HYPER_DOWN  = \"\\x1b[6~\",
                        HYPER_RIGHT = \"\\x1b[F\",
                        HYPER_LEFT  = \"\\x1b[H\",
                        ALT_UP    = \"\\x1b\\x1b[A\",
                        ALT_DOWN  = \"\\x1b\\x1b[B\",
                        ALT_RIGHT = \"\\x1bf\", -- heh
                        ALT_LEFT  = \"\\x1bb\",
                        SHIFT_ALT_UP = \"\\x1b[1;10A\",
                        SHIFT_ALT_DOWN = \"\\x1b[1;10B\",
                        SHIFT_ALT_RIGHT = \"\\x1b[1;10C\",
                        SHIFT_ALT_LEFT  = \"\\x1b[1;10A\",
                        SHIFT_TAB  = \"\\x1b[Z\",
                        ALT_TAB    = \"\\x1b\\t\",
                        NEWLINE    = \"\\n\",
                        RETURN     = \"\\r\",
                        TAB        = \"\\t\"
                     }

local __control = {  ZERO = \"\\0\",
                   }

local navigation = {}
local control = {}

--  Then invert

for k,v in pairs(__navigation) do
   navigation[v] = k
end
for k,v in pairs(__control) do
   control[v] = k
end

__navigation, __control = nil, nil

local function act(action, category)
   colwrite(a.yellow(action), 81, 2)
end

local function litprint(seq)
   local phrase = \"\"
   for i = 1, #seq do
      phrase = phrase .. \":\" .. byte(seq, i)
   end
   return phrase
end

local function process_escapes(seq)
   if navigation[seq] then
      act(navigation[seq], \"navigation\")
   elseif #seq == 1 then
      act(\"ESC\", \"control\")
   else
      act(litprint(seq))
   end
end

local function onseq(err,seq)
   if err then error(err) end
   local head = byte(seq)
   -- ^Q hard coded as quit, for now
   if head == 17 then
      femto.cooked()
      uv.stop()
      return 0
   end
   -- Escape sequences
   if head == 27 then
      local color
      if navigation[seq] or #seq == 1 then
         color = a.magenta
      else
         color = a.red
      end
      colwrite(color(STAT_ICON) .. \" : \" .. c.ts(seq))
      return process_escapes(seq)
   end
   -- Control sequences
   if head <= 31 and not navigation[seq] then
      local ctrl = \"^\" .. string.char(head + 64)
      colwrite(a.blue(STAT_ICON) .. \" : \" .. ctrl)
      return act(ts(seq), \"control\")
   elseif navigation[seq] then
      colwrite(a.green(STAT_ICON))
      return act(seq, \"navigation\")
   end

   colwrite(a.green(STAT_ICON) .. \" : \" .. seq)
   return act(seq, \"entry\")

end"]
// END RANK codeblock_73

codeblock_74 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- Get names for as many values as possible
-- into the colorizer
c.allNames()
-- This switches screens and does a wipe,
-- then puts the cursor at 1,1.
write '\\x1b[?47h\\x1b[2J\\x1b[H'
print \"an repl, plz reply uwu ðŸ‘€\"
displayPrompt 'ðŸ‘‰  '
-- Crude hack to choose raw mode at runtime
if arg[1] == \"-r\" then
   femto.raw()
   uv.read_start(stdin, onseq)
else
   uv.read_start(stdin, onread)
end



-- main loop
local retcode = uv.run('default')
-- Restore main screen
print '\\x1b[?47l'

if retcode ~= 0 then
   error(retcode)
end

print(\"kthxbye\")
return retcode"]
// END RANK codeblock_74


}
