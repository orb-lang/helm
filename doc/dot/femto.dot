digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 308"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-212"]


// END RANK doc_0

section_1 -> { header_2 prose_3 section_4 section_5 section_6 section_7}
{rank=same; header_2 prose_3 section_4 section_5 section_6 section_7}

header_2 [label="1 : Femto"]

prose_3 [label="prose"]

section_4 [label="section: 6-25"]

section_5 [label="section: 32-111"]

section_6 [label="section: 125-212"]

section_7 [label="section: 213-217"]


// END RANK section_1

header_2 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*  Femto"]
// END RANK header_2

prose_3 -> { raw_9}
{rank=same; raw_9}

raw_9 [label="raw"]


// END RANK prose_3

raw_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="



"]
// END RANK raw_9

section_4 -> { header_11 prose_12 prose_13 prose_14 codeblock_15 section_16}
{rank=same; header_11 prose_12 prose_13 prose_14 codeblock_15 section_16}

header_11 [label="2 : includes"]

prose_12 [label="prose"]

prose_13 [label="prose"]

prose_14 [label="prose"]

codeblock_15 [label="code block 15-23"]

section_16 [label="section: 26-31"]


// END RANK section_4

header_11 -> leaf_17
leaf_17  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**  includes"]
// END RANK header_11

prose_12 -> { raw_18}
{rank=same; raw_18}

raw_18 [label="raw"]


// END RANK prose_12

raw_18 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This all goes into global space for now.  Our more sophisticated loader will
handle namespace isolation. Meanwhile we're building a repl, so.
"]
// END RANK raw_18

prose_13 -> { raw_20}
{rank=same; raw_20}

raw_20 [label="raw"]


// END RANK prose_13

raw_20 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
First we load everything that might reasonable expect a stock namespace.
"]
// END RANK raw_20

prose_14 -> { raw_22}
{rank=same; raw_22}

raw_22 [label="raw"]


// END RANK prose_14

raw_22 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
All of these are exceedingly well-behaved.
"]
// END RANK raw_22

codeblock_15 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sql = require \"sqlayer\"
L = require \"lpeg\"
lfs = require \"lfs\"
ffi = require \"ffi\"
bit = require \"bit\"
ffi.reflect = require \"reflect\"
uv = require \"luv\""]
// END RANK codeblock_15

section_16 -> { header_25 prose_26}
{rank=same; header_25 prose_26}

header_25 [label="3 : Djikstra Insertion Point"]

prose_26 [label="prose"]


// END RANK section_16

header_25 -> leaf_27
leaf_27  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Djikstra Insertion Point"]
// END RANK header_25

prose_26 -> { raw_28}
{rank=same; raw_28}

raw_28 [label="raw"]


// END RANK prose_26

raw_28 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Although we're not doing so yet, this is where we will set up Djikstra mode
for participating code.  We then push that up through the layers, and it lands
as close to C level as practical.
"]
// END RANK raw_28

section_5 -> { header_30 prose_31 prose_32 codeblock_33 prose_34 prose_35 codeblock_36 prose_37 prose_38 codeblock_39 codeblock_40 section_41}
{rank=same; header_30 prose_31 prose_32 codeblock_33 prose_34 prose_35 codeblock_36 prose_37 prose_38 codeblock_39 codeblock_40 section_41}

header_30 [label="2 : core"]

prose_31 [label="prose"]

prose_32 [label="prose"]

codeblock_33 [label="code block 39-56"]

prose_34 [label="prose"]

prose_35 [label="prose"]

codeblock_36 [label="code block 63-70"]

prose_37 [label="prose"]

prose_38 [label="prose"]

codeblock_39 [label="code block 77-98"]

codeblock_40 [label="code block 100-109"]

section_41 [label="section: 112-124"]


// END RANK section_5

header_30 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** core"]
// END RANK header_30

prose_31 -> { raw_43 prespace_44 literal_45 raw_46}
{rank=same; raw_43 prespace_44 literal_45 raw_46}

raw_43 [label="raw"]

prespace_44 [label="prespace"]

literal_45 [label="literal"]

raw_46 [label="raw"]


// END RANK prose_31

raw_43 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The"]
// END RANK raw_43

prespace_44 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_44

literal_45 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="core"]
// END RANK literal_45

raw_46 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" library is shaping up as a place to keep alterations to the global
namespace and standard library.
"]
// END RANK raw_46

prose_32 -> { raw_51 prespace_52 literal_53 raw_54 prespace_55 literal_56 raw_57}
{rank=same; raw_51 prespace_52 literal_53 raw_54 prespace_55 literal_56 raw_57}

raw_51 [label="raw"]

prespace_52 [label="prespace"]

literal_53 [label="literal"]

raw_54 [label="raw"]

prespace_55 [label="prespace"]

literal_56 [label="literal"]

raw_57 [label="raw"]


// END RANK prose_32

raw_51 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This prelude belongs in"]
// END RANK raw_51

prespace_52 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_52

literal_53 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label="pylon"]
// END RANK literal_53

raw_54 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="; it, and"]
// END RANK raw_54

prespace_55 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_55

literal_56 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="core"]
// END RANK literal_56

raw_57 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", will eventually end up there.
"]
// END RANK raw_57

codeblock_33 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="core = require \"core\"
string.cleave, string.litpat = core.cleave, core.litpat
string.utf8 = core.utf8
string.codepoints = core.codepoints
table.splice = core.splice
table.clone = core.clone
table.arrayof = core.arrayof
table.select = core.select
table.reverse = core.reverse
utf8 = core.utf8
codepoints = core.codepoints
_G.meta = core.meta
getmeta, setmeta = getmetatable, setmetatable
coro = coroutine

local concat = table.concat"]
// END RANK codeblock_33

prose_34 -> { raw_66}
{rank=same; raw_66}

raw_66 [label="raw"]


// END RANK prose_34

raw_66 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Primitives for terminal manipulation.
"]
// END RANK raw_66

prose_35 -> { raw_68 prespace_69 literal_70 raw_71}
{rank=same; raw_68 prespace_69 literal_70 raw_71}

raw_68 [label="raw"]

prespace_69 [label="prespace"]

literal_70 [label="literal"]

raw_71 [label="raw"]


// END RANK prose_35

raw_68 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Arguably don't belong here."]
// END RANK raw_68

prespace_69 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_69

literal_70 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label="watch"]
// END RANK literal_70

raw_71 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is unused at present, it will be useful
in Orb relatively soon.
"]
// END RANK raw_71

codeblock_36 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label="a = require \"anterm\"
color = require \"color\"
ts = color.ts
c = color.color
watch = require \"watcher\"
"]
// END RANK codeblock_36

prose_37 -> { raw_77 prespace_78 literal_79 raw_80}
{rank=same; raw_77 prespace_78 literal_79 raw_80}

raw_77 [label="raw"]

prespace_78 [label="prespace"]

literal_79 [label="literal"]

raw_80 [label="raw"]


// END RANK prose_37

raw_77 -> leaf_81
leaf_81  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is all from the"]
// END RANK raw_77

prespace_78 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_78

literal_79 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label="luv"]
// END RANK literal_79

raw_80 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" repl example, which has been an excellent launching
off point.  Thanks Tim Caswell!
"]
// END RANK raw_80

prose_38 -> { raw_85}
{rank=same; raw_85}

raw_85 [label="raw"]


// END RANK prose_38

raw_85 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's getting phased out bit by bit.
"]
// END RANK raw_85

codeblock_39 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local usecolors
stdout = \"\"

if uv.guess_handle(1) == \"tty\" then
  stdout = uv.new_tty(1, false)
  usecolors = true
else
  stdout = uv.new_pipe(false)
  uv.pipe_open(utils.stdout, 1)
  usecolors = false
end

if not usecolors then
   ts = tostring
   -- #todo make this properly black and white ts
end

function write(str)
   uv.write(stdout, str)
end"]
// END RANK codeblock_39

codeblock_40 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function print(...)
  local n = select('#', ...)
  local arguments = {...}
  for i = 1, n do
    arguments[i] = tostring(arguments[i])
  end
  uv.write(stdout, concat(arguments, \"\\t\") .. \"\\n\")
end"]
// END RANK codeblock_40

section_41 -> { header_89 prose_90 codeblock_91}
{rank=same; header_89 prose_90 codeblock_91}

header_89 [label="3 : tty setup"]

prose_90 [label="prose"]

codeblock_91 [label="code block 114-122"]


// END RANK section_41

header_89 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** tty setup"]
// END RANK header_89

prose_90 -> { raw_93}
{rank=same; raw_93}

raw_93 [label="raw"]


// END RANK prose_90

raw_93 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_93

codeblock_91 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="if uv.guess_handle(0) ~= \"tty\" or
   uv.guess_handle(1) ~= \"tty\" then
  -- Entry point for other consumers!
  error \"stdio must be a tty\"
end

local stdin = uv.new_tty(0, true)"]
// END RANK codeblock_91

section_6 -> { header_96 prose_97 codeblock_98 codeblock_99 codeblock_100}
{rank=same; header_96 prose_97 codeblock_98 codeblock_99 codeblock_100}

header_96 [label="2 : Modeselektor"]

prose_97 [label="prose"]

codeblock_98 [label="code block 127-133"]

codeblock_99 [label="code block 135-197"]

codeblock_100 [label="code block 199-210"]


// END RANK section_6

header_96 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Modeselektor"]
// END RANK header_96

prose_97 -> { raw_102}
{rank=same; raw_102}

raw_102 [label="raw"]


// END RANK prose_97

raw_102 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_102

codeblock_98 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- This switches screens and does a wipe,
-- then puts the cursor at 1,1.
write \"\\x1b[?47h\\x1b[2J\\x1b[H\"
modeS = require \"modeselektor\" ()
modeS.max_row, modeS.max_col = uv.tty_get_winsize(stdin)"]
// END RANK codeblock_98

codeblock_99 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
--  *** utilities

local function gatherResults(success, ...)
  local n = select('#', ...)
  return success, { n = n, ... }
end

local function printResults(results)
  for i = 1, results.n do
    results[i] = ts(results[i])
  end
  print(concat(results, '\\t'))
end

local buffer = ''

local function evaluateLine(line)
   if string.byte(line) == 17 then -- ^Q
      -- move this to modeselektor asap
      modeS.hist.conn:close()
      uv.stop()
      return 0
   end
   local chunk  = buffer .. line
   local f, err = loadstring('return ' .. chunk, 'REPL') -- first we prefix return

   if not f then
      f, err = loadstring(chunk, 'REPL') -- try again without return
   end

   if f then
      buffer = ''
      local success, results = gatherResults(xpcall(f, debug.traceback))

      if success then
      -- successful call
         if results.n > 0 then
            printResults(results)
         end
      else
      -- error
         print(results[1])
      end
   else
      if err:match \"'<eof>'$\" then
         -- Lua expects some more input; stow it away for next time
         buffer = chunk .. '\\n'
         return '...'
      else
         print(err)
         buffer = ''
      end
   end

   return '👉  '
end

local function displayPrompt(prompt)
  uv.write(stdout, prompt)
end"]
// END RANK codeblock_99

codeblock_100 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- Deprecated, but useful if I want, y'know, a REPL
local function onread(err, line)
  if err then error(err) end
  if line then
    local prompt = evaluateLine(line)
    displayPrompt(prompt)
  else
    uv.close(stdin)
  end
end"]
// END RANK codeblock_100

section_7 -> { header_107 prose_108 section_109}
{rank=same; header_107 prose_108 section_109}

header_107 [label="2 : Reader"]

prose_108 [label="prose"]

section_109 [label="section: 218-308"]


// END RANK section_7

header_107 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Reader"]
// END RANK header_107

prose_108 -> { raw_111 prespace_112 literal_113 raw_114 prespace_115 literal_116 raw_117}
{rank=same; raw_111 prespace_112 literal_113 raw_114 prespace_115 literal_116 raw_117}

raw_111 [label="raw"]

prespace_112 [label="prespace"]

literal_113 [label="literal"]

raw_114 [label="raw"]

prespace_115 [label="prespace"]

literal_116 [label="literal"]

raw_117 [label="raw"]


// END RANK prose_108

raw_111 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The reader takes a stream of data from"]
// END RANK raw_111

prespace_112 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_112

literal_113 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label="stdin"]
// END RANK literal_113

raw_114 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", asynchronously, and
processes it into tokens, which stream to the"]
// END RANK raw_114

prespace_115 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_115

literal_116 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label="modeselektor"]
// END RANK literal_116

raw_117 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
// END RANK raw_117

section_109 -> { header_125 prose_126 codeblock_127 codeblock_128}
{rank=same; header_125 prose_126 codeblock_127 codeblock_128}

header_125 [label="3 : process_escapes(seq)"]

prose_126 [label="prose"]

codeblock_127 [label="code block 220-275"]

codeblock_128 [label="code block 277-308"]


// END RANK section_109

header_125 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** process_escapes(seq)"]
// END RANK header_125

prose_126 -> { raw_130}
{rank=same; raw_130}

raw_130 [label="raw"]


// END RANK prose_126

raw_130 -> leaf_131
leaf_131  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_130

codeblock_127 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local byte, sub = string.byte, string.sub
local m_parse, is_mouse = a.mouse.parse_fast, a.mouse.ismousemove
local navigation, is_nav = a.navigation, a.is_nav

local function process_escapes(seq)
   if is_nav(seq) then
      return modeS(\"NAV\", navigation[seq] )
   elseif #seq == 1 then
      modeS(\"NAV\", \"ESC\") -- I think of escape as navigation in modal systems
   end
   if is_mouse(seq) then
      local m = m_parse(seq)
      return modeS(\"MOUSE\", m)
   elseif #seq == 2 and byte(sub(seq,2,2)) < 128 then
      -- Meta
      local key = \"M-\" .. sub(seq,2,2)
      return modeS(\"ALT\", key)
   else
      return modeS(\"NYI\", seq)
   end
end

local navigation = a.navigation

local function onseq(err,seq)
   if err then error(err) end
   local head = byte(seq)
   -- ^Q hard coded as quit, for now
   if head == 17 then
      femto.cooked()
      write(a.mouse.track(false))
      uv.stop()
      return 0
   end
   -- Escape sequences
   if head == 27 then
      return process_escapes(seq)
   end
   -- Control sequences
   if head <= 31 and not navigation[seq] then
      local ctrl = \"^\" .. string.char(head + 64)
      return modeS(\"CTRL\", ctrl)
   elseif navigation[seq] then
      return modeS(\"NAV\", navigation[seq])
   end
   -- Printables
   if head > 31 and head < 127 then
      return modeS(\"ASCII\", seq)
   else
      -- wchars go here
      return modeS(\"NYI\", seq)
   end
end"]
// END RANK codeblock_127

codeblock_128 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- Get names for as many values as possible
-- into the colorizer
color.allNames()

print \"an repl, plz reply uwu 👀\"
displayPrompt '👉  '
-- Crude hack to choose raw mode at runtime
if arg[1] == \"-r\" then
   femto.raw()
   --uv.tty_set_mode(stdin, 2)
   -- mouse mode
   write(a.mouse.track(true))
   uv.read_start(stdin, onseq)
else
   uv.read_start(stdin, onread)
end



-- main loop
local retcode =  uv.run('default')
-- Restore main screen
print '\\x1b[?47l'

if retcode ~= true then
   error(retcode)
end

print(\"kthxbye\")
return retcode"]
// END RANK codeblock_128


}
