digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 317"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-196"]


// END RANK doc_0

section_1 -> { header_2 prose_3 section_4 section_5 section_6}
{rank=same; header_2 prose_3 section_4 section_5 section_6}

header_2 [label="1 : Femto"]

prose_3 [label="prose"]

section_4 [label="section: 6-25"]

section_5 [label="section: 32-196"]

section_6 [label="section: 197-224"]


// END RANK section_1

header_2 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*  Femto"]
// END RANK header_2

prose_3 -> { raw_8}
{rank=same; raw_8}

raw_8 [label="raw"]


// END RANK prose_3

raw_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="



"]
// END RANK raw_8

section_4 -> { header_10 prose_11 prose_12 prose_13 codeblock_14 section_15}
{rank=same; header_10 prose_11 prose_12 prose_13 codeblock_14 section_15}

header_10 [label="2 : includes"]

prose_11 [label="prose"]

prose_12 [label="prose"]

prose_13 [label="prose"]

codeblock_14 [label="code block 15-23"]

section_15 [label="section: 26-31"]


// END RANK section_4

header_10 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**  includes"]
// END RANK header_10

prose_11 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


// END RANK prose_11

raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This all goes into global space for now.  Our more sophisticated loader will
handle namespace isolation. Meanwhile we're building a repl, so.
"]
// END RANK raw_17

prose_12 -> { raw_19}
{rank=same; raw_19}

raw_19 [label="raw"]


// END RANK prose_12

raw_19 -> leaf_20
leaf_20  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
First we load everything that might reasonable expect a stock namespace.
"]
// END RANK raw_19

prose_13 -> { raw_21}
{rank=same; raw_21}

raw_21 [label="raw"]


// END RANK prose_13

raw_21 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
All of these are exceedingly well-behaved.
"]
// END RANK raw_21

codeblock_14 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sql = require \"sqlite\"
L = require \"lpeg\"
lfs = require \"lfs\"
ffi = require \"ffi\"
bit = require \"bit\"
ffi.reflect = require \"reflect\"
uv = require \"luv\""]
// END RANK codeblock_14

section_15 -> { header_24 prose_25}
{rank=same; header_24 prose_25}

header_24 [label="3 : Djikstra Insertion Point"]

prose_25 [label="prose"]


// END RANK section_15

header_24 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Djikstra Insertion Point"]
// END RANK header_24

prose_25 -> { raw_27}
{rank=same; raw_27}

raw_27 [label="raw"]


// END RANK prose_25

raw_27 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Although we're not doing so yet, this is where we will set up Djikstra mode
for participating code.  We then push that up through the layers, and it lands
as close to C level as practical.
"]
// END RANK raw_27

section_5 -> { header_29 prose_30 prose_31 codeblock_32 prose_33 prose_34 codeblock_35 prose_36 prose_37 codeblock_38 prose_39 codeblock_40 codeblock_41 codeblock_42}
{rank=same; header_29 prose_30 prose_31 codeblock_32 prose_33 prose_34 codeblock_35 prose_36 prose_37 codeblock_38 prose_39 codeblock_40 codeblock_41 codeblock_42}

header_29 [label="2 : core"]

prose_30 [label="prose"]

prose_31 [label="prose"]

codeblock_32 [label="code block 39-50"]

prose_33 [label="prose"]

prose_34 [label="prose"]

codeblock_35 [label="code block 57-65"]

prose_36 [label="prose"]

prose_37 [label="prose"]

codeblock_38 [label="code block 72-93"]

prose_39 [label="prose"]

codeblock_40 [label="code block 97-99"]

codeblock_41 [label="code block 101-181"]

codeblock_42 [label="code block 183-194"]


// END RANK section_5

header_29 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** core"]
// END RANK header_29

prose_30 -> { raw_44 prespace_45 literal_46 raw_47}
{rank=same; raw_44 prespace_45 literal_46 raw_47}

raw_44 [label="raw"]

prespace_45 [label="prespace"]

literal_46 [label="literal"]

raw_47 [label="raw"]


// END RANK prose_30

raw_44 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The"]
// END RANK raw_44

prespace_45 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_45

literal_46 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="core"]
// END RANK literal_46

raw_47 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" library is shaping up as a place to keep alterations to the global
namespace and standard library.
"]
// END RANK raw_47

prose_31 -> { raw_52 prespace_53 literal_54 raw_55 prespace_56 literal_57 raw_58}
{rank=same; raw_52 prespace_53 literal_54 raw_55 prespace_56 literal_57 raw_58}

raw_52 [label="raw"]

prespace_53 [label="prespace"]

literal_54 [label="literal"]

raw_55 [label="raw"]

prespace_56 [label="prespace"]

literal_57 [label="literal"]

raw_58 [label="raw"]


// END RANK prose_31

raw_52 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This prelude belongs in"]
// END RANK raw_52

prespace_53 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_53

literal_54 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="pylon"]
// END RANK literal_54

raw_55 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="; it, and"]
// END RANK raw_55

prespace_56 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_56

literal_57 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="core"]
// END RANK literal_57

raw_58 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", will eventually end up there.
"]
// END RANK raw_58

codeblock_32 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local core = require \"core\"
string.cleave, string.litpat = core.cleave, core.litpat
string.utf8 = core.utf8
string.codepoints = core.codepoints
table.splice = core.splice
utf8 = core.utf8
codepoints = core.codepoints
meta = core.meta
getmeta, setmeta = getmetatable, setmetatable
coro = coroutine"]
// END RANK codeblock_32

prose_33 -> { raw_67}
{rank=same; raw_67}

raw_67 [label="raw"]


// END RANK prose_33

raw_67 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Primitives for terminal manipulation.
"]
// END RANK raw_67

prose_34 -> { raw_69 prespace_70 literal_71 raw_72}
{rank=same; raw_69 prespace_70 literal_71 raw_72}

raw_69 [label="raw"]

prespace_70 [label="prespace"]

literal_71 [label="literal"]

raw_72 [label="raw"]


// END RANK prose_34

raw_69 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Arguably don't belong here."]
// END RANK raw_69

prespace_70 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_70

literal_71 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="watch"]
// END RANK literal_71

raw_72 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is unused at present, it will be useful
in Orb relatively soon.
"]
// END RANK raw_72

codeblock_35 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local concat = table.concat
a = require \"anterm\"
color = require \"color\"
ts = color.ts
c = color.color
watch = require \"watcher\"
"]
// END RANK codeblock_35

prose_36 -> { raw_78 prespace_79 literal_80 raw_81}
{rank=same; raw_78 prespace_79 literal_80 raw_81}

raw_78 [label="raw"]

prespace_79 [label="prespace"]

literal_80 [label="literal"]

raw_81 [label="raw"]


// END RANK prose_36

raw_78 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is all from the"]
// END RANK raw_78

prespace_79 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_79

literal_80 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="luv"]
// END RANK literal_80

raw_81 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" repl example, which has been an excellent launching
off point.  Thanks Tim Caswell!
"]
// END RANK raw_81

prose_37 -> { raw_86}
{rank=same; raw_86}

raw_86 [label="raw"]


// END RANK prose_37

raw_86 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's getting phased out bit by bit.
"]
// END RANK raw_86

codeblock_38 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local usecolors
stdout = \"\"

if uv.guess_handle(1) == \"tty\" then
  stdout = uv.new_tty(1, false)
  usecolors = true
else
  stdout = uv.new_pipe(false)
  uv.pipe_open(utils.stdout, 1)
  usecolors = false
end

if not usecolors then
   ts = tostring
   -- #todo make this properly black and white ts
end

function write(str)
   uv.write(stdout, str)
end"]
// END RANK codeblock_38

prose_39 -> { raw_89}
{rank=same; raw_89}

raw_89 [label="raw"]


// END RANK prose_39

raw_89 -> leaf_90
leaf_90  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Modeselektor
"]
// END RANK raw_89

codeblock_40 -> leaf_91
leaf_91  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local modeS = require \"modeselektor\" ()"]
// END RANK codeblock_40

codeblock_41 -> leaf_92
leaf_92  [color=Gray,shape=rectangle,fontname=Inconsolata,label="function print(...)
  local n = select('#', ...)
  local arguments = {...}
  for i = 1, n do
    arguments[i] = tostring(arguments[i])
  end
  uv.write(stdout, concat(arguments, \"\\t\") .. \"\\n\")
end


--  *** tty setup

if uv.guess_handle(0) ~= \"tty\" or
   uv.guess_handle(1) ~= \"tty\" then
  -- Entry point for other consumers!
  error \"stdio must be a tty\"
end

local stdin = uv.new_tty(0, true)


--  *** utilities

local function gatherResults(success, ...)
  local n = select('#', ...)
  return success, { n = n, ... }
end

local function printResults(results)
  for i = 1, results.n do
    results[i] = ts(results[i])
  end
  print(concat(results, '\\t'))
end

local buffer = ''

local function evaluateLine(line)
   if string.byte(line) == 17 then -- ^Q
      uv.stop()
      return 0
   end
   local chunk  = buffer .. line
   local f, err = loadstring('return ' .. chunk, 'REPL') -- first we prefix return

   if not f then
      f, err = loadstring(chunk, 'REPL') -- try again without return
   end

   if f then
      buffer = ''
      local success, results = gatherResults(xpcall(f, debug.traceback))

      if success then
      -- successful call
         if results.n > 0 then
            printResults(results)
         end
      else
      -- error
         print(results[1])
      end
   else
      if err:match \"'<eof>'$\" then
         -- Lua expects some more input; stow it away for next time
         buffer = chunk .. '\\n'
         return '...'
      else
         print(err)
         buffer = ''
      end
   end

   return '👉  '
end

local function displayPrompt(prompt)
  uv.write(stdout, prompt)
end"]
// END RANK codeblock_41

codeblock_42 -> leaf_93
leaf_93  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- Deprecated, but useful if I want, y'know, a REPL
local function onread(err, line)
  if err then error(err) end
  if line then
    local prompt = evaluateLine(line)
    displayPrompt(prompt)
  else
    uv.close(stdin)
  end
end"]
// END RANK codeblock_42

section_6 -> { header_94 prose_95 section_96 section_97}
{rank=same; header_94 prose_95 section_96 section_97}

header_94 [label="2 : Reader"]

prose_95 [label="prose"]

section_96 [label="section: 203-224"]

section_97 [label="section: 225-317"]


// END RANK section_6

header_94 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Reader"]
// END RANK header_94

prose_95 -> { raw_99 prespace_100 literal_101 raw_102}
{rank=same; raw_99 prespace_100 literal_101 raw_102}

raw_99 [label="raw"]

prespace_100 [label="prespace"]

literal_101 [label="literal"]

raw_102 [label="raw"]


// END RANK prose_95

raw_99 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The reader takes a stream of data from"]
// END RANK raw_99

prespace_100 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_100

literal_101 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="stdin"]
// END RANK literal_101

raw_102 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", asynchronously, and
processes it into tokens, which stream to the recognizer.

"]
// END RANK raw_102

section_96 -> { header_107 prose_108 prose_109 prose_110 codeblock_111}
{rank=same; header_107 prose_108 prose_109 prose_110 codeblock_111}

header_107 [label="4 : keybuf"]

prose_108 [label="prose"]

prose_109 [label="prose"]

prose_110 [label="prose"]

codeblock_111 [label="code block 214-222"]


// END RANK section_96

header_107 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** keybuf"]
// END RANK header_107

prose_108 -> { raw_113}
{rank=same; raw_113}

raw_113 [label="raw"]


// END RANK prose_108

raw_113 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 Currently the keybuf is a simple array that holds bytes until we have
enough for the lexer.
"]
// END RANK raw_113

prose_109 -> { raw_115}
{rank=same; raw_115}

raw_115 [label="raw"]


// END RANK prose_109

raw_115 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It is cleared and reused, to avoid a glut of allocations and allow the tracer
to follow it.
"]
// END RANK raw_115

prose_110 -> { raw_117 prespace_118 literal_119 raw_120}
{rank=same; raw_117 prespace_118 literal_119 raw_120}

raw_117 [label="raw"]

prespace_118 [label="prespace"]

literal_119 [label="literal"]

raw_120 [label="raw"]


// END RANK prose_110

raw_117 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Soon I'll move the remaining local state into an instance table, to make"]
// END RANK raw_117

prespace_118 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_118

literal_119 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label="femto"]
// END RANK literal_119

raw_120 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" re-entrant.
"]
// END RANK raw_120

codeblock_111 -> leaf_125
leaf_125  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local keybuf = {}
local sub, byte = string.sub, string.byte
local concat = table.concat


local max_row, mac_col = uv.tty_get_winsize(stdin)
"]
// END RANK codeblock_111

section_97 -> { header_126 prose_127 codeblock_128 codeblock_129}
{rank=same; header_126 prose_127 codeblock_128 codeblock_129}

header_126 [label="3 : process_escapes(seq)"]

prose_127 [label="prose"]

codeblock_128 [label="code block 227-282"]

codeblock_129 [label="code block 284-317"]


// END RANK section_97

header_126 -> leaf_130
leaf_130  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** process_escapes(seq)"]
// END RANK header_126

prose_127 -> { raw_131}
{rank=same; raw_131}

raw_131 [label="raw"]


// END RANK prose_127

raw_131 -> leaf_132
leaf_132  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_131

codeblock_128 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

local m_parse, is_mouse = a.mouse.parse_fast, a.mouse.ismousemove
local navigation, is_nav = a.navigation, a.is_nav

local function process_escapes(seq)
   if is_nav(seq) then
      return modeS(\"NAV\", navigation[seq] )
   elseif #seq == 1 then
      modeS(\"NAV\", \"ESC\") -- I think of escape as navigation in modal systems
   end
   if is_mouse(seq) then
      local m = m_parse(seq)
      return modeS(\"MOUSE\", m)
   elseif #seq == 2 and byte(sub(seq,2,2)) < 128 then
      -- Meta
      local key = \"M-\" .. sub(seq,2,2)
      return modeS(\"ALT\", key)
   else
      return modeS(\"NYI\", seq)
   end
end

local navigation = a.navigation

local function onseq(err,seq)
   if err then error(err) end
   local head = byte(seq)
   -- ^Q hard coded as quit, for now
   if head == 17 then
      femto.cooked()
      write(a.mouse.track(false))
      uv.stop()
      return 0
   end
   -- Escape sequences
   if head == 27 then
      return process_escapes(seq)
   end
   -- Control sequences
   if head <= 31 and not navigation[seq] then
      local ctrl = \"^\" .. string.char(head + 64)
      return modeS(\"CTRL\", ctrl)
   elseif navigation[seq] then
      return modeS(\"NAV\", navigation[seq])
   end
   -- Printables
   if head > 31 and head < 127 then
      return modeS(\"INSERT\", seq)
   else
      -- wchars go here
      return modeS(\"NYI\", seq)
   end
end"]
// END RANK codeblock_128

codeblock_129 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- Get names for as many values as possible
-- into the colorizer
color.allNames()
-- This switches screens and does a wipe,
-- then puts the cursor at 1,1.
write \"\\x1b[?47h\\x1b[2J\\x1b[H\"
print \"an repl, plz reply uwu 👀\"
displayPrompt '👉  '
-- Crude hack to choose raw mode at runtime
if arg[1] == \"-r\" then
   femto.raw()
   --uv.tty_set_mode(stdin, 2)
   -- mouse mode
   write(a.mouse.track(true))
   uv.read_start(stdin, onseq)
else
   uv.read_start(stdin, onread)
end



-- main loop
local retcode =  uv.run('default')
-- Restore main screen
print '\\x1b[?47l'

if retcode ~= true then
   error(retcode)
end

print(\"kthxbye\")
return retcode"]
// END RANK codeblock_129


}
