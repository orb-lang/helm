digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 480"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-183"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 section_5 section_6 section_7}
{rank=same; header_2 prose_3 prose_4 section_5 section_6 section_7}

header_2 [label="1 : Femto"]

prose_3 [label="prose"]

prose_4 [label="prose"]

section_5 [label="section: 9-28"]

section_6 [label="section: 35-183"]

section_7 [label="section: 184-253"]


// END RANK section_1

header_2 -> leaf_8
leaf_8  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*  Femto"]
// END RANK header_2

prose_3 -> { raw_9}
{rank=same; raw_9}

raw_9 [label="raw"]


// END RANK prose_3

raw_9 -> leaf_10
leaf_10  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


I just got orb stood up in the pylon bootloader distribution.
"]
// END RANK raw_9

prose_4 -> { raw_11}
{rank=same; raw_11}

raw_11 [label="raw"]


// END RANK prose_4

raw_11 -> leaf_12
leaf_12  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I am excited about this.

"]
// END RANK raw_11

section_5 -> { header_13 prose_14 prose_15 prose_16 codeblock_17 section_18}
{rank=same; header_13 prose_14 prose_15 prose_16 codeblock_17 section_18}

header_13 [label="2 : includes"]

prose_14 [label="prose"]

prose_15 [label="prose"]

prose_16 [label="prose"]

codeblock_17 [label="code block 18-26"]

section_18 [label="section: 29-34"]


// END RANK section_5

header_13 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**  includes"]
// END RANK header_13

prose_14 -> { raw_20}
{rank=same; raw_20}

raw_20 [label="raw"]


// END RANK prose_14

raw_20 -> leaf_21
leaf_21  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This all goes into global space for now.  Our more sophisticated loader will
handle namespace isolation. Meanwhile we're building a repl, so.
"]
// END RANK raw_20

prose_15 -> { raw_22}
{rank=same; raw_22}

raw_22 [label="raw"]


// END RANK prose_15

raw_22 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
First we load everything that might reasonable expect a stock namespace.
"]
// END RANK raw_22

prose_16 -> { raw_24}
{rank=same; raw_24}

raw_24 [label="raw"]


// END RANK prose_16

raw_24 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
All of these are exceedingly well-behaved.
"]
// END RANK raw_24

codeblock_17 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sql = require \"sqlite\"
L = require \"lpeg\"
lfs = require \"lfs\"
ffi = require \"ffi\"
bit = require \"bit\"
ffi.reflect = require \"reflect\"
uv = require \"luv\""]
// END RANK codeblock_17

section_18 -> { header_27 prose_28}
{rank=same; header_27 prose_28}

header_27 [label="3 : Djikstra Insertion Point"]

prose_28 [label="prose"]


// END RANK section_18

header_27 -> leaf_29
leaf_29  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** Djikstra Insertion Point"]
// END RANK header_27

prose_28 -> { raw_30}
{rank=same; raw_30}

raw_30 [label="raw"]


// END RANK prose_28

raw_30 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Although we're not doing so yet, this is where we will set up Djikstra mode
for participating code.  We then push that up through the layers, and it lands
as close to C level as practical.
"]
// END RANK raw_30

section_6 -> { header_32 prose_33 prose_34 codeblock_35 prose_36 prose_37 codeblock_38 prose_39 prose_40 codeblock_41 codeblock_42}
{rank=same; header_32 prose_33 prose_34 codeblock_35 prose_36 prose_37 codeblock_38 prose_39 prose_40 codeblock_41 codeblock_42}

header_32 [label="2 : core"]

prose_33 [label="prose"]

prose_34 [label="prose"]

codeblock_35 [label="code block 42-48"]

prose_36 [label="prose"]

prose_37 [label="prose"]

codeblock_38 [label="code block 55-60"]

prose_39 [label="prose"]

prose_40 [label="prose"]

codeblock_41 [label="code block 67-168"]

codeblock_42 [label="code block 170-181"]


// END RANK section_6

header_32 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** core"]
// END RANK header_32

prose_33 -> { raw_44 prespace_45 literal_46 raw_47}
{rank=same; raw_44 prespace_45 literal_46 raw_47}

raw_44 [label="raw"]

prespace_45 [label="prespace"]

literal_46 [label="literal"]

raw_47 [label="raw"]


// END RANK prose_33

raw_44 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The"]
// END RANK raw_44

prespace_45 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_45

literal_46 -> leaf_50
leaf_50  [color=Gray,shape=rectangle,fontname=Inconsolata,label="core"]
// END RANK literal_46

raw_47 -> leaf_51
leaf_51  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" library is shaping up as a place to keep alterations to the global
namespace and standard library.
"]
// END RANK raw_47

prose_34 -> { raw_52 prespace_53 literal_54 raw_55 prespace_56 literal_57 raw_58}
{rank=same; raw_52 prespace_53 literal_54 raw_55 prespace_56 literal_57 raw_58}

raw_52 [label="raw"]

prespace_53 [label="prespace"]

literal_54 [label="literal"]

raw_55 [label="raw"]

prespace_56 [label="prespace"]

literal_57 [label="literal"]

raw_58 [label="raw"]


// END RANK prose_34

raw_52 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This prelude belongs in"]
// END RANK raw_52

prespace_53 -> leaf_60
leaf_60  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_53

literal_54 -> leaf_61
leaf_61  [color=Gray,shape=rectangle,fontname=Inconsolata,label="pylon"]
// END RANK literal_54

raw_55 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="; it, and"]
// END RANK raw_55

prespace_56 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_56

literal_57 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label="core"]
// END RANK literal_57

raw_58 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", will eventually end up there.
"]
// END RANK raw_58

codeblock_35 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local core = require \"core\"
string.cleave, string.litpat = core.cleave, core.litpat
meta = core.meta
getmeta, setmeta = getmetatable, setmetatable
coro = coroutine"]
// END RANK codeblock_35

prose_36 -> { raw_67}
{rank=same; raw_67}

raw_67 [label="raw"]


// END RANK prose_36

raw_67 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Primitives for terminal manipulation.
"]
// END RANK raw_67

prose_37 -> { raw_69 prespace_70 literal_71 raw_72}
{rank=same; raw_69 prespace_70 literal_71 raw_72}

raw_69 [label="raw"]

prespace_70 [label="prespace"]

literal_71 [label="literal"]

raw_72 [label="raw"]


// END RANK prose_37

raw_69 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Arguably don't belong here."]
// END RANK raw_69

prespace_70 -> leaf_74
leaf_74  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_70

literal_71 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="watch"]
// END RANK literal_71

raw_72 -> leaf_76
leaf_76  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is unused at present, it will be useful
in Orb relatively soon.
"]
// END RANK raw_72

codeblock_38 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="a = require \"anterm\"
c = require \"color\"
ts = c.ts
watch = require \"watcher\""]
// END RANK codeblock_38

prose_39 -> { raw_78 prespace_79 literal_80 raw_81}
{rank=same; raw_78 prespace_79 literal_80 raw_81}

raw_78 [label="raw"]

prespace_79 [label="prespace"]

literal_80 [label="literal"]

raw_81 [label="raw"]


// END RANK prose_39

raw_78 -> leaf_82
leaf_82  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
This is all from the"]
// END RANK raw_78

prespace_79 -> leaf_83
leaf_83  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_79

literal_80 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="luv"]
// END RANK literal_80

raw_81 -> leaf_85
leaf_85  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" repl example, which has been an excellent launching
off point.  Thanks Tim Caswell!
"]
// END RANK raw_81

prose_40 -> { raw_86}
{rank=same; raw_86}

raw_86 [label="raw"]


// END RANK prose_40

raw_86 -> leaf_87
leaf_87  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's getting phased out bit by bit.
"]
// END RANK raw_86

codeblock_41 -> leaf_88
leaf_88  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local usecolors
stdout = \"\"

if uv.guess_handle(1) == \"tty\" then
  stdout = uv.new_tty(1, false)
  usecolors = true
else
  stdout = uv.new_pipe(false)
  uv.pipe_open(utils.stdout, 1)
  usecolors = false
end

if not usecolors then
   c.ts = tostring
   -- #todo make this properly black and white ts
end

function print(...)
  local n = select('#', ...)
  local arguments = {...}
  for i = 1, n do
    arguments[i] = tostring(arguments[i])
  end
  uv.write(stdout, table.concat(arguments, \"\\t\") .. \"\\n\")
end

function write(str)
   uv.write(stdout, str)
end


--  *** tty setup

if uv.guess_handle(0) ~= \"tty\" or
   uv.guess_handle(1) ~= \"tty\" then
  -- Entry point for other consumers!
  error \"stdio must be a tty\"
end

local stdin = uv.new_tty(0, true)


--  *** utilities

local function gatherResults(success, ...)
  local n = select('#', ...)
  return success, { n = n, ... }
end

local function printResults(results)
  for i = 1, results.n do
    results[i] = c.ts(results[i])
  end
  print(table.concat(results, '\\t'))
end

local buffer = ''

local function evaluateLine(line)
   if string.byte(line) == 17 then -- ^Q
      uv.stop()
      return 0
   end
   local chunk  = buffer .. line
   local f, err = loadstring('return ' .. chunk, 'REPL') -- first we prefix return

   if not f then
      f, err = loadstring(chunk, 'REPL') -- try again without return
   end

   if f then
      buffer = ''
      local success, results = gatherResults(xpcall(f, debug.traceback))

      if success then
      -- successful call
         if results.n > 0 then
            printResults(results)
         end
      else
      -- error
         print(results[1])
      end
   else
      if err:match \"'<eof>'$\" then
         -- Lua expects some more input; stow it away for next time
         buffer = chunk .. '\\n'
         return '...'
      else
         print(err)
         buffer = ''
      end
   end

   return 'ðŸ‘‰  '
end

local function displayPrompt(prompt)
  uv.write(stdout, prompt)
end"]
// END RANK codeblock_41

codeblock_42 -> leaf_89
leaf_89  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- Deprecated, but useful if I want, y'know, a REPL
local function onread(err, line)
  if err then error(err) end
  if line then
    local prompt = evaluateLine(line)
    displayPrompt(prompt)
  else
    uv.close(stdin)
  end
end"]
// END RANK codeblock_42

section_7 -> { header_90 prose_91 section_92 section_93 section_94}
{rank=same; header_90 prose_91 section_92 section_93 section_94}

header_90 [label="2 : Reader"]

prose_91 [label="prose"]

section_92 [label="section: 190-213"]

section_93 [label="section: 214-253"]

section_94 [label="section: 254-480"]


// END RANK section_7

header_90 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Reader"]
// END RANK header_90

prose_91 -> { raw_96 prespace_97 literal_98 raw_99}
{rank=same; raw_96 prespace_97 literal_98 raw_99}

raw_96 [label="raw"]

prespace_97 [label="prespace"]

literal_98 [label="literal"]

raw_99 [label="raw"]


// END RANK prose_91

raw_96 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

The reader takes a stream of data from"]
// END RANK raw_96

prespace_97 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_97

literal_98 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label="stdin"]
// END RANK literal_98

raw_99 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", asynchronously, and
processes it into tokens, which stream to the recognizer.

"]
// END RANK raw_99

section_92 -> { header_104 prose_105 prose_106 prose_107 codeblock_108}
{rank=same; header_104 prose_105 prose_106 prose_107 codeblock_108}

header_104 [label="4 : keybuf"]

prose_105 [label="prose"]

prose_106 [label="prose"]

prose_107 [label="prose"]

codeblock_108 [label="code block 201-211"]


// END RANK section_92

header_104 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** keybuf"]
// END RANK header_104

prose_105 -> { raw_110}
{rank=same; raw_110}

raw_110 [label="raw"]


// END RANK prose_105

raw_110 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

 Currently the keybuf is a simple array that holds bytes until we have
enough for the lexer.
"]
// END RANK raw_110

prose_106 -> { raw_112}
{rank=same; raw_112}

raw_112 [label="raw"]


// END RANK prose_106

raw_112 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It is cleared and reused, to avoid a glut of allocations and allow the tracer
to follow it.
"]
// END RANK raw_112

prose_107 -> { raw_114 prespace_115 literal_116 raw_117}
{rank=same; raw_114 prespace_115 literal_116 raw_117}

raw_114 [label="raw"]

prespace_115 [label="prespace"]

literal_116 [label="literal"]

raw_117 [label="raw"]


// END RANK prose_107

raw_114 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Soon I'll move the remaining local state into an instance table, to make"]
// END RANK raw_114

prespace_115 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label=""]
// END RANK prespace_115

literal_116 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label="femto"]
// END RANK literal_116

raw_117 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" re-entrant.
"]
// END RANK raw_117

codeblock_108 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local keybuf = {}
local sub, byte = string.sub, string.byte
local concat = table.concat

local linebuf = { line = \"\",
                  ndx  = 0 }

local max_row, mac_col = uv.tty_get_winsize(stdin)
"]
// END RANK codeblock_108

section_93 -> { header_123 prose_124 codeblock_125}
{rank=same; header_123 prose_124 codeblock_125}

header_123 [label="3 : helper functions"]

prose_124 [label="prose"]

codeblock_125 [label="code block 219-251"]


// END RANK section_93

header_123 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** helper functions"]
// END RANK header_123

prose_124 -> { raw_127}
{rank=same; raw_127}

raw_127 [label="raw"]


// END RANK prose_124

raw_127 -> leaf_128
leaf_128  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

Writes will eventually happen in their own library.  Right now we're building
the minimum viable loop.
"]
// END RANK raw_127

codeblock_125 -> leaf_129
leaf_129  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- This will be called parse_digits and be substantially more complex.
--
local function cursor_pos(str)
   local row, col = core.cleave(str, \";\")
   return tonumber(row), tonumber(col)
end

-- more like jumpwrite at this point but w/e
local function colwrite(str, col, row)
   col = col or 81
   row = row or 1
   local dash = a.stash()
             .. a.cursor.hide()
             .. a.jump(row, col)
             .. a.erase.right()
             .. str
             .. a.pop()
             .. a.cursor.show()
   write(dash)
end

local STAT_ICON = \"â—‰\"

local function isnum(char)
   return char >= \"0\" and char <= \"9\"
end

local function isalpha(char)
   return (char >= \"A\" and char <= \"z\")
      or  (char >= \"a\" and char <= \"z\")
end"]
// END RANK codeblock_125

section_94 -> { header_130 prose_131 prose_132 prose_133 prose_134 prose_135 codeblock_136 prose_137 codeblock_138 prose_139 prose_140 prose_141 codeblock_142 codeblock_143}
{rank=same; header_130 prose_131 prose_132 prose_133 prose_134 prose_135 codeblock_136 prose_137 codeblock_138 prose_139 prose_140 prose_141 codeblock_142 codeblock_143}

header_130 [label="3 : process_escapes(seq)"]

prose_131 [label="prose"]

prose_132 [label="prose"]

prose_133 [label="prose"]

prose_134 [label="prose"]

prose_135 [label="prose"]

codeblock_136 [label="code block 269-301"]

prose_137 [label="prose"]

codeblock_138 [label="code block 305-311"]

prose_139 [label="prose"]

prose_140 [label="prose"]

prose_141 [label="prose"]

codeblock_142 [label="code block 321-445"]

codeblock_143 [label="code block 447-480"]


// END RANK section_94

header_130 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** process_escapes(seq)"]
// END RANK header_130

prose_131 -> { raw_145 prespace_146 literal_147 raw_148}
{rank=same; raw_145 prespace_146 literal_147 raw_148}

raw_145 [label="raw"]

prespace_146 [label="prespace"]

literal_147 [label="literal"]

raw_148 [label="raw"]


// END RANK prose_131

raw_145 -> leaf_149
leaf_149  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

After flailing about and writing what was no doubt a good parser for
individual byte sequences, I discovered that"]
// END RANK raw_145

prespace_146 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_146

literal_147 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label="uv"]
// END RANK literal_147

raw_148 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" gives them to me a seq at a
time.
"]
// END RANK raw_148

prose_132 -> { raw_153}
{rank=same; raw_153}

raw_153 [label="raw"]


// END RANK prose_132

raw_153 -> leaf_154
leaf_154  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Because of course it does.
"]
// END RANK raw_153

prose_133 -> { raw_155 prespace_156 literal_157 raw_158}
{rank=same; raw_155 prespace_156 literal_157 raw_158}

raw_155 [label="raw"]

prespace_156 [label="prespace"]

literal_157 [label="literal"]

raw_158 [label="raw"]


// END RANK prose_133

raw_155 -> leaf_159
leaf_159  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
So we're just going to make this a jump table that translates"]
// END RANK raw_155

prespace_156 -> leaf_160
leaf_160  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_156

literal_157 -> leaf_161
leaf_161  [color=Gray,shape=rectangle,fontname=Inconsolata,label="xterm"]
// END RANK literal_157

raw_158 -> leaf_162
leaf_162  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" directly
to english.
"]
// END RANK raw_158

prose_134 -> { raw_163 prespace_164 literal_165 raw_166}
{rank=same; raw_163 prespace_164 literal_165 raw_166}

raw_163 [label="raw"]

prespace_164 [label="prespace"]

literal_165 [label="literal"]

raw_166 [label="raw"]


// END RANK prose_134

raw_163 -> leaf_167
leaf_167  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'm also going to switch to"]
// END RANK raw_163

prespace_164 -> leaf_168
leaf_168  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
// END RANK prespace_164

literal_165 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label="x1b"]
// END RANK literal_165

raw_166 -> leaf_170
leaf_170  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", which is more visually distinguished.
"]
// END RANK raw_166

prose_135 -> { raw_171}
{rank=same; raw_171}

raw_171 [label="raw"]


// END RANK prose_135

raw_171 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
To avoid extraneous quoting, we define the tokens as keys, and their escape
strings as values."]
// END RANK raw_171

codeblock_136 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
--

local __navigation = {  UP       = \"\\x1b[A\",
                        DOWN     = \"\\x1b[B\",
                        RIGHT    = \"\\x1b[C\",
                        LEFT     = \"\\x1b[D\",
                        SHIFT_UP = \"\\x1b[1;2A\",
                        SHIFT_DOWN = \"\\x1b[1;2B\",
                        SHIFT_RIGHT = \"\\x1b[1;2C\",
                        SHIFT_LEFT  = \"\\x1b[1;2D\",
                        HYPER_UP    = \"\\x1b[5~\",
                        HYPER_DOWN  = \"\\x1b[6~\",
                        HYPER_RIGHT = \"\\x1b[F\",
                        HYPER_LEFT  = \"\\x1b[H\",
                        ALT_UP    = \"\\x1b\\x1b[A\",
                        ALT_DOWN  = \"\\x1b\\x1b[B\",
                        ALT_RIGHT = \"\\x1bf\", -- heh
                        ALT_LEFT  = \"\\x1bb\",
                        SHIFT_ALT_UP = \"\\x1b[1;10A\",
                        SHIFT_ALT_DOWN = \"\\x1b[1;10B\",
                        SHIFT_ALT_RIGHT = \"\\x1b[1;10C\",
                        SHIFT_ALT_LEFT  = \"\\x1b[1;10D\",
                        SHIFT_TAB  = \"\\x1b[Z\",
                        ALT_TAB    = \"\\x1b\\t\",
                        NEWLINE    = \"\\n\",
                        RETURN     = \"\\r\",
                        TAB        = \"\\t\",
                        BACKSPACE  = \"\\127\",
                        DELETE     = \"\\x1b[3~\",
                     }"]
// END RANK codeblock_136

prose_137 -> { raw_174}
{rank=same; raw_174}

raw_174 [label="raw"]


// END RANK prose_137

raw_174 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's possible to coerce a terminal into sending these, apparently:
"]
// END RANK raw_174

codeblock_138 -> leaf_176
leaf_176  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local __alt_nav = {  UP       = \"\\x1bOA\",
                     DOWN     = \"\\x1bOB\",
                     RIGHT    = \"\\x1bOC\",
                     LEFT     = \"\\x1bOD\",
                  }"]
// END RANK codeblock_138

prose_139 -> { raw_177}
{rank=same; raw_177}

raw_177 [label="raw"]


// END RANK prose_139

raw_177 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I don't know why, and if anyone does, please let me know.
"]
// END RANK raw_177

prose_140 -> { raw_179}
{rank=same; raw_179}

raw_179 [label="raw"]


// END RANK prose_140

raw_179 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I'm fairly sure those are the only valid meanings for the above escape
strings.
"]
// END RANK raw_179

prose_141 -> { raw_181}
{rank=same; raw_181}

raw_181 [label="raw"]


// END RANK prose_141

raw_181 -> leaf_182
leaf_182  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Annnnyway, printable control characters:
"]
// END RANK raw_181

codeblock_142 -> leaf_183
leaf_183  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local __control = { HT = \"\\t\",
                    LF = \"\\n\",
                    CR = \"\\r\" }

local navigation = {}
local control = {}

--  Then invert

for k,v in pairs(__navigation) do
   navigation[v] = k
end
for k,v in pairs(__alt_nav) do
   navigation[v] = k
end

__navigation, __alt_nav = nil, nil, nil

function pr_mouse(m)
   local phrase = a.magenta(m.button) .. \": \"
                     .. a.bright(kind) .. \" \" .. ts(m.shift)
                     .. \" \" .. ts(m.meta)
                     .. \" \" .. ts(m.ctrl) .. \" \" .. ts(m.moving) .. \" \"
                     .. ts(m.scrolling) .. \" \"
                     .. a.cyan(m.col) .. \",\" .. a.cyan(m.row)
   return phrase
end

local act_map = { MOUSE = pr_mouse}

local function act(category, action)
   if act_map[category] then
      colwrite(act_map[category](action), 81, 2)
   else
      colwrite(action, 81, 2)
   end
end

local function litprint(seq)
   local phrase = \"\"
   for i = 1, #seq do
      phrase = phrase .. \":\" .. byte(seq, i)
   end
   return phrase
end

local function ismousemove(seq)
   if sub(seq, 1, 3) == \"\\x1b[M\" then
      return true
   end
end

local buttons = {[0] =\"MB0\", \"MB1\", \"MB2\", \"MBNONE\"}

local rshift = bit.rshift
local function process_escapes(seq)
   if navigation[seq] then
      act(\"NAV\", navigation[seq] )
   elseif #seq == 1 then
      act(\"CTRL\", \"ESC\")
   end
   if ismousemove(seq) then
      local kind, col, row = byte(seq,4), byte(seq, 5), byte(seq, 6)
      kind = rshift(kind, 32)
      local m = {row = rshift(row, 5), col = rshift(col, 5)}
      -- Get button
      m.button = buttons[kind % 4]
      -- Get modifiers
      kind = rshift(kind, 2)
      m.shift = kind % 2 == 1
      kind = rshift(kind, 1)
      m.meta = kind % 2 == 1
      kind = rshift(kind, 1)
      m.ctrl = kind % 2 == 1
      kind = rshift(kind, 1)
      m.moving = kind % 2 == 1
      -- we skip a bit that seems to just mirror the motion
      -- it may be pixel level, I can't tell and idk
      m.scrolling = kind == 2


      act(\"MOUSE\", m)
   elseif #seq == 2 and byte(seq[2]) < 128 then

      -- Meta
   end
end

local function onseq(err,seq)
   if err then error(err) end
   local head = byte(seq)
   -- ^Q hard coded as quit, for now
   if head == 17 then
      femto.cooked()
      write(a.mouse.track(false))
      uv.stop()
      return 0
   end
   -- Escape sequences
   if head == 27 then
      local color
      if navigation[seq] or #seq == 1 then
         color = a.magenta
      else
         color = a.red
      end
      colwrite(color(STAT_ICON) .. \" : \" .. c.ts(seq))
      return process_escapes(seq)
   end
   -- Control sequences
   if head <= 31 and not navigation[seq] then
      local ctrl = \"^\" .. string.char(head + 64)
      colwrite(a.blue(STAT_ICON) .. \" : \" .. ctrl)
      return act(\"CTRL\", ctrl)
   elseif navigation[seq] then
      colwrite(a.green(STAT_ICON))
      return act(\"NAV\", navigation[seq])
   end

   colwrite(a.green(STAT_ICON) .. \" : \" .. seq)
   return act(\"INSERT\", byte(seq))

end"]
// END RANK codeblock_142

codeblock_143 -> leaf_184
leaf_184  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- Get names for as many values as possible
-- into the colorizer
c.allNames()
-- This switches screens and does a wipe,
-- then puts the cursor at 1,1.
write \"\\x1b[?47h\\x1b[2J\\x1b[H\"
print \"an repl, plz reply uwu ðŸ‘€\"
displayPrompt 'ðŸ‘‰  '
-- Crude hack to choose raw mode at runtime
if arg[1] == \"-r\" then
   femto.raw()
   --uv.tty_set_mode(stdin, 2)
   -- mouse mode
   write(a.mouse.track(true))
   uv.read_start(stdin, onseq)
else
   uv.read_start(stdin, onread)
end



-- main loop
local retcode =  uv.run('default')
-- Restore main screen
print '\\x1b[?47l'

if retcode ~= true then
   error(retcode)
end

print(\"kthxbye\")
return retcode"]
// END RANK codeblock_143


}
