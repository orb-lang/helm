digraph lpegNode {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 303"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-159"]


// END RANK doc_0

section_1 -> { header_2 prose_3 prose_4 section_5 section_6}
{rank=same; header_2 prose_3 prose_4 section_5 section_6}

header_2 [label="1 : Femto"]

prose_3 [label="prose"]

prose_4 [label="prose"]

section_5 [label="section: 9-35"]

section_6 [label="section: 160-167"]


// END RANK section_1

header_2 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*  Femto"]
// END RANK header_2

prose_3 -> { raw_8}
{rank=same; raw_8}

raw_8 [label="raw"]


// END RANK prose_3

raw_8 -> leaf_9
leaf_9  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


I just got orb stood up in the pylon bootloader distribution.
"]
// END RANK raw_8

prose_4 -> { raw_10}
{rank=same; raw_10}

raw_10 [label="raw"]


// END RANK prose_4

raw_10 -> leaf_11
leaf_11  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I am excited about this.

"]
// END RANK raw_10

section_5 -> { header_12 prose_13 codeblock_14 section_15}
{rank=same; header_12 prose_13 codeblock_14 section_15}

header_12 [label="2 : includes"]

prose_13 [label="prose"]

codeblock_14 [label="code block 14-33"]

section_15 [label="section: 36-159"]


// END RANK section_5

header_12 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**  includes"]
// END RANK header_12

prose_13 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


// END RANK prose_13

raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This all goes into global space for now.  Our more sophisticated loader will
handle namespace isolation. Meanwhile we're building a repl, so.
"]
// END RANK raw_17

codeblock_14 -> leaf_19
leaf_19  [color=Gray,shape=rectangle,fontname=Inconsolata,label="sql = require \"sqlite\"

lfs = require \"lfs\"
ffi = require \"ffi\"

ffi.reflect = require \"reflect\"

uv = require \"luv\"

L = require \"lpeg\"

a = require \"anterm\"

c = require \"color\"

core = require \"core\"

watch = require \"watcher\""]
// END RANK codeblock_14

section_15 -> { header_20 prose_21 codeblock_22}
{rank=same; header_20 prose_21 codeblock_22}

header_20 [label="4 : utils"]

prose_21 [label="prose"]

codeblock_22 [label="code block 38-157"]


// END RANK section_15

header_20 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** utils"]
// END RANK header_20

prose_21 -> { raw_24}
{rank=same; raw_24}

raw_24 [label="raw"]


// END RANK prose_21

raw_24 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
"]
// END RANK raw_24

codeblock_22 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
local usecolors
stdout = \"\"

if uv.guess_handle(1) == \"tty\" then
  stdout = uv.new_tty(1, false)
  usecolors = true
else
  stdout = uv.new_pipe(false)
  uv.pipe_open(utils.stdout, 1)
  usecolors = false
end

if not usecolors then
   c.ts = tostring
   -- #todo make this properly black and white ts
end

function print(...)
  local n = select('#', ...)
  local arguments = {...}
  for i = 1, n do
    arguments[i] = tostring(arguments[i])
  end
  uv.write(stdout, table.concat(arguments, \"\\t\") .. \"\\n\")
end

function write(str)
   uv.write(stdout, str)
end


--  *** tty setup

if uv.guess_handle(0) ~= \"tty\" or
   uv.guess_handle(1) ~= \"tty\" then
  -- Entry point for other consumers!
  error \"stdio must be a tty\"
end

local stdin = uv.new_tty(0, true)


--[[

I'll keep this around for a bit, it looks nice


--]]

--  *** utilities

local function gatherResults(success, ...)
  local n = select('#', ...)
  return success, { n = n, ... }
end

local function printResults(results)
  for i = 1, results.n do
    results[i] = c.ts(results[i])
  end
  print(table.concat(results, '\\t'))
end

local buffer = ''

local function evaluateLine(line)
   if string.byte(line) == 17 then -- ^Q
      uv.stop()
      return 0
   end
   local chunk  = buffer .. line
   local f, err = loadstring('return ' .. chunk, 'REPL') -- first we prefix return

   if not f then
      f, err = loadstring(chunk, 'REPL') -- try again without return
   end

   if f then
      buffer = ''
      local success, results = gatherResults(xpcall(f, debug.traceback))

      if success then
      -- successful call
         if results.n > 0 then
            printResults(results)
         end
      else
      -- error
         print(results[1])
      end
   else
      if err:match \"'<eof>'$\" then
         -- Lua expects some more input; stow it away for next time
         buffer = chunk .. '\\n'
         return '...'
      else
         print(err)
         buffer = ''
      end
   end

   return 'ðŸ‘‰  '
end

local function displayPrompt(prompt)
  uv.write(stdout, prompt)
end

local function onread(err, line)
  if err then error(err) end
  if line then
    local prompt = evaluateLine(line)
    displayPrompt(prompt)
  else
    uv.close(stdin)
  end
end"]
// END RANK codeblock_22

section_6 -> { header_27 prose_28 prose_29 section_30}
{rank=same; header_27 prose_28 prose_29 section_30}

header_27 [label="2 : onkey(err, key)"]

prose_28 [label="prose"]

prose_29 [label="prose"]

section_30 [label="section: 168-303"]


// END RANK section_6

header_27 -> leaf_31
leaf_31  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** onkey(err, key)"]
// END RANK header_27

prose_28 -> { raw_32}
{rank=same; raw_32}

raw_32 [label="raw"]


// END RANK prose_28

raw_32 -> leaf_33
leaf_33  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

We buffer escape sequences, which terminate in an alphabetic value.
"]
// END RANK raw_32

prose_29 -> { raw_34}
{rank=same; raw_34}

raw_34 [label="raw"]


// END RANK prose_29

raw_34 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
No special effort to detect \"^[[\" (as opposed to just \"^[\") is made, that is
handled at the recognizer layer.

"]
// END RANK raw_34

section_30 -> { header_36 prose_37 prose_38 codeblock_39 codeblock_40 codeblock_41}
{rank=same; header_36 prose_37 prose_38 codeblock_39 codeblock_40 codeblock_41}

header_36 [label="4 : onkey state"]

prose_37 [label="prose"]

prose_38 [label="prose"]

codeblock_39 [label="code block 174-225"]

codeblock_40 [label="code block 227-262"]

codeblock_41 [label="code block 264-303"]


// END RANK section_30

header_36 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** onkey state"]
// END RANK header_36

prose_37 -> { raw_43}
{rank=same; raw_43}

raw_43 [label="raw"]


// END RANK prose_37

raw_43 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This is a stateful event loop, no way around it.
"]
// END RANK raw_43

prose_38 -> { raw_45}
{rank=same; raw_45}

raw_45 [label="raw"]


// END RANK prose_38

raw_45 -> leaf_46
leaf_46  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
State is maintained in the following upvalues.
"]
// END RANK raw_45

codeblock_39 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local keybuf = {}
local sub, byte = string.sub, string.byte
local concat = table.concat

local linebuf = { line = \"\",
                  ndx  = 0 }

local max_row, mac_col = 0, 0
local finding_max = false

local function cursor_pos(str)
   str = sub(str, 3, -2)
   local row, col = core.cleave(str, \";\")
   return tonumber(row), tonumber(col)
end

local _row = 1
local function colwrite(str)
   local dash = a.stash() .. a.jump(_row, 80) .. str .. a.pop()
   write(dash)
   _row = _row + 1
end

local function process_escapes(seq)
   local term = sub(seq, -1)
   if term == \"R\" and finding_max then
      max_row, max_col = cursor_pos(seq)
      write(a.pop())
      finding_max = false
   elseif term == \"A\" then
      -- up
   elseif term == \"B\" then
      -- down
   elseif term == \"C\" then
      -- left
   elseif term == \"D\" then
      -- right
   else
      return write(seq)
   end
end

local function recognize(seq)
   -- This front matter belongs in the escape handling code.
   if byte(seq) == 27 then
      process_escapes(seq)
      return
   end
   write(seq)
end"]
// END RANK codeblock_39

codeblock_40 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function onkey(err, key)
   if err then error(err) end
   -- ^Q to quit
   if key == \"\\17\" then
      femto.disableRawMode()
      uv.stop()
      return 0
   end
   if key == \"\\27\" then
      keybuf[#keybuf + 1]  = key
      return
   end
   if #keybuf > 0 then
      local char = byte(key)
      -- esc [0-9]
      if #keybuf == 1 and
         char >= 48 and char <= 57 then
         local esc_val = \"\\27\" .. key
         keybuf[1] = nil
         return recognize(esc_val)
      end
      -- [A-Za-z]
      if (char >= 65 and char <= 90)
         or (char >= 97 and char <= 122) then
         local esc_val = concat(keybuf) .. key
         for i, _ in ipairs(keybuf) do keybuf[i] = nil end
         return recognize(esc_val)
      else
         keybuf[#keybuf + 1] = key
         return
      end
   end
   return recognize(key)
end"]
// END RANK codeblock_40

codeblock_41 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label="-- Alternate screen

coroutine.wrap(function()
   -- Get names for as many values as possible
   -- into the colorizer
   c.allNames()
   -- This switches screens and does a wipe,
   -- then puts the cursor at 1,1.
   write '\\27[?47h\\27[2J\\27[H'
   print \"an repl, plz reply uwu ðŸ‘€\"
   displayPrompt 'ðŸ‘‰  '
   -- Crude hack to choose raw mode at runtime
   if arg[1] == \"-r\" then
      femto.enableRawMode()
      uv.read_start(stdin, onkey)
      finding_max = true
      -- stash cursor
      write(a.stash())
      -- Jump to bottom right and report position.
      write(\"\\27[999C\\27[999B\\27[6n\")
      -- the story continues in onkey...
   else
      uv.read_start(stdin, onread)
   end
end)()



local retcode = uv.run('default')
-- Restore
print '\\27[?47l'

if retcode ~= 0 then
   error(retcode)
end

print(\"kthxbye\")
return retcode"]
// END RANK codeblock_41


}
