* Dramatis Personae


  This is a guide to the actors which make up helm.

It is written in the present tense, with an eye toward the future.


** Background

  What follows is an attempt to make legible some of the most important
conventions of the bridge project.

A perusal of the [[style guide][httk://]] for Lua would be a good prerequisite
to reading this document generally, and this section in particular.


*** Actors in Bridge

What does it mean to say an artifact of code is an actor?

We eshew the use of "object" in discussing bridge code.  It has its place, but
is seldom the correct word to use to describe something.

This is a table: ={}=.  It is a map of anything, including itself, excluding
only =nil=, to anything else except =nil=.  Or if you prefer, it's a map of
absolutely everything except =nil=, to =nil=, except where otherwise
specified.

A table with a metatable, =setmetatable({}, Metatable)= is: a table with a
metatable.  Metatables, and metamethods, are the [[Meta Object Protocol]†] of
the Lua language, and they are magnificent.

[†]: https://en.wikipedia.org/wiki/The_Art_of_the_Metaobject_Protocol


**** Of Modules and Instances

A common pattern for a module is to define a metatable, with associated
metamethods and such machinery.  Such a module ends (usually) with a function
called =new=.  =new= is assigned to a slot on the metatable,
==Metatable.idEst = new==, and the function is returned.

This sort of module, when imported, is invariably done as follows:

#!lua #noKnit
local Widget = require "widget:widget"
#/lua

That is, what was called =new= in the module =./orb/widget/widget.orb=, is
called =Widget= at the consumer side.  =new= will take some number of
parameters, greater than or equal to zero, and return an /instance/ of Widget.
We avoid calling Widget a class! It's already a module, and a metatable, and
a constructor of instances: that's a lot of things for one word to be, and
there's no /one thing/ which has the Widget-nature already, so why keep adding
nouns?

What this gets us is that the following generally holds true:

#!lua #noKnit
local Widget = require "widget:widget"

local thingum = Widget()

assert(thingum.idEst == Widget, "this property normally holds")
#/lua

As an aside, this isn't flexible enough, and soon, before the year is out even,
we'll have to bite the bullet and rewrite it so that the call is
=thingum:idEst(Widget)=, where the simple case has =widget.orb= containing
==Widget.__type = new== after the constructor is defined.


**** All the Bridge is a Stage

Is =thingum= then an actor?  Sometimes, but not often.

What is an isn't an actor is necessarily somewhat subjective.  It may be that
we can spell out hard criteria which an actor must fulfill to meet the
standard, but it isn't necessary, and will never be sufficient.

We haven't talked much about actors, so this is all new information.  It is my
hope that becoming explicit about this will help us write better software.

The first thing is that an actor is /sui generis/, and almost always unique.
We might construct a mock actor for tests, but as a general rule there is
going to be on instance of each actor module.

I can imagine this admitting of exceptions, but in =helm=, there are not.

Second is that an actor *acts*, that is, it does things.  It doesn't exist to
be acted upon, but to take action; and it doesn't exist primarily to make
other objects (see, not a useless word!), although many of them do generate
considerable objects and other data.

So, to speak of [[espalier][@br:espalier]], neither the Grammar nor the Node
modules are actors. Both exist to create instances: Grammar makes grammars and
grammars parse strings into nodes.  Are they factories?

...I guess! <throws up hands, makes face>

A given grammar is also not an actor. Not really. They are /sui generis/, but
they don't do, they are done with.

Nor is =br=, the artifact produced by [[pylon][@br:pylon]], an actor.  It's a
program!  You can tell because it has a makefile.  It has no metatable and is
created with no instance: it's just bridge.

Orb, and helm, are clearly programs as well, apps even.  In bridge parlance we
call them projects.  A project has its own codex, and can be invoked with

#!lua #noKnit
local proj = require "project"

-- or

local proj = require "project:project"
#/lua

Projects which can be invoked from the command line with =br project= are
called *verbs*.  Some are core to bridge, and we provide a mechanism to create
and install new ones, which are only slightly second-class.

I think this is enough of an introduction.  Let's get to the meat of the
document: an introduction to the actors in bridge, and where we're going with
the design.

As a reminder, this is a living design document: as it is written, it's going
beyond what we have, and by the time it's written, it will have grown somewhat
stale.  I'll do what I can to keep it in tune with what actually happens.


** Dramatis Personae

Helm has more actors than any other program, by a large margin.

In Orb, the Lume is certainly an actor.  Skeins are probably actors as well,
in fact, let's go with that: despite being many, each has a personality,
defined ultimately by the File which provides the meat of each.  They
certainly do things!  So a given run of Orb can have more actors than helm,
usually.  It's just most of them are Skeins.

Doc is not, though. Doc is a grammar, there's no instance (except of Grammar),
and like any grammar it returns Nodes.

...actually Doc is a Node, but calling it invokes a Grammar.  This actually
makes sense, bit confusing to just type it out though.  It's just a convenient
way to do it, because the Doc format is a PEG grammar (several in fact) and
since PEG is a parsing format, parsing it returns a Node; PEG is defined the
"old fashioned" way, as a Lua function, because implementing the full
metacircular version is a bit of a hassle (I did start the job though).

So we attach a =__call= method to the start rule of PEG, and that calls a
generated Grammar which recognizes the universe of the defined grammar.

But we're here to talk about helm!  Without further ado, I introduce to you
the star of the show.


*** Modeselektor

The [[Modeselektor][@:helm/modeselektor]], =modeS= by name, is our star DJ.

All of =helm.orb= is one big function, with an environment, which sets up a
=uv= event loop, builds the modeselektor, and launches an event loop to run
it.

Modeselektor holds the references to all other actors.  We enter modeselector
in responsed to /events/, which are currently all created by input.  This is
handed to =modeS=, which does things with them.

The Modeselektor has somewhat outgrown his name, but I think we're going to
stick with it.  It comes from how we call him: we enter =modeS= when we get a
sequence of input, and =modeS= responds to that sequence by /selecting/ the
response on the basis of the /mode/ which helm is in at that exact instant.

It turns out that to do that, =modeS= has to know all, see all, and do a lot.
The role is one of coordination, and personally performing the big events.

=modeS:act()= is the primary modeselektor method.  In the =helm= loop, we call
=modeS(category, value)= and =ModeS.__call= is exactly this function:

#!lua #noKnit this should be a transclude...
function ModeS.__call(modeS, category, value)
   return modeS:act(category, value)
end
#/lua

Which is deliberate.  This lets us hook =:act=, replace it, and do anything
else we would care to.  Though we haven't.

Modeselektor owns references to three other actors, and we're adding a fourth.
They are the Historian, the Zoneherd, and Valiant, our evaluator.

This is a distinct relationship.  =modeS.hist= is, aspirationally, the *only*
reference to the Historian.  Anything which owns such a reference can command
anything of the actor, and can delete it: and after that, the actor is
garbage.

When an actor owns the only reference to another actor, we say that the owning
actor is the /Boss/ of that actor.  We can be as whimsical as we want in
describing the relationship in the other order.

This is in fact one of the criteria for actors: no one can serve two masters
(oops, looks like I'm cancelled) and an actor should have *only* one reference
to it, owned by its boss. If an Actor doesn't have a boss, well, then it's
the boss.  =modeS= is an upvalue in =helm.orb='s local namespace, when helm
returns, it goes out of scope, and show's over folks!  Don't forget to tip
your waitress.

We are in the process of introducing another big player, the Maestro.  Let us
begin with what we have!


*** Historian

The [[Historian][@:helm/historian.orb]] is in charge of the history of helm, across
all runs, sessions, and projects.

Helm never forgets.  Anything you enter into your helm is duly recorded and
kept forever.  We don't even offer a mechanism to prune it, and we probably
won't.  It's a SQLite database, if you want to do housekeeping you certainly
can.

The Historian loads up a bunch of information from this database using
=helm-db=, a instance containing a proxy table.  You pass it messages, it
returns prepared statements, and it has a few other tricks under its sleve.

While a proxy table is definitely not an actor, it is an instance, but not one
which follows the usual objectesque pattern.  Kind of its own thing.

If we're running a Session, this also lives on Historian. That's an actor as
well... I think.  It's kind of more a gets "done to" than a "doer", and I'm
making up the criteria as I go along.  But let's say it is one for the sake of
argument.

As we proceed, there will also be the Run, which makes a record of everything
from when helm is invoked to when it crashes or quits.  You'll be able to tell
the difference: a run which quit will say "I quit" at the end, and if it
didn't, either it crashed (we'll try to make a note but, you know) or it's
still running somewhere.

The Historian has even very recent history, such as the last line evaluated,
and it makes an effort to persist everything it knows just as soon as it can.
Currently, this isn't true of the Session, but it really should be.

Crashing should have as little impact as possible on the smooth functioning of
any bridge program as possible.

The most important data in the Historian, a robust cache of the last few
thousand lines, is stored in the array portion.

Modeselektor holds what should be the only reference to the historian, at
=modeS.hist=, and invokes him frequently.


*** Valiant

  [[Valiant][@br:session/valiant]] is our old friend =eval=.  He lives in his
own project, because we need him to run sessions from the command line as
well.

Valiant is invoked by =modeS:eval()=, usually in response to the user hitting
the return key.  Valiant evaluates the current text buffer, and returns any
results of the calculation, which Modeselektor dutifully hands to the
Historian for bookkeeping.

This isn't a place to define everything an actor does, we have the modules for
that; this suffices as an introduction.





