* Refactoring Ragas


  Time to tackle ragas.

We've made a lot of progress on reducing global state in =helm=, decoupling
components, and delineating areas of responsiblity within the system.

Ragas, the part of helm which responds to keystrokes, are lagging in that
respect.  This is typical of a bootstrap, but it's time to refactor them.


*** Keystroke parser

This first issue is fortunately self-contained: we shotgun keystrokes into
various categories.  This isn't /badly/ done, I'd say that the categories we
use (ASCII, UTF8, ALT, CTRL, PASTE, NAV, and MOUSE) are reasonable, although
NAV is kind of unprincipled, a grab-bag of terminal sequences which are issued
by arrow keys, PgUp/Dn, and so on.

The biggest problem here is that, if anything hangs the event loop for long
enough for the buffer to fill up, our shotgun parser just drops things on the
floor.

So this is one, reasonably self-contained task:


**** [ ] Write a better terminal sequence parser

I think we should be using =lpeg= for this, but using it directly: The output
is a sequence of (category, value) tuples, not an abstract syntax tree, so the
existing PEG machinery is going to fight against us.

In any case, this needs to break the assumption that exactly one sequence is
arriving at a time, so it should produce a pair of ((category, value), index),
such that if =index < #seq=, we send the tuple off to =modeS= and keep parsing
from =index= until the sequence is consumed.


*** Conflating keystrokes with actions

  This is one of the places where we're rapidly painting ourselves into a
corner.

It's impossible to discuss this without some leakage from later parts of this
document, I'll do my best to keep that to a minimum.

Currently, we have exactly one raga, and stateless shifts to new ragas which
constitute a state machine, one which is somewhat scattered between modules.

All of those things are problems, but not the one I'm addressing here, which
is that ragas act on (category, value) pairs directly.

What we need is a two-stage process, where keystrokes are turned into
something with more semantic meaning by the parser, and this is then resolved
into a message, which is sent to the raga.

There are more layers than this, but that's the essence of it. The raga itself
is a layered stack of available functions, with some kind of 'action resolver'
sitting on top of it, translating user commands into those actions.
