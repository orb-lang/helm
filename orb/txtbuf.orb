* Txtbuf

This is not much more than an ordinary array of lines that has a bit of
awareness, mostly about which lines have cursors and which don't.

I'll circle back for quipu but I want a basic editor as soon as possible. The
interaction dynamics need to be worked out right away, plus I want to use it!

Plan: A line that has a cursor on it, and there can be many, gets 'opened'
into a grid of characters.  These in turn get 'closed' when the cursor leaves.

A closed line is just a string.


** Interface


*** Instance fields

- lines :  An array of arrays containing codepoints (string fragments).

- cursor :  Number of fragments to skip before an insertion.

- cur_row :  Row containing the cursor.

- disp :  Array of numbers, representing the furthest-right column which
          may be reached by printing the corresponding row.

The intention is that all of these fields are manipulated internally: the
codebase doesn't completely respect this, yet, but it should.

This will let us expand, for instance, the definition of =cursor= to allow for
an array of cursors, in the event that there's more than one, without exposing
this elaboration to the rest of the system.

The =txtbuf= is also a candidate for full replacement with the quipu data
structure, so the more we can encapsulate its region of responsiblity, the
cleaner that transition can be.


**** Instance fields to be added

- region:  Has a field =cursor= and field =cur_row= which store the beginning
           of a region, with the txtbuf fields defined as the end of that
           region.

           Mutation of these should be encapsulated such that there can
           eventually be plural regions, during for instance search and
           replace.

**** dependencies

#!lua
assert(meta)
local collect = assert(table.collect)
local lines = assert(string.lines)
local codepoints = assert(string.codepoints)
#/lua


** Methods

#!lua
local Txtbuf = meta {}
#/lua

*** Txtbuf.__tostring(txtbuf)

#!lua
local concat = assert(table.concat)

local function cat(l)
   if type(l) == "string" then
      return l
   elseif type(l) == "table" then
      if l[1] ~= nil then
         return concat(l)
      else
         return ""
      end
   end

   error("called private fn cat with type" .. type(l))
end
#/lua

#!lua
function Txtbuf.__tostring(txtbuf)
   local phrase = ""
   for i = 1, #txtbuf.lines - 1 do
      phrase = phrase .. cat(txtbuf.lines[i]) .. "\n"
   end

   return phrase .. cat(txtbuf.lines[#txtbuf.lines])
end
#/lua

*** Txtbuf:openRow(row_num), Txtbuf:closeRow(row_num), Txtbuf:switchRow(row_num)

#!lua

function Txtbuf.openRow(txtbuf,row_num)
   local line = txtbuf.lines[row_num]
   if type(line) == "string" then
      txtbuf.lines[row_num] = codepoints(line)
   end
end

function Txtbuf.closeRow(txtbuf,row_num)
   local line = txtbuf.lines[row_num]
   if type(line) == "table" then
      txtbuf.lines[row_num] = concat(line)
   end
end

function Txtbuf.switchRow(txtbuf,new_row)
   if txtbuf.cur_row == new_row then return end
   txtbuf:closeRow(txtbuf.cur_row)
   txtbuf.cur_row = new_row
   txtbuf:openRow(txtbuf.cur_row)
end

#/lua


*** Txtbuf:insert(frag)

#!lua
local t_insert, splice = assert(table.insert), assert(table.splice)
local utf8, codepoints, gsub = string.utf8, string.codepoints, string.gsub

local _frag_sub = { ["("] = {"(", ")"},
                    ['"'] = {'"', '"'},
                    ["'"] = {"'", "'"},
                    ["{"] = {"{", "}"},
                    ["["] = {"[", "]"} }

local _closing_pairs = { '"', ")", "}", "]", "'"}

-- pronounced clozer
local function _closer(frag)
   local mebbe = false
   for _, cha in ipairs(_closing_pairs) do
      mebbe = mebbe or cha == frag
   end
   return mebbe
end

local function _no_insert(line, cursor, frag)
   if frag == line[cursor]
      and _closer(frag) then
      return false
   else
      return true
   end
end

function Txtbuf.insert(txtbuf, frag)
   local line = txtbuf.lines[txtbuf.cur_row]
   local wide_frag = utf8(frag)
   -- #deprecated
   -- in principle, we should be breaking up wide (paste) inputs in
   -- femto.
   --
   -- in reality this code is still invoked on paste.  Something to fix
   -- at some point...
   if wide_frag < #frag then -- a paste
      -- Normalize whitespace
      frag = gsub(frag, "\r\n", "\n"):gsub("\r", "\n"):gsub("\t", "   ")
      wide_frag = codepoints(frag)
   else
      wide_frag = false
   end
   -- #/deprecated
   if not wide_frag then
      if _frag_sub[frag] and _no_insert(line, txtbuf.cursor, frag) then
         -- add a closing symbol
         splice(line, txtbuf.cursor, _frag_sub[frag])
      elseif _no_insert(line, txtbuf.cursor, frag)then
         t_insert(line, txtbuf.cursor, frag)
      end
      txtbuf.cursor = txtbuf.cursor + 1
      return true
   else
      -- What if the fragment contains a newline? Don't we need to split it onto two lines of the txtbuf?
      -- Breaking up paste inputs might change how/where we handle this, but somehow or other we need to...
      splice(line, txtbuf.cursor, wide_frag)
      txtbuf.cursor = txtbuf.cursor + #wide_frag
      return true
   end

   return false
end
#/lua


*** Txtbuf:advance()

#!lua
local ts_bw = (require "color").ts_bw

function Txtbuf.advance(txtbuf)
   -- Seems like this should be folded into insert(), as part of handling newlines?
   txtbuf.lines[#txtbuf.lines + 1] = {}
   txtbuf.cur_row = #txtbuf.lines
   txtbuf.cursor = 1
end
#/lua


*** Txtbuf:d_back()

The return value tells us if we have one less line, since we need to
clear it off the screen (true of d_fwd as well

#NB this leave ghost lines on the screen during some kinds of multi-line
edits, which must be addressed.

#!lua
local remove = assert(table.remove)

local _del_by_pairs = { {"{", "}"},
                       {"'", "'"},
                       {'"', '"'},
                       {"[", "]"},
                       {"(", ")"} }

local function _isPaired(a, b)
   local pairing = false
   for _, bookends in ipairs(_del_by_pairs) do
      pairing = pairing or (a == bookends[1] and b == bookends[2])
   end
   return pairing
end

local function _deleteBack(txtbuf, cursor)
   local cursor, cur_row, lines = txtbuf.cursor, txtbuf.cur_row, txtbuf.lines
   if _isPaired(lines[cur_row][cursor - 1], lines[cur_row][cursor]) then
      remove(txtbuf.lines[cur_row], cursor)
      remove(txtbuf.lines[cur_row], cursor - 1)
   else
      remove(txtbuf.lines[cur_row], cursor - 1)
   end
   txtbuf.cursor = cursor - 1
end

function Txtbuf.d_back(txtbuf)
   local cursor, cur_row = txtbuf.cursor, txtbuf.cur_row
   if cursor > 1 then
      _deleteBack(txtbuf, cursor)
      return false
   elseif cur_row == 1 then
      return false
   else
      txtbuf:openRow(cur_row - 1)
      local new_cursor = #txtbuf.lines[cur_row - 1] + 1
      splice(txtbuf.lines[cur_row - 1],nil,txtbuf.lines[cur_row])
      remove(txtbuf.lines, cur_row)
      txtbuf.cur_row = cur_row - 1
      txtbuf.cursor = new_cursor
      return true
   end
end
#/lua


*** Txtbuf:d_fwd()

#!lua
function Txtbuf.d_fwd(txtbuf)
   local cursor, cur_row = txtbuf.cursor, txtbuf.cur_row
   if cursor <= #txtbuf.lines[cur_row] then
      remove(txtbuf.lines[txtbuf.cur_row], txtbuf.cursor)
      return false
   elseif cur_row == #txtbuf.lines then
      return false
   else
      txtbuf:openRow(cur_row + 1)
      splice(txtbuf.lines[cur_row],nil,txtbuf.lines[cur_row + 1])
      remove(txtbuf.lines, cur_row + 1)
      return true
   end
end
#/lua


*** Txtbuf:left(disp), Txtbuf:right(disp)

These methods shift a cursor left or right, handling line breaks internally.

=disp= is a number of codepoints to shift.

#!lua
function Txtbuf.left(txtbuf, disp)
   local disp = disp or 1
   local moved = false
   if txtbuf.cursor - disp >= 1 then
      txtbuf.cursor = txtbuf.cursor - disp
      moved = true
   else
      txtbuf.cursor = 1
   end
   if not moved and txtbuf.cur_row ~= 1 then
      local cur_row = txtbuf.cur_row - 1
      txtbuf.cur_row = cur_row
      txtbuf.cursor = #txtbuf.lines[cur_row] + 1
   end

   return moved
end
#/lua


*** Txtbuf:right(disp)

#!lua
function Txtbuf.right(txtbuf, disp)
   disp = disp or 1
   local moved = false
   local line = txtbuf.lines[txtbuf.cur_row]
   if txtbuf.cursor + disp <= #line + 1 then
      txtbuf.cursor = txtbuf.cursor + disp
      moved = true
   else
      txtbuf.cursor = #line + 1
   end

   if not moved and txtbuf.cur_row ~= txtbuf.lines then
      txtbuf.cur_row = txtbuf.cur_row + 1
      txtbuf.cursor = 1
   end

   return moved
end
#/lua


*** Txtbuf:rightWord(disp, mark), Txtbuf:leftWord(disp, mark)

This is the proposed interface for operating on a word level on a Txtbuf:

- #parameters

  - disp:  The number of /words/ to move across

  - mark:  A boolean: if true, the Txtbuf is annotated with a 'mark' defining
           a region.  The first cursor is stored as the mark origin, and the
           second cursor is given the 'cursor' slot on the txtbuf.

This lets us define a generalized method to kill or yank the region.


*** Txtbuf:replace(frag)

Replaces the character to the right of the cursor with the given codepoint.

This is called =frag= as a reminder that, a) it's variable width and b) to
really nail displacement we need to be looking up displacements in some kind
of region-defined lookup table.

*** Txtbuf:up(), Txtbuf:down()

#!lua

local function _constrain_cursor(txtbuf)
   if txtbuf.cursor > #txtbuf.lines[txtbuf.cur_row] + 1 then
      txtbuf.cursor = #txtbuf.lines[txtbuf.cur_row] + 1
   end
end

function Txtbuf.up(txtbuf)
   if txtbuf.cur_row == 1 then
      return false
   else
      txtbuf:switchRow(txtbuf.cur_row - 1)
      _constrain_cursor(txtbuf)
      return true
   end
end
#/lua

#!lua
function Txtbuf.down(txtbuf)
   if txtbuf.cur_row == #txtbuf.lines then
      return false
   else
      txtbuf:switchRow(txtbuf.cur_row + 1)
      _constrain_cursor(txtbuf)
      return true
   end
end
#/lua

*** Txtbuf:nl()

Either splits a line or (more usually) evaluates.

#!lua
local sub = assert(string.sub)
local insert = assert(table.insert)
function Txtbuf.nl(txtbuf)
   -- Most txtbufs are one line, so we always evaluate from
   -- a one-liner, regardless of cursor location.
   local linum = #txtbuf.lines
   if linum == 1 then
      return true
   end
   local cursor = txtbuf.cursor
   local cur_row = txtbuf.cur_row
   -- these are the two default positions for up and down
   -- history search
   if cur_row == 1 and cursor > #txtbuf.lines[1] then
      return true
   end
   if cur_row == linum and cursor > #txtbuf.lines[linum] then
      return true
   end
   -- split the line
   local cur_line = concat(txtbuf.lines[txtbuf.cur_row])
   local first = sub(cur_line, 1, cursor - 1)
   local second = sub(cur_line, cursor)
   txtbuf.lines[cur_row] = codepoints(first)
   insert(txtbuf.lines, cur_row + 1, codepoints(second))
   txtbuf.cursor = 1
   txtbuf.cur_row = cur_row + 1

   return false
end
#/lua


#!lua
function Txtbuf.suspend(txtbuf)
   for i,v in ipairs(txtbuf.lines) do
      txtbuf.lines[i] = tostring(v)
   end

   return txtbuf
end
#/lua

#!lua
function Txtbuf.resume(txtbuf)
   for i, line in ipairs(txtbuf.lines) do
      txtbuf.lines[i] = codepoints(line)
   end
   txtbuf.cursor = #txtbuf.lines[#txtbuf.lines] + 1
   txtbuf.cur_row = #txtbuf.lines

   return txtbuf
end
#/lua

#!lua
local cl = assert(table.clone, "table.clone must be provided")

function Txtbuf.clone(txtbuf)
   -- Clone to depth of 3 to get tb, tb.lines, and each lines
   local tb = cl(txtbuf, 3)
   if type(tb.lines[1]) == "string" then
      return tb:resume()
   end
   return tb
end
#/lua


*** new

#!lua
local function into_codepoints(lines)
   local cp = {}
   for i,v in ipairs(lines) do
      cp[i] = codepoints(v)
   end

   return cp
end

local function new(line)
   local txtbuf = meta(Txtbuf)
   local __l = line or ""
   local _lines = into_codepoints(collect(lines, __l))
   if #_lines == 0 then
      _lines[1] = {}
   end
   txtbuf.cursor = line and #_lines[#_lines] + 1 or 1
   txtbuf.cur_row = line and #_lines  or 1
   txtbuf.lines = _lines
   return txtbuf
end

Txtbuf.idEst = new
#/lua

#!lua
return new
#/lua