*  Helm


=helm= is our repl.


***** profiler

Normally commented out.

Planning to run this from time to time if it looks like we have significant
performance regressions.

#!lua
--[[
profile = require("jit.profile")
profiled = {}
profile.start("li1", function(th, samples, vmmode)
   local d = profile.dumpstack(th, "pF", 1)
   profiled[d] = (profiled[d] or 0) + samples
end)
--]]
#/lua

#!lua
assert(true)
if rawget(_G, "_Bridge") then
   _Bridge.helm = true
end
#/lua


**** Intercept _G

We don't want to put =helm= into the environment of the codebase under
examination, so we replace the global environment with a table which falls
back to =_G=. We make it available as a global anywhere in `helm`, without
exposing it to others who are still using the normal _G global environment.

Man.  I really like having first-class environments.

#!lua
local __G = setmetatable({}, {__index = _G})
__G.__G = __G
#/lua


**** _restore()

Does everything necessary to return the terminal to its original condition.

#!lua
local function _restore()
   local a = require "anterm"
   local uv = require "luv"
   -- Teardown: Mouse tracking off, restore main screen and cursor
   io.stdout:write(a.mouse.track(false),
         a.paste_bracketing(false),
         a.alternate_screen(false),
         a.cursor.pop(),
         a.cursor.show())

   -- Back to normal mode and finish tearing down uv
   uv.tty_reset_mode()

   -- Make sure the terminal processes all of the above
   io.stdout:flush()
   -- stop the loop
   uv.stop()
   -- Shut down the database conn:
   local helm_db = require "helm:helm/helm-db"
   helm_db.close()
   local retcode = uv.run 'default'

   -- Restore the global environment
   setfenv(0, _G)
end
#/lua


**** _cleanup(err)

When we catch errors, we handle need an error handler:

#!lua
local function _cleanup(err)
   _restore()
   io.stderr:write(debug.traceback(err, 2))
   os.exit(1)
end
#/lua


*** _helm

The entire module is setup as a function, to allow our new fenv
to be passed in.

#!lua
local function _helm(_ENV)
#/lua

Set our environment:

#!lua
setfenv(0, __G)
#/lua

Add some stuff to it:

#!lua
import = assert(require "core/module" . import)
meta = import("core/meta", "meta")
core = require "core:core"
jit.vmdef = require "helm:helm/vmdef"
jit.p = require "helm:helm/ljprof"
sql = assert(sql, "sql must be in _G")
#/lua


** Boot sequence

This boot sequence builds on Tim Caswell and the Luvit Author's repl example.

#!lua
uv = require "luv"
local usecolors
stdout = ""
#/lua


***** tty detection

  Should move this into =pylon= as a method in a bridge preload package, or
something like that.  We're not using the not tty branch, we just bail later
if we're in a pipe.

#!lua
if uv.guess_handle(1) == 'tty' then
   stdout = uv.new_tty(1, false)
   usecolors = true
else
   stdout = uv.new_pipe(false)
   uv.pipe_open(utils.stdout, 1)
   usecolors = false
end
#/lua

Not-blocking =write= and =print=:

#!lua
local function write(...)
   uv.write(stdout, {...})
end
#/lua

#!lua
local concat = assert(table.concat)

function print(...)
   local n = select('#', ...)
   local arguments = {...}
   for i = 1, n do
      arguments[i] = tostring(arguments[i])
   end
   uv.write(stdout, concat(arguments, "\t") .. "\n")
end
#/lua


*** tty setup

#!lua
if uv.guess_handle(0) ~= 'tty' or
   uv.guess_handle(1) ~= 'tty' then
   -- Bail if we're in a pipe
   error "stdio must be a tty"
end

local stdin = uv.new_tty(0, true)
#/lua

Primitives for terminal manipulation.

#!lua
a = require "anterm:anterm"
local Point = require "anterm:point"
--watch = require "watcher"
#/lua

** Modeselektor


#!lua

-- Get window size and set up an idler to keep it refreshed

local MOUSE_MAX = 223

local function bind_pane(dim1, dim2)
   dim1 = dim1 > MOUSE_MAX and MOUSE_MAX or dim1
   dim2 = dim2 > MOUSE_MAX and MOUSE_MAX or dim2
   return dim1, dim2
end

local max_col, max_row = bind_pane(uv.tty_get_winsize(stdin))
local max_extent = Point(max_row, max_col)



modeS = require "helm/modeselektor" (max_extent, write)
local insert = assert(table.insert)
local function s_out(msg)
   insert(modeS.status, msg)
end

-- make a new 'status' instance
local s = require "status:status" (s_out)

local bounds_watch = uv.new_timer()
uv.timer_start(bounds_watch, 500, 500, function()
   max_col, max_row = uv.tty_get_winsize(stdin)
   if Point(max_row, max_col) ~= modeS.max_extent then
      modeS.max_extent = Point(bind_pane(max_row, max_col))
      -- Mark all zones as touched since we don't know the state of the screen
      -- (some terminals, iTerm for sure, will attempt to reflow the screen
      -- themselves and fail miserably)
      for _, zone in ipairs(modeS.zones) do
         zone.touched = true
      end
      modeS:reflow()
   end
end)
#/lua


*** Orb listener

  If we start with the =--listen= flag, we open up a [[lume][@orb:lume/lume]],
and set an =uv= watcher on the project directory.

We then add a timer to check the lume for a flag indicating it has processed a
file, and restart the modeselektor if it has.


#!lua
local restart_watch, lume = nil, nil

if _Bridge.args.listen then
   uv.new_timer():start(0, 0, function()
      local orb = require "orb:orb"
      lume = orb.lume(uv.cwd())
      lume :run() :serve(true)
      restart_watch = uv.new_timer()
      uv.timer_start(restart_watch, 500, 500, function()
         if lume.has_file_change then
            modeS:restart()
            lume.has_file_change = nil
         end
      end)
   end)
end
#/lua


** Reader

The reader takes a stream of data from =stdin=, asynchronously, and
processes it into tokens, which stream to the =modeselektor=.


*** process_escapes(seq)

#!lua
local Codepoints = require "singletons/codepoints"
local byte, sub, char = assert(string.byte),
                        assert(string.sub),
                        assert(string.char)
local m_parse, is_mouse = a.mouse.parse_fast, a.mouse.ismousemove
local navigation = a.navigation

local function process_escapes(seq)
   if is_mouse(seq) then
      return modeS("MOUSE", m_parse(seq))
   elseif #seq == 2 and byte(seq, 2) < 128 then
      -- Meta
      local key = "M-" .. sub(seq,2,2)
      return modeS("ALT", key)
   elseif a.is_paste(seq) then
      return modeS("PASTE", a.parse_paste(seq))
   else
      return modeS("NYI", seq)
   end
end
#/lua


*** onseq(err, seq)

Listens for sequences from =stdin=.

Wrapped in an =xpcall=, because it's the entry point for most of the logit
inside Modeselektor, and we want to clean up the terminal when helm throws an
error.


#!lua
-- uv, being an event loop, will sometimes keep reading after
-- we expect it to stop.
--
-- _ditch prevents modeS from being reloaded in such circumstances.
--
-- maybe.
local _ditch = false

local function onseq(err, seq)
   if _ditch then return nil end
   xpcall(function()
      if err then error(err) end

      local head = byte(seq)
      -- Special "navigation" sequences--this includes some escape sequences
      if navigation[seq] then
         modeS("NAV", navigation[seq])
      -- Other escape sequences
      elseif head == 27 then
         process_escapes(seq)
      -- Control sequences
      elseif head <= 31 then
         local ctrl = "^" .. char(head + 64)
         modeS("CTRL", ctrl)
      -- Printables--break into codepoints in case of multi-char input sequence
      -- But first, optimize common case of single ascii printable
      -- Note that bytes <= 31 and 127 (DEL) will have been taken care of earlier
      elseif #seq == 1 and head < 128 then
         modeS("ASCII", seq)
      else
         local points = Codepoints(seq)
         for i, pt in ipairs(points) do
            -- #todo handle decode errors here--right now we'll just insert an
            -- actual Unicode "replacement character"
            modeS(byte(pt) < 128 and "ASCII" or "UTF8", pt)
         end
      end
      -- Okay, if the action resulted in a quit, break out of the event loop
      if modeS.has_quit then
         _ditch = true
         uv.read_stop(stdin)
         uv.timer_stop(bounds_watch)
         if restart_watch then
            uv.timer_stop(restart_watch)
            lume.server:stop()
         end
      end
   end, _cleanup)
end
#/lua

#!lua


-- Get names for as many values as possible
-- into the colorizer
-- Treat package names as existing in the global namespace
-- rather than having a "package.loaded." prefix
local names = require "repr:repr/names"
names.loadNames(package.loaded)
names.loadNames(_G)
names.loadNames(__G)

-- assuming we survived that, set up our repling environment:

-- raw mode
uv.tty_set_mode(stdin, 2)

-- Enable mouse tracking, save the cursor, switch screens and wipe,
-- then put the cursor at 1,1.
-- #todo Cursor save/restore supposedly may not work on all terminals?
-- Test this and, if necessary, explicitly read and store the cursor position
-- and manually restore it at the end.
write(a.cursor.stash(),
      a.alternate_screen(true),
      a.erase.all(),
      a.jump(1, 1),
      a.paste_bracketing(true),
      a.mouse.track(true)
)

-- set onseq to listen to stdin
uv.read_start(stdin, onseq)

-- paint screen
modeS:paint()

-- main loop
local retcode =  uv.run('default')

-- restore the terminal settings
_restore()

-- remove any spurious mouse inputs or other stdin stuff
io.stdin:read "*a"
#/lua

Thus ends =_helm=.

#!lua
end
#/lua

**** Call helm

#!lua
return setfenv(_helm, __G)
#/lua
