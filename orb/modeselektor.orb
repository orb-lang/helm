* Modeselektor

=femto= will hold all state for an terminal session.  Soon, we will
encapsulate that, making the library re-entrant.

=modeselektor= is the modal interpreter for the repl language, which becomes
the core of =ed=.  This is a glorified lookup table with a state switch and
a pointer to the =femto=cell we're operating on.

=femto= passes keystrokes as messages to =modeselektor=.  In final boss form,
it does no writes to stdout at all.  It is smart enough to categorize and
parse various device reports, but has no knowledge of why those reports were
requested.

=femto= runs the event loop, so all other members are pulled in as modules.

=modeselektor= takes care of system-level housekeeping: opening files and
sockets, keeping command history, fuzzy completion, and has its own eval loop
off the main track.  For evaluating lines, it will call a small executor, so
that in a little while we can put the user program in its own =LuaL_state=.

This is both good practice, and absolutely necessary if we are to REPL other
=bridge= programs, each of which has its own event loop.

=modeselektor= passes any edit or movement commands to a =linebuf=, which
keeps all modeling of the line.  =modeselektor= decides when to repaint the
screen, calling =rainbuf= with a region of =linebuf= and instructions as to
how to paint it.

There is one =deck= instance member per screen, which tiles the available
space.  =modeselektor= is the writer, and =rainbuf= holds a pointer to the
table for read access.

When we have our fancy parse engine and quipu structure, linebuf will call
=comb= to redecorate the syntax tree before passing it to =rainbuf= for
markup.  At the moment I'm just going to write some crude lexers, which
will be more than enough for Clu and Lua, which have straightforward syntax.

An intermediate step could just squeeze the linebuf into a string, parse it
with =esplalier= and emit a =rainbuf= through the usual recursive method
lookup.  The problem isn't speed, not for a REPL, it's not having error
recovery parsing available.

I will likely content myself with a grammar that kicks in when the user
presses return.  I'll want that to perform rewrites (such as removing
outer-level =local=s to facilicate copy-pasting) and keep the readline
grammar from becoming too ad-hoc.

#!lua
assert(meta, "must have meta in _G")
local ModeS = meta()
assert(write, "must have write in G")
local unpack = assert(unpack)
#/lua


*** Categories

These are the types of event recognized by =femto=.

#!lua
local INSERT = {}
local NAV    = {}
local CTRL   = {}
local ALT    = {}
local FN     = {}
local MOUSE  = {}
#/lua

Color schemes are supposed to be one-and-done, and I strongly suspect we
have a =__concat= dominated workflow, although I have yet to turn on the
profiler.

Therefore we use reference equality for the =color= and =hints= tables.
Switching themes is a matter of repopulating those tables.  I intend to
isolate this within an instance so that multiple terminals can each run their
own theme, through a simple 'fat inheritance' method.

=modeselektor= is what you might call hypermodal. Everything is isolated in
its own lookup, that is, we use /value/ equality.  This lets us pass strings
as messages and use jump tables to resolve most things.

It typically runs at the speed of human fingers and can afford to be much less
efficient than it will be, even before the JIT gets involved.

Note also that everything is a method, our dispatch pattern will always
include the =modeS= instance as the first argument.

#!lua
ModeS.modes = { INSERT = INSERT,
                NAV    = NAV,
                CTRL   = CTRL,
                ALT    = ALT,
                MOUSE  = MOUSE }
#/lua

Sometimes its useful to briefly override handlers, so we check values
against =special= first:

#!lua
ModeS.special = {}
#/lua



** act

=act= simply dispatches. Note that our common interfaces is
=method(modeS, category, value)=, we need to distinguish betwen the tuple
=("INSERT", "SHIFT-LEFT")= (which could arrive from copy-paste) and
=("NAV", "SHIFT-LEFT")= and preserve information for our fall-through method.

=act= always succeeds, meaning we need some metatable action to absorb and
log anything unexpected.

#!lua
function ModeS.act(modeS, category, value)
   if modeS.special[value] then
      return modeS.special[value](modeS, category, value)
   elseif modeS.modes[category][value] then
      return modeS.modes[category][value](modeS, category, value)
   else
      return modeS:default(category, value)
   end
end
#/lua

#!lua
function ModeS.default(modeS, category, value)
    return write(value)
end
#/lua

This will need to take a complete config table at some point.

#!lua
function new()
  local modeS = meta(ModeS)
  return modeS
end

ModeS.idEst = new
#/lua

#!lua
return new
#/lua























