* Run-review (interactive-restart) agent

Agent responsible for interactive editing of a previous run
before restarting it.


**** imports

#!lua
local table = core.table
#/lua


#!lua
local ReviewAgent = require "helm:agent/review"
local RunReviewAgent = meta(getmetatable(ReviewAgent))
#/lua


*** RunReviewAgent:update(lines)

#!lua
local insert = assert(table.insert)
function RunReviewAgent.update(agent, lines)
   agent.subject = {}
   while not lines:isEmpty() do
      insert(agent.subject, { line = lines:pop(), status = "keep" })
   end
   agent.selected_index = #agent.subject == 0 and 0 or 1
   agent:_updateResultsAgent()
   -- Update any EditAgents we have without creating any more
   for index in pairs(agent.edit_agents) do
      agent:_updateEditAgent(index)
   end
   agent:contentsChanged()
end
#/lua


** Editing


*** Status list

#!lua
RunReviewAgent.valid_statuses = { "keep", "trash", "insert" }
#/lua


*** Line insertion


**** RunReviewAgent:setSelectedState(state)

We need to perform additional bookkeeping to add or remove a blank line when
changing to/from insert status.

#!lua
local remove = assert(table.remove)
function RunReviewAgent.setSelectedState(agent, state)
   local premise = agent:selectedPremise()
   if premise.status == state then return end
   if premise.status == "insert" then
      -- Switching out of special "insert" state,
      -- remove temporary blank line
      remove(agent.subject, agent.selected_index + 1)
      -- Remove the *last* EditAgent iff there is one,
      -- then update the others to preserve bindings
      agent.edit_agents[#agent.subject + 1] = nil
      agent:bufferCommand("editAgentRemoved", #agent.subject + 1)
      for i = agent.selected_index + 1, #agent.subject do
         agent:_updateEditAgent(i)
      end
   elseif state == "insert" then
      -- Switching to special "insert" state,
      -- add a blank line below the selected premise
      -- Use an otherwise-invalid state--this line should never be selected
      -- except when editing it, so it cannot receive a Tab keypress
      insert(agent.subject, agent.selected_index + 1, { line = "", status = "ignore" } )
      for i = agent.selected_index + 1, #agent.subject do
         agent:_updateEditAgent(i)
      end
   end
   return ReviewAgent.setSelectedState(agent, state)
end
#/lua


**** RunReviewAgent:selectIndex(i)

Only the selected premise may have the "insert" state,
switch back to "keep" if we scroll away.

#!lua
local clamp = assert(core.math.clamp)
function RunReviewAgent.selectIndex(agent, index)
   index = #agent.subject == 0
      and 0
      or clamp(index, 1, #agent.subject)
   if index ~= agent.selected_index
      and agent:selectedPremise().status == "insert" then
      agent:setSelectedState("keep")
   end
   ReviewAgent.selectIndex(agent, index)
end
#/lua


**** RunReviewAgent:selectNextWrap()

Need to ignore a temporary blank line at the very end, since it will be
removed as part of changing selection and we would otherwise end up with a
no-op.

#!lua
function RunReviewAgent.selectNextWrap(agent)
   if agent:selectedPremise().status == "insert"
      and agent.selected_index + 1 == #agent.subject then
      return agent:selectIndex(1)
   else
      return ReviewAgent.selectNextWrap(agent)
   end
end
#/lua


**** RunReviewAgent:editInsertedLine()

Switch to editing a blank, newly-inserted line/premise, iff there is one.

#!lua
function RunReviewAgent.editInsertedLine(agent)
   if agent:selectedPremise().status ~= "insert" then
      return false
   end
   agent :send { method = "pushMode", "edit_line"}
end
#/lua


**** RunReviewAgent:cancelInsertEditing()

Cancel out of editing the line-to-be-inserted, returning selection
to the line before (still with the "insert" status).

#!lua
function RunReviewAgent.cancelInsertEditing(agent)
   agent :send { to = "agents.edit", method = "clear" }
   agent :send { method = "popMode" }
end
#/lua


**** RunReviewAgent:acceptInsertion()

Accept the line in the edit buffer as a new premise.

#!lua
function RunReviewAgent.acceptInsertion(agent)
   local line = agent :send { to = "agents.edit", method = "contents" }
   agent :send { to = "agents.edit", method = "clear" }
   local new_premise = agent.subject[agent.selected_index + 1]
   new_premise.line = line
   new_premise.status = "keep"
   agent:_updateEditAgent(agent.selected_index + 1)
   -- Switch out the status without going through the usual channels
   -- so that we don't remove the newly-added premise in the process
   agent:selectedPremise().status = "keep"
   agent:selectNextWrap()
   send { method = "popMode" }
end
#/lua


*** RunReviewAgent:evalAndResume()

Finishes the review process, evaluating all non-trashed lines.

#!lua
local Deque = require "deque:deque"
function RunReviewAgent.evalAndResume(agent)
   -- Clear out any insertion-in-progress
   if agent:selectedPremise().status == "insert" then
      agent:setSelectedState("keep")
   end
   local to_run = Deque()
   for _, premise in ipairs(agent.subject) do
      if premise.status == "keep" then
         to_run:push(premise.line)
      end
   end
   agent :send { method = "rerun", to_run }
   agent :send { method = "pushMode", "nerf" }
end
#/lua


#!lua
return core.cluster.constructor(RunReviewAgent)
#/lua
