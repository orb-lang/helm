* ReviewAgent

Abstract base for agents that handle editing of something like a Run
(either a run itself or a session).


**** imports

#!lua
local core = require "qor:core"
local math = core.math
local assert = assert(core.fn.assertfmt)

local cluster = require "cluster:cluster"
local Agent = require "helm:agent/agent"

local EditAgent = require "helm:agent/edit"
local ResultsAgent = require "helm:agent/results"
#/lua


*** ReviewAgent()

#!lua
local new, ReviewAgent = cluster.genus(Agent)

cluster.extendbuilder(new, function(_new, agent)
   agent.selected_index = 0
   agent.edit_agents = {}
   agent.results_agent = ResultsAgent()
   agent.status_cycle_map = {}
   agent.status_reverse_map = {}
   local stats = _new.valid_statuses
   for i, this_status in ipairs(stats) do
      local prev_status = i == 1
         and stats[#stats]
         or stats[i - 1]
      local next_status = i == #stats
         and stats[1]
         or stats[i + 1]
      agent.status_cycle_map[this_status] = next_status
      agent.status_reverse_map[this_status] = prev_status
   end
   return agent
end)
#/lua


*** ReviewAgent:update(riff)

Configure the agent to display/edit the rounds in =riff=. Note we defer to an
abstract =:setInitialSelection()= as empty-riff behavior differs.

#!lua
function ReviewAgent.update(agent, run)
   agent.topic = run
   agent:setInitialSelection()
   agent:_updateResultsAgent()
   -- Update any EditAgents we have without creating any more
   for index in pairs(agent.edit_agents) do
      agent:_updateEditAgent(index)
   end
   agent:contentsChanged()
end
#/lua


*** ReviewAgent:_updateEditAgent(index), :_updateResultsAgent()

Since we lazy-create our subsidiary agents, it's worth a function wrapper to
update them if-and-only-if they exist.

#!lua
function ReviewAgent._updateEditAgent(agent, index)
   local edit_agent = agent.edit_agents[index]
   if edit_agent then
      edit_agent:update(agent.topic[index].line)
   end
end

function ReviewAgent._updateResultsAgent(agent)
   local results_agent = agent.results_agent
   if results_agent then
      local round = agent:selectedRound()
      local result = round and round:result()
      results_agent:update(result)
      -- #todo scroll offset of the Resbuf needs to be reset at this point
      -- we have some serious thinking to do about how changes are
      -- communicated to the buffer
   end
end
#/lua


*** Selection, scrolling, etc


**** ReviewAgent:selectionChanged()

Notification that the selected item in the list has changed. Update the
results display and scroll the selection into view. Our displayed contents
change as well because of the selection highlight.

#!lua
function ReviewAgent.selectionChanged(agent)
      agent:_updateResultsAgent()
      agent:contentsChanged()
      agent:bufferCommand("ensureSelectedVisible")
end
#/lua


**** ReviewAgent:selectIndex(index)

Select the round at =index= in the session for possible editing.

#!lua
local clamp = assert(math.clamp)
function ReviewAgent.selectIndex(agent, index)
   index = #agent.topic == 0
      and 0
      or clamp(index, 1, #agent.topic)
   if index ~= agent.selected_index then
      agent.selected_index = index
      agent:selectionChanged()
   end
end
#/lua


**** ReviewAgent:selectNextWrap(), :selectPreviousWrap()

Selects the next/previous round, wrapping around to the beginning/end
if we're at the end/beginning, respectively.

#!lua
function ReviewAgent.selectNextWrap(agent)
   local new_idx = agent.selected_index < #agent.topic
      and agent.selected_index + 1
      or 1
   return agent:selectIndex(new_idx)
end
function ReviewAgent.selectPreviousWrap(agent)
   local new_idx = agent.selected_index > 1
      and agent.selected_index - 1
      or #agent.topic
   return agent:selectIndex(new_idx)
end
#/lua


**** ReviewAgent:selectedRound()

#!lua
function ReviewAgent.selectedRound(agent)
   return agent.topic[agent.selected_index]
end
#/lua


*** Editing


**** Status list and cycle maps

Concrete implementations must supply a list of possible round statuses,
in the order they should cycle when pressing "tab".


**** ReviewAgent:[reverse]toggleSelectedState()

Toggles the state of the selected round, cycling through the valid statuses.

#!lua
function ReviewAgent.toggleSelectedState(agent)
   local new_status = agent.status_cycle_map[agent:selectedRound().status]
   return agent:setSelectedState(new_status)
end

function ReviewAgent.reverseToggleSelectedState(agent)
   local new_status = agent.status_reverse_map[agent:selectedRound().status]
   return agent:setSelectedState(new_status)
end
#/lua


**** ReviewAgent:setSelectedState(state)

Directly set the state of the selected round (must be one of the valid states).

#!lua
function ReviewAgent.setSelectedState(agent, state)
   local round = agent:selectedRound()
   if round.status == state then return end
   assert(agent.status_cycle_map[state], "Cannot change to invalid status %s", state)
   round.status = state
   agent:contentsChanged()
   return true
end
#/lua


**** ReviewAgent:moveRound{Up|Down}()

Moves the selected round up/back or down/forward in the riff.

#todo doesn't account for the round results possibly changing as a result.
For now, we assume the user knows what they're doing, and they can always
use =br session update= to fix things separately.

#!lua
local function _swap_rounds(agent, index_a, index_b)
   local round_a = agent.topic[index_a]
   local round_b = agent.topic[index_b]

   agent.topic[index_a] = round_b
   round_b.ordinal = index_a
   agent:_updateEditAgent(index_a)

   agent.topic[index_b] = round_a
   round_a.ordinal = index_b
   agent:_updateEditAgent(index_b)

   agent:contentsChanged()
end

function ReviewAgent.moveRoundUp(agent)
   if agent.selected_index == 1 then
      return false
   end
   _swap_rounds(agent, agent.selected_index, agent.selected_index - 1)
   -- Maintain selection of the same round after the move
   -- Will never wrap because we disallowed moving the first round up
   agent:selectPreviousWrap()
   return true
end

function ReviewAgent.moveRoundDown(agent)
   if agent.selected_index == #agent.topic then
      return false
   end
   _swap_rounds(agent, agent.selected_index, agent.selected_index + 1)
   agent:selectNextWrap()
   return true
end
#/lua


** Buffer interaction protocol


*** ReviewAgent:bufferValue()

#!lua
function ReviewAgent.bufferValue(agent)
   return agent.topic
end
#/lua


*** ReviewAgent:windowConfiguration()

Our primary window exposes selection information, and can also retrieve
windows for our subsidiary =Edit= and =ResultsAgent=s.

#!lua
function ReviewAgent.windowConfiguration(agent)
   return agent.mergeWindowConfig(Agent.windowConfiguration(), {
      field = { selected_index = true },
      closure = { selectedRound = true,
                  editWindow = true,
                  resultsWindow = true }
   })
end
#/lua


**** ReviewAgent:editWindow(index)

Retrieve the window for the EditAgent for the =index=th round.

#!lua
local inbounds = assert(math.inbounds)
local lua_thor = assert(require "helm:lex" . lua_thor)
function ReviewAgent.editWindow(agent, index)
   assert(inbounds(index, 1, #agent.topic))
   if not agent.edit_agents[index] then
      -- Stuff not-yet-initialized slots with `false`
      -- to maintain correct insert/remove/etc behavior
      for i = #agent.edit_agents + 1, index - 1 do
         agent.edit_agents[i] = false
      end
      agent.edit_agents[index] = EditAgent()
      agent.edit_agents[index].lex = lua_thor
      agent:_updateEditAgent(index)
   end
   return agent.edit_agents[index]:window()
end
#/lua


**** ReviewAgent:resultsWindow()

Retrieve the window to the ResultsAgent for the results of the
currently-selected round. This Agent and its Window is persistent, and is
updated when the selected round changes.

#!lua
function ReviewAgent.resultsWindow(agent)
   return agent.results_agent:window()
end
#/lua


#!lua
return new
#/lua
