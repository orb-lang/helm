* Rainbuf


This class encapsulates data to be written to the screen.

As it stands, we have two special cases, the =txtbuf= and =results=.

We need to extend the functionality of =results=, so we're building this as a
root metatable for those methods.

Plausibly, we can make this a 'mixin' for =txtbuf= as well, since they have
the additional complexity of receiving input.


** Design

We're aiming for complex interactivity with data.

Our current renderer is crude: it converts the entire table into a string
representation, including newlines, and returns it.

One sophistication we've added is a =__repr= metamethod, which overrides the
default use of =ts()=.  It still returns a dumb block of strings, using
concatenation at the moment of combination.  This is inefficient and also
impedes more intelligent rendering.  But it's a start.

=rainbuf= needs to have a cell-by-cell understanding of what's rendered and
what's not, must calculate a printable representation given the constraints of
the =zone=, and, eventually, will respond to mouse and cursor events.

Doing this correctly is extraordinarily complex but we can fake it adequately
as long as the engineering is correct.  Everything we're currently using is
ASCII-range or emojis and both of those are predictable, narrow/ordinary and
wide respectively.

There are libraries/databases which purport to answer this question.  We plan
to link one of those in.

Results, as we currently manifest them, use an array for the raw objects and
=n= rather than =#res= to represent the length.  That's a remnant of the
original repl from =luv=.  The =.n= is neceessary because =nil= can be a
positional result.

A =txtbuf= keeps its contents in a =.lines= table, and so we can reuse this
field for cached textual representations.  All internals should support both
strings and array-of-strings as possible values of the =lines= array.

We also need a =.wids= array of arrays of numbers and should probably hide
this behind methods so as to fake it when we just have strings.

Later, we add a =.targets=, this is a dense array for the number of lines,
each with a sparse array containing handlers for mouse events.  If a mouse
event doesn't hit a =target= then the default handler is engaged.

We also have =offset=, a number, and =more=, which is =true= if the buffer
continues past the edge of the zone and otherwise falsy.

**** includes

#!lua
local lineGen = import("helm/repr", "lineGen")
#/lua


**** Rainbuf metatable

#!lua
local Rainbuf = meta {}
#/lua

** Methods

*** Rainbuf:clearCaches()

Clears any cached lineGen iterators and their output, causing a full re-render
the next time lineGen is called.

#!lua
local clear = assert(table.clear)
function Rainbuf.clearCaches(rainbuf)
   rainbuf.reprs = nil
   clear(rainbuf.lines)
end
#/lua

*** Rainbuf:lineGen(rows, offset)

This is a generator which yields =rows= number of lines.

Since we've replaced the old all-at-once =repr= with something that generates
a line at a time (and it only took, oh, six months), we're finally able to
generate these on the fly.

#!lua
local insert = assert(table.insert)
local lines = import("core/string", "lines")

function Rainbuf.lineGen(rainbuf, rows, cols)
   local offset = rainbuf.offset or 0
   cols = cols or 80
   if rainbuf.scrollable then
      cols = cols - 3
   end
   if rainbuf.live then
      -- this buffer needs a fresh render each time
      rainbuf:clearCaches()
   end
   if not rainbuf.reprs then
      rainbuf.reprs = {}
      for i = 1, rainbuf.n do
         rainbuf.reprs[i] = rainbuf.frozen
            and lines(rainbuf[i])
            or lineGen(rainbuf[i], cols)
      end
   end
   -- state for iterator
   local r_num = 1
   local cursor = offset
   local max_row = offset + rows
   rainbuf.more = true
   local function _nextLine()
      -- Off the end
      if cursor >= max_row then
         return nil
      end
      cursor = cursor + 1
      -- Fill the lines array until there's a line available at the cursor,
      -- or we know there will not be one. Look one step ahead to correctly
      -- set .more
      while rainbuf.more and cursor >= #rainbuf.lines do
         local repr = rainbuf.reprs[r_num]
         -- Out of content
         if repr == nil then
            rainbuf.more = false
         else
            local line = repr()
            if line then
               insert(rainbuf.lines, line)
            else
               r_num = r_num + 1
            end
         end
      end
      local prefix = ""
      if rainbuf.scrollable then
         -- If this is the last line requested, but more are available,
         -- prepend a continuation marker, otherwise left padding
         prefix = "   "
         if cursor == max_row and rainbuf.more then
            prefix = a.red "..."
         end
      end
      return rainbuf.lines[cursor] and prefix .. rainbuf.lines[cursor]
   end
   return _nextLine
end
#/lua

*** Rainbuf:scrollUp(), Rainbuf:scrollDown()

Scrolls the visible portion up or down one line. Returns a boolean
indicating whether scrolling actually ocurred.

#!lua
function Rainbuf.scrollUp(rainbuf)
   if rainbuf.offset > 0 then
      rainbuf.offset = rainbuf.offset - 1
      return true
   else
      return false
   end
end

function Rainbuf.scrollDown(rainbuf)
   if rainbuf.more then
      rainbuf.offset = rainbuf.offset + 1
      return true
   else
      return false
   end
end
#/lua

*** new(res?)

#!lua
local function new(res)
   if type(res) == "table" and res.idEst == Rainbuf then
      error "made a Rainbuf from a Rainbuf"
   end
   local rainbuf = meta(Rainbuf)
   assert(res.n, "must have n")
   if res then
      for i = 1, res.n do
         rainbuf[i] = res[i]
      end
      rainbuf.n = res.n
      rainbuf.frozen = res.frozen
      rainbuf.live = res.live
      rainbuf.scrollable = res.scrollable
   end
   rainbuf.offset = 0
   rainbuf.lines = {}
   return rainbuf
end

Rainbuf.idEst = new

return new
#/lua


