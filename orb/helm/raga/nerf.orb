* Nerf mode


=nerf= is the default mode for the repl.

-  #Todo

  - [X]  All of the content for the first draft is in =modeselektor=, so
         let's transfer that.

  - [?]  There should probably be a metatable for Mode objects.


**** includes

This is copypasta from Modeselektor, but yeah, we'll need most of this.

#!lua
assert(meta, "must have meta in _G")
#/lua

#!lua
local a         = require "anterm:anterm"
local Txtbuf    = require "helm:buf/txtbuf"
local Rainbuf   = require "helm:buf/rainbuf"
local Historian = require "helm/historian"
local Lex       = require "helm/lex"

local concat, insert = assert(table.concat), assert(table.insert)
local sub, gsub, rep = assert(string.sub),
                       assert(string.gsub),
                       assert(string.rep)
local yield = assert(coroutine.yield)
#/lua


** Nerf

#!lua
local clone    = import("core/table", "clone")
local EditBase = require "helm:helm/raga/edit"

local Nerf = clone(EditBase, 2)
Nerf.name = "nerf"
Nerf.prompt_char = "ðŸ‘‰"
#/lua

*** Insertion

#!lua

local function _insert(modeS, category, value)
   if modeS:agent'edit':contents() == "" then
      modeS:clearResults()
      if value == "/" then
         yield{ method = "shiftMode", "search" }
         return
      end
      if value == "?" then
         modeS:openHelp()
         return
      end
   end
   modeS:agent'edit':insert(value)
end

Nerf.ASCII = _insert
Nerf.UTF8 = _insert

#/lua

*** NAV

#!lua

local NAV = Nerf.NAV

local function _prev(modeS)
   -- Save what the user is currently typing...
   local linestash = modeS:agent'edit':contents()
   -- ...but only if they're at the end of the history,
   -- and obviously only if there's anything there
   if linestash == "" or modeS.hist.cursor <= modeS.hist.n then
      linestash = nil
   end
   local prev_line, prev_result = modeS.hist:prev()
   if linestash then
      modeS.hist:append(linestash)
   end
   modeS:agent'edit':update(prev_line)
   modeS:setResults(prev_result)
   return modeS
end

function NAV.UP(modeS, category, value)
   local inline = modeS:agent'edit':up()
   if not inline then
      _prev(modeS)
   end
   return modeS
end

local function _advance(modeS)
   local new_line, next_result = modeS.hist:next()
   if not new_line then
      local added = modeS.hist:append(modeS:agent'edit':contents())
      if added then
         modeS.hist.cursor = modeS.hist.n + 1
      end
   end
   modeS:agent'edit':update(new_line)
   modeS:setResults(next_result)
   return modeS
end

function NAV.DOWN(modeS, category, value)
   local inline = modeS:agent'edit':down()
   if not inline then
      _advance(modeS)
   end

   return modeS
end
#/lua

#!lua
function _eval(modeS)
   local line = modeS:agent'edit':contents()
   local success, results = modeS.eval(line)
   if not success and results == 'advance' then
      modeS:agent'edit':endOfText()
      modeS:agent'edit':nl()
   else
      modeS.hist:append(line, results, success)
      modeS.hist.cursor = modeS.hist.n + 1
      modeS:setResults(results)
      modeS:agent'edit':clear()
   end
end

function NAV.RETURN(modeS, category, value)
   if modeS:agent'edit':shouldEvaluate() then
      _eval(modeS)
   else
      modeS:agent'edit':nl()
   end
end

function NAV.CTRL_RETURN(modeS, category, value)
   _eval(modeS)
end

function NAV.SHIFT_RETURN(modeS, category, value)
   modeS:agent'edit':nl()
end

-- Add aliases for terminals not in CSI u mode
Nerf.CTRL["^\\"] = NAV.CTRL_RETURN
NAV.ALT_RETURN = NAV.SHIFT_RETURN
#/lua


** Keymap

#!lua
Nerf.default_keymaps = {{ source = "agents.suggest",
                          name = "keymap_try_activate" },
                        { source = "agents.results",
                          name = "keymap_scrolling" },
                        { source = "agents.edit",
                          name = "keymap_readline_nav" }}
for _, map in ipairs(EditBase.default_keymaps) do
   insert(Nerf.default_keymaps, map)
end
#/lua

*** Scroll handling

#!lua
function Nerf.scrollResultsUp(maestro, event)
   maestro.agents.results:scrollUp(event.num_lines)
end

function Nerf.scrollResultsDown(maestro, event)
   maestro.agents.results:scrollDown(event.num_lines)
end

#/lua


*** ALT

#!lua
local ALT = Nerf.ALT
#/lua


**** M-e

#!lua
ALT ["M-e"] = function(modeS, category, value)
   local top = modeS.hist.n
   local cursor = modeS.hist.cursor
   for i = cursor, top do
      -- Discard the second return value from :index
      -- or it will confuse the Txtbuf constructor rather badly
      local line = modeS.hist:index(i)
      modeS:agent'edit':update(line)
      _eval(modeS)
   end
end
#/lua

*** Nerf.onCursorChanged(modeS), Nerf.onTxtbufChanged(modeS)

Whenever the cursor moves or the Txtbuf contents change, need to
update the suggestions.

#!lua
function Nerf.onCursorChanged(modeS)
   modeS:agent'suggest':update()
   EditBase.onCursorChanged(modeS)
end

function Nerf.onTxtbufChanged(modeS)
   modeS:agent'suggest':update()
   EditBase.onTxtbufChanged(modeS)
end
#/lua


*** Nerf.onShift

Set up Agent connections--install the SuggestAgent's Window as the provider of
suggestions for the Txtbuf, and ResultsAgent to supply the content of the
results zone.

#!lua
local Resbuf = require "helm:buf/resbuf"
function Nerf.onShift(modeS)
   EditBase.onShift(modeS)
   modeS:bindZone("results", "results", Resbuf, { scrollable = true })
   local txtbuf = modeS.zones.command.contents
   txtbuf.suggestions = modeS:agent'suggest':window()
end
#/lua

#!lua
return Nerf
#/lua
