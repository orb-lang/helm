* Raga base

Some common functionality for ragas.


** Dependencies

#!lua
local a         = require "anterm:anterm"

local concat         = assert(table.concat)
local sub, gsub, rep = assert(string.sub),
                       assert(string.gsub),
                       assert(string.rep)
#/lua


** Categories

These are the broad types of event.

#!lua
local RagaBase_meta = {}
local RagaBase = setmetatable({}, RagaBase_meta)

for _, cat in ipairs{"NAV", "CTRL", "ALT", "ASCII",
                     "UTF8", "PASTE", "MOUSE", "NYI"} do
   RagaBase[cat] = {}
end
#/lua

When creating a new raga, remember to set:

#!lua-example
RagaBase.name = "raga_base"
RagaBase.prompt_char = "$"
#/lua-example


*** CTRL[^Q]

We default to having ^Q perform an immediate quit--some ragas may wish to
prompt to save changes or the like first.

#!lua
RagaBase.CTRL["^Q"] = function(modeS, category, value)
   -- #todo it's obviously terrible to have code specific to a particular
   -- piece of functionality in an abstract class like this.
   -- To do this right, we probably need a proper raga stack. Then -n could
   -- push the Review raga onto the bottom of the stack, then Nerf. Quit
   -- at this point would be the result of the raga stack being empty,
   -- rather than an explicitly-invoked command, and Ctrl-Q would just pop
   -- the current raga. Though, a Ctrl-Q from e.g. Search would still want
   -- to actually quit, so it's not quite that simple...
   -- Anyway. Also, don't bother saving the session if it has no premises...
   if _Bridge.args.new_session and #modeS.hist.session > 0 then
      -- #todo Add the ability to change accepted status of
      -- the whole session to the review interface
      modeS.hist.session.accepted = true
      -- Also, it's horribly hacky to change the "default" raga, but it's
      -- the only way to make Modal work properly. A proper raga stack
      -- would *definitely* fix this
      modeS.raga_default = "review"
      modeS.shift_to = "review"
      modeS:setStatusLine("review", modeS.hist.session.session_title)
   else
      modeS:quit()
   end
end
#/lua


** __call (main input handling/dispatch)

Looks up and executes a handler for a seq. Note that we must perform the
lookup on the table that was actually called in order to support inheritance,
e.g. an explicit call to =EditBase(modeS, category, value)= when
modeS.raga == Nerf.

#!lua

local hasfield, iscallable = import("core/table", "hasfield", "iscallable")

function RagaBase_meta.__call(raga, modeS, category, value)
   -- Dispatch on value if possible
   if hasfield(raga[category], value) then
      raga[category][value](modeS, category, value)
   -- Or on category if the whole category is callable
   elseif iscallable(raga[category]) then
      raga[category](modeS, category, value)
   -- Otherwise indicate that we didn't know what to do with the input
   else
      return false
   end
   return true
end

#/lua


** <Raga>.getCursorPosition(modeS)

Computes and returns the position for the terminal cursor,
or nil if it should be hidden. This is a reasonable default
as not all ragas need the cursor shown.

#!lua
function RagaBase.getCursorPosition(modeS)
   return nil
end
#/lua


** Events


*** <Raga>.onTxtbufChanged(modeS)

Called whenever the txtbuf's contents have changed while processing a seq.

#!lua
function RagaBase.onTxtbufChanged(modeS)
   return
end
#/lua


*** <Raga>.onCursorChanged(modeS)

Called whenever the cursor has moved while processing a seq.
Both onTxtbufChanged and onCursorChanged will be called in the
common case of a simple insertion.

#!lua
function RagaBase.onCursorChanged(modeS)
   return
end
#/lua


*** <Raga>.onShift(modeS)

Called when first switching to the raga. Provides an opportunity to
reconfigure zones or perform other set-up work.

#!lua
function RagaBase.onShift(modeS)
   return
end
#/lua


*** <Raga>.onUnshift(modeS)

Opposite of onShift--called when switching away to another raga.

#!lua
function RagaBase.onUnshift(modeS)
   return
end
#/lua


#!lua
return RagaBase
#/lua
