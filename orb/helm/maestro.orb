* Maestro

The Maestro is the boss of all the Agents, and possibly some non-Agent Actors
as well. It is responsible for keymap resolution and dispatching the resulting
Message (and later Action). When we need to start buffering commands,
switching to sub-keymaps, or whatever we do for vril-style commands, that'll
be here too.

It also keeps track of the current raga, and a cycle-free stack of previous
ragas--that is, pushing a raga removes any previous appearances lower in the
stack.


**** imports

#!lua
local EditAgent      = require "helm:agent/edit"
local InputEchoAgent = require "helm:agent/input-echo"
local ModalAgent     = require "helm:agent/modal"
local PagerAgent     = require "helm:agent/pager"
local PromptAgent    = require "helm:agent/prompt"
local ResultsAgent   = require "helm:agent/results"
local SearchAgent    = require "helm:agent/search"
local SessionAgent   = require "helm:agent/session"
local StatusAgent    = require "helm:agent/status"
local SuggestAgent   = require "helm:agent/suggest"

local available_ragas = {
   nerf       = require "helm:raga/nerf",
   search     = require "helm:raga/search",
   complete   = require "helm:raga/complete",
   page       = require "helm:raga/page",
   modal      = require "helm:raga/modal",
   review     = require "helm:raga/review",
   edit_title = require "helm:raga/edit-title"
}

local cluster = require "cluster:cluster"
local Actor = require "actor:actor"

local assert = assert(core.fn.assertfmt)
local table = core.table
#/lua


** Maestro

#!lua

local new, Maestro, Maestro_M = cluster.genus(Actor)
#/lua


** Keymap resolution


*** Maestro(msg), Maestro:act(msg)

Actor defines a =__call= which expects an =.act= slot bearing an ordinary
method, which is called as a task.  It can also be called directly if there
is no need to create a coroutine, as in =:delegate= below.

#!lua
function Maestro.act(maestro, msg)
   return pack(maestro:dispatch(msg))
end
#/lua


*** Maestro:delegate(msg)

  This is called on any messages yielded by a task, and provides the packed
arguments which are to be returned to that coroutine.

For Maestro, the current behavior is to dispatch anything sent to agents, and
throw anything else to Modeselektor.

#!lua
local _yield  = assert(core.thread.nest "actor" .yield)

function Maestro.delegate(maestro, msg)
   if msg.method == "pushMode" or msg.method == "popMode" or
      (msg.to and msg.to:find("^agents%.")) then
      return maestro:act(msg)
   else
      return pack(_yield(msg))
   end
end
#/lua


*** Maestro:dispatchEvent(event)

Dispatches =event= to the handler(s) specified in the active keymaps. Each
handler may answer a boolean indicating whether the event should be considered
handled, or whether execution should continue. Note that we look only for an
explicit =false= return value to fall through to the next handler. Any other
value, specifically including =nil=, stops execution.

#todo this creates problems with editing commands that return whether or not
they "did something"--successfully moved the cursor or deleted something. In
their case we don't always want to fall through.

Wildcard bindings are checked after all specific bindings, no matter which
keymap they each come from. In other words, if we have keymaps A and B, and A
contains a matching wildcard binding, but B contains a matching specific
binding, the binding from B wil be executed first (and may stop subsequent
commands from executing at all). Partly this makes things easier to implement,
since a composed keymap can just throw all the wildcards in one pile and not
worry about where they came from, but it also seems reasonable that they are
of a lower logical priority than specific bindings.

#todo We may want/need a pre-translation step where the input event is
processed to determine arguments to pass to the actual handler. Not sure
that'll come up for "simple" commands--almost by definition the event itself
is enough information for the command to figure things out--but once we start
buffering for =vril= this is where we would deal with that.

#todo Need to handle the case where the active raga (and thus the list of
active keymaps) changes during command execution, and the handler wants to
fall through. Right now we have the =modeS.action_complete= mechanism, but I'd
like to unify and remove that. The question then is how to manipulate the list
of remaining handlers. The only obvious thing is to rebuild the composed
keymap, redo the lookup, and start over from the beginning of the new list of
bindings (which is equivalent to the action_complete behavior), relying on the
handler to ensure that it is no longer *in* that list and won't be executed
again. Hard to say what the right thing to do here is...

#!lua

local clone, concat, insert = assert(table.clone),
                              assert(table.concat),
                              assert(table.insert)

local function _dispatchOnly(maestro, event)
   local handlers = maestro.raga.keymap(event)
   local tried = {}
   for _, handler in ipairs(handlers) do
      handler = clone(handler)
      -- #todo make this waaaaay more flexible
      if handler.n > 0 and not handler[handler.n] then
        handler[handler.n] = event
      end
      -- #todo using empty-string as a non-nil signpost
      -- should be able to refactor so this is not needed
      if (not handler.to) or handler.to == '' then
         handler.to = maestro.raga.target
      end
      -- #todo ugh, some way to dump a Message to a representative string?
      -- #todo also, this is assuming that all traversal is done in `to`,
      -- without nested messages--bad assumption, in general
      insert(tried, handler.method or handler.call)
      if send(handler) ~= false then
         break
      end
   end
   if #tried == 0 then
      return nil
   else
      return concat(tried, ", ")
   end
end

function Maestro.eventDispatcher(maestro, event)
   local command = _dispatchOnly(maestro, event)
   if maestro.agents.edit.contents_changed then
      maestro.raga.onTxtbufChanged()
    -- Treat contents_changed as implying cursor_changed
    -- only ever fire one of the two events
   elseif maestro.agents.edit.cursor_changed then
      maestro.raga.onCursorChanged()
   end
   maestro.agents.edit.contents_changed = false
   maestro.agents.edit.cursor_changed = false
   return command
end

function Maestro.dispatchEvent(maestro, event)
   return maestro :task() :eventDispatcher(event)
end
#/lua


** Raga management

Maestro keeps track of a stack of =raga=s, our name for modes. Yes, it's a bit
precious, but it's an important and heavily-used concept, so it's good to have
a unique name.

We'll need several basic modes and some ways to do overlay, and we need a
single source of truth as to what mode we're in.


*** _shiftMode(maestro, raga)

The =modeselektor=, as described in the prelude, is a stateful and hypermodal
=repl= environment.

=shiftMode= is the gear stick which drives the state. It encapsulates the
state changes needed to switch between them.


#!lua
local function _shiftMode(maestro, raga_name)
   -- Stash the current lexer associated with the current raga
   -- Currently we never change the lexer separate from the raga,
   -- but this will change when we start supporting multiple languages
   -- Guard against nil raga or lexer during startup
   if maestro.raga then
      maestro.raga.onUnshift()
   end
   -- Switch in the new raga and associated lexer
   maestro.raga = available_ragas[raga_name]
   maestro.agents.edit:setLexer(maestro.raga.lex)
   maestro.raga.onShift()
   -- #todo feels wrong to do this here, like it's something the raga
   -- should handle, but onShift feels kinda like it "doesn't inherit",
   -- like it's not something you should actually super-send, so there's
   -- not one good place to do this.
   maestro.agents.prompt:update(maestro.raga.prompt_char)
   return maestro
end
#/lua


*** Maestro:pushMode(raga)

Pushes a new raga to the stack, also removing any occurrence lower in the stack.

#!lua
local remove = assert(table.remove)

function Maestro.pushMode(maestro, raga)
   -- There will be at most one previous occurrence as long as nobody breaks
   -- the rules and messes with the stack outside these methods
   for i, elem in ipairs(maestro.raga_stack) do
      if elem == raga then
         remove(maestro.raga_stack, i)
         break
      end
   end
   insert(maestro.raga_stack, raga)
   return _shiftMode(maestro, raga)
end
#/lua


*** Maestro:popMode()

Pops the topmost raga from the stack, returning to whatever is below it.

#todo What do we do if the raga stack is now empty? Possibly quit helm,
and it deserves some thought as to whether this should be the _normal_ way
to quit helm.

#!lua
function Maestro.popMode(maestro)
   remove(maestro.raga_stack)
   return _shiftMode(maestro, maestro.raga_stack[#maestro.raga_stack])
end
#/lua


*** new()

#!lua
cluster.extendbuilder(new, function(_new, maestro)
   maestro.agents = {
      edit       = EditAgent(),
      input_echo = InputEchoAgent(),
      modal      = ModalAgent(),
      pager      = PagerAgent(),
      prompt     = PromptAgent(),
      results    = ResultsAgent(),
      search     = SearchAgent(),
      session    = SessionAgent(),
      status     = StatusAgent(),
      suggest    = SuggestAgent(),
   }
   -- Raga stack starts out empty, though by first paint we'll have
   -- pushed an initial raga
   maestro.raga_stack = {}
   return maestro
end)
#/lua


#!lua
return new
#/lua
