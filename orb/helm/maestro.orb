* Maestro

The Maestro is...I'm not sure yet, but for now it's where I'm going to put the
keymap-resolver logic, and when we need to start buffering commands, switching
to sub-keymaps, or whatever we do for vril-style commands, that'll be here
too.

This will eventually be the home for all the Agents, and possibly some
non-Agent Actors as well. We will eventually communicate with modeS via
coroutine yield/resume, but for now, between Agents not yet migrated and not
*having* said mechanism, we just keep a reference to modeS.


**** imports

#!lua
local input_event = require "anterm:input-event"

local EditAgent      = require "helm:agent/edit"
local InputEchoAgent = require "helm:agent/input-echo"
local ModalAgent     = require "helm:agent/modal"
local PagerAgent     = require "helm:agent/pager"
local PromptAgent    = require "helm:agent/prompt"
local ResultsAgent   = require "helm:agent/results"
local SessionAgent   = require "helm:agent/session"
local StatusAgent    = require "helm:agent/status"
local SuggestAgent   = require "helm:agent/suggest"

local Resbuf    = require "helm:buf/resbuf"
local Stringbuf = require "helm:buf/stringbuf"
local Txtbuf    = require "helm:buf/txtbuf"
#/lua


#!lua
local Maestro = meta {}
#/lua


** Keymap resolution


*** Maestro:activeKeymaps()

Determines the list of active keymaps.

#todo concept of active keymaps is extremely primitive--entirely static, just
retrieved wholesale from the raga.

#!lua
function Maestro.activeKeymaps(maestro)
   return maestro.modeS.raga.default_keymaps
end
#/lua


*** Maestro:translate(event)

Searches the active keymaps for =event=, and returns the command name to
execute, or nil if none is found.

#todo This is probably where we would go about determining arguments to the
command as well. Not sure that'll come up for "simple" commands--almost by
definition the event itself is enough information for the command to figure
things out--but once we start buffering for =vril= this is where we would deal
with that. Maybe if we come up with any args we *don't* actually hand the raw
event to the command? In the =vril= case it's pretty useless really... In that
case we would need to return the event as the sole arg in the case where we
*do* want it, rather than the calling code passing it unconditionally.

#!lua
function Maestro.translate(maestro, event)
   local keymaps = maestro:activeKeymaps()
   if not keymaps then return nil end
   local event_string = input_event.serialize(event)
   for _, keymap in ipairs(keymaps) do
      if keymap[event_string] then
         return keymap[event_string]
      end
   end
   return nil
end
#/lua


*** Maestro:dispatch(event, command[, args])

Given a command name (and optional arguments), finds the function implementing
the command and executes it.

#todo should the event always be passed like this, or should that be handled
by the definition of the command somehow?

#!lua
function Maestro.dispatch(maestro, event, command, args)
   return maestro.modeS.raga[command](maestro, event, args)
end
#/lua


*** Maestro:bindZone(zone_name, agent_name, buf_class, cfg)

Changes the Zone =zone_name= to display content from the Agent named =agent_name=.

#todo the buffer class and cfg is generally fixed for any given agent, having them
as arguments is probably not the best choice.

#!lua
function Maestro.bindZone(maestro, zone_name, agent_name, buf_class, cfg)
   local zone = maestro.zones[zone_name]
   local agent = maestro.agents[agent_name]
   zone:replace(buf_class(agent:window(), cfg))
end
#/lua


*** new(modeS)

#!lua
local borrowmethod = assert(require "core:cluster/actor" . borrowmethod)
local function new(modeS)
   local maestro = meta(Maestro)
   -- #todo this is temporary until we sort out communication properly
   maestro.modeS = modeS
   -- Zoneherd we will keep a reference to (maybe the only reference) even
   -- once we untangle from modeS, so start referring to it directly now
   maestro.zones = modeS.zones
   local agents = {
      edit       = EditAgent(),
      input_echo = InputEchoAgent(),
      modal      = ModalAgent(),
      pager      = PagerAgent(),
      prompt     = PromptAgent(),
      results    = ResultsAgent(),
      session    = SessionAgent(),
      status     = StatusAgent(),
      suggest    = SuggestAgent()
   }
   maestro.agents = agents
   -- Set up Agent <-> Agent interaction via borrowmethod
   local function borrowto(dst, src, name)
      dst[name] = borrowmethod(src, name)
   end
   borrowto(agents.suggest, agents.edit, "tokens")
   borrowto(agents.suggest, agents.edit, "replaceToken")
   borrowto(agents.prompt,  agents.edit, "continuationLines")
   -- #todo this is just...ugly
   -- it is, the signature should be something like this:
   -- agents.prompt.editTouched = getter(agents.edit, "touched")
   -- which is pretty trivial, I'll write it on core right now
   agents.prompt.editTouched = borrowmethod(agents.edit,
                                 function(agent) return agent.touched end)
   -- Set up common Agent -> Zone bindings
   -- Note we don't do results here because that varies from raga to raga
   -- The Txtbuf also needs a source of "suggestions" (which might be
   -- history-search results instead), but that too is raga-dependent
   maestro:bindZone("command",  "edit",       Txtbuf)
   maestro:bindZone("popup",    "pager",      Resbuf,    { scrollable = true })
   maestro:bindZone("prompt",   "prompt",     Stringbuf)
   maestro:bindZone("modal",    "modal",      Resbuf)
   maestro:bindZone("status",   "status",     Stringbuf)
   maestro:bindZone("stat_col", "input_echo", Resbuf)
   maestro:bindZone("suggest",  "suggest",    Resbuf)
   return maestro
end
#/lua


#!lua
return new
#/lua
