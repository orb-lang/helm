* Maestro

The Maestro is...I'm not sure yet, but for now it's where I'm going to put the
keymap-resolver logic, and when we need to start buffering commands, switching
to sub-keymaps, or whatever we do for vril-style commands, that'll be here
too.

This will eventually be the home for all the Agents, and possibly some
non-Agent Actors as well. We will eventually communicate with modeS via
coroutine yield/resume, but for now, between Agents not yet migrated and not
*having* said mechanism, we just keep a reference to modeS.


**** imports

#!lua
local EditAgent      = require "helm:agent/edit"
local InputEchoAgent = require "helm:agent/input-echo"
local ModalAgent     = require "helm:agent/modal"
local PagerAgent     = require "helm:agent/pager"
local PromptAgent    = require "helm:agent/prompt"
local ResultsAgent   = require "helm:agent/results"
local SearchAgent    = require "helm:agent/search"
local SessionAgent   = require "helm:agent/session"
local StatusAgent    = require "helm:agent/status"
local SuggestAgent   = require "helm:agent/suggest"

local assert = assert(core.fn.assertfmt)
local table = core.table
#/lua


** Maestro

#!lua
local cluster = require "cluster:cluster"
local Keymap = require "helm:keymap"

local Actor = require "actor:actor"

local new, Maestro, Maestro_M = cluster.genus(Actor)
#/lua


** Keymap resolution


*** Maestro(msg), Maestro:act(msg)

Actor defines a =__call= which expects an =.act= slot bearing an ordinary
method, which is called as a task.  It can also be called directly if there
is no need to create a coroutine, as in =:delegate= below.

#!lua
function Maestro.act(maestro, msg)
   return pack(maestro:dispatch(msg))
end
#/lua


*** Maestro:delegate(msg)

  This is called on any messages yielded by a task, and provides the packed
arguments which are to be returned to that coroutine.

For Maestro, the current behavior is to dispatch anything sent to agents, and
throw anything else to Modeselektor.

#!lua
local _yield  = assert(core.thread.nest "actor" .yield)

function Maestro.delegate(maestro, msg)
   local to = msg.sendto or msg.to
   if to and to:find("^agents%.") then
      return maestro:act(msg)
   else
      return pack(_yield(msg))
   end
end
#/lua


*** Maestro:dispatchEvent(event)

Dispatches =event= to the handler(s) specified in the active keymaps. Each
handler may answer a boolean indicating whether the event should be considered
handled, or whether execution should continue. Note that we look only for an
explicit =false= return value to fall through to the next handler. Any other
value, specifically including =nil=, stops execution.

#todo this creates problems with editing commands that return whether or not
they "did something"--successfully moved the cursor or deleted something. In
their case we don't always want to fall through.

Wildcard bindings are checked after all specific bindings, no matter which
keymap they each come from. In other words, if we have keymaps A and B, and A
contains a matching wildcard binding, but B contains a matching specific
binding, the binding from B wil be executed first (and may stop subsequent
commands from executing at all). Partly this makes things easier to implement,
since a composed keymap can just throw all the wildcards in one pile and not
worry about where they came from, but it also seems reasonable that they are
of a lower logical priority than specific bindings.

#todo We may want/need a pre-translation step where the input event is
processed to determine arguments to pass to the actual handler. Not sure
that'll come up for "simple" commands--almost by definition the event itself
is enough information for the command to figure things out--but once we start
buffering for =vril= this is where we would deal with that.

#todo Need to handle the case where the active raga (and thus the list of
active keymaps) changes during command execution, and the handler wants to
fall through. Right now we have the =modeS.action_complete= mechanism, but I'd
like to unify and remove that. The question then is how to manipulate the list
of remaining handlers. The only obvious thing is to rebuild the composed
keymap, redo the lookup, and start over from the beginning of the new list of
bindings (which is equivalent to the action_complete behavior), relying on the
handler to ensure that it is no longer *in* that list and won't be executed
again. Hard to say what the right thing to do here is...

#!lua

local clone, concat, insert = assert(table.clone),
                              assert(table.concat),
                              assert(table.insert)

local function _dispatchOnly(maestro, event)
   local handlers = maestro.raga.keymap(event)
   local tried = {}
   for _, handler in ipairs(handlers) do
      handler = clone(handler)
      -- #todo make this waaaaay more flexible
      if handler.n > 0 then
         handler[handler.n] = event
      end
      -- #todo using empty-string as a non-nil signpost
      -- should be able to refactor so this is not needed
      if (not handler.to) or handler.to == '' then
         handler.to = maestro.raga.target
      end
      -- #todo ugh, some way to dump a Message to a representative string?
      -- #todo also, this is assuming that all traversal is done in `sendto`,
      -- without nested messages--bad assumption, in general
      insert(tried, handler.method or handler.call)
      if maestro:dispatch(handler) ~= false then
         break
      end
   end
   if #tried == 0 then
      return nil
   else
      return concat(tried, ", ")
   end
end

function Maestro.eventDispatcher(maestro, event)
   local command = _dispatchOnly(maestro, event)
   if maestro.agents.edit.contents_changed then
      maestro.raga.onTxtbufChanged()
    -- Treat contents_changed as implying cursor_changed
    -- only ever fire one of the two events
   elseif maestro.agents.edit.cursor_changed then
      maestro.raga.onCursorChanged()
   end
   maestro.agents.edit.contents_changed = false
   maestro.agents.edit.cursor_changed = false
   return command
end

function Maestro.dispatchEvent(maestro, event)
   return maestro :task() :eventDispatcher(event)
end
#/lua


*** new()

#!lua
cluster.extendbuilder(new, function(_new, maestro)
   maestro.agents = {
      edit       = EditAgent(),
      input_echo = InputEchoAgent(),
      modal      = ModalAgent(),
      pager      = PagerAgent(),
      prompt     = PromptAgent(),
      results    = ResultsAgent(),
      search     = SearchAgent(),
      session    = SessionAgent(),
      status     = StatusAgent(),
      suggest    = SuggestAgent(),
   }
   return maestro
end)
#/lua


#!lua
return new
#/lua
