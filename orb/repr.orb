* Repr


=repr= is our general-purpose pretty-printer.

This is undergoing a huge refactor to make it iterable, so it yields one
line at a time and won't get hung up on enormous tables.

Currently we yield most things, and are working our way toward providing an
iterator that itself returns one line at a time until it reaches the end of
the repr.


**** imports

#!lua
local a = require "anterm"

local core = require "core"

local C = require "color"
#/lua


**** setup

#!lua

local repr = {}

local hints = C.color.hints

local c = C.color
#/lua


*** anti_G

In order to provide names for values, we want to trawl through =_G= and
acquire them.  This table is from value to key where =_G= is key to value,
hence, =anti_G=.

#!lua
local anti_G = { _G = "_G" }
#/lua

Now to populate it:


*** C.allNames()

Ransacks =_G= looking for names to put on things.

To really dig out a good name for metatables we're going to need to write
some kind of reflection function that will dig around in upvalues to find
local names for things.


**** tie_break(old, new)

A helper function to decide which name is better.

#!lua
local function tie_break(old, new)
   return #old > #new
end

local function addName(t, aG, pre)
   pre = pre or ""
   aG = aG or anti_G
   if pre ~= "" then
      pre = pre .. "."
   end
   for k, v in pairs(t) do
      local T = type(v)
      if (T == "table") then
         local key = pre ..
            (type(k) == "string" and k or "<" .. type(k) .. ">")
         if not aG[v] then
            aG[v] = key
            if not (pre == "" and k == "package") then
               addName(v, aG, key)
            end
         else
            local kv = aG[v]
            if tie_break(kv, key) then
               -- quadradic lol
               aG[v] = key
               addName(v, aG, key)
            end
         end
         local _M = getmetatable(v)
         local _M_id = _M and "⟨" .. key.. "⟩" or ""
         if _M then
            if not aG[_M] then
               addName(_M, aG, _M_id)
               aG[_M] = _M_id
            else
               local aG_M_id = aG[_M]
               if tie_break(aG_M_id, _M_id) then
                  addName(_M, aG, _M_id)
                  aG[_M] = _M_id
               end
            end
         end
      elseif T == "function" or
         T == "thread" or
         T == "userdata" then
         aG[v] = pre .. k
      end
   end
   return aG
end
#/lua


**** repr.allNames(), repr.clearNames()

The trick here is that we scan =package.loaded= after =_G=, which gives
better names for things.

#!lua
function repr.allNames(tab)
   tab = tab or _G
   return addName(package.loaded, addName(tab))
end

function repr.clearNames()
   anti_G = {_G = "_G"}
   return anti_G
end
#/lua


*** tabulator

This is fundamentally [[Tim Caswell's][https://github.com/creationix]] code.

I've dressed it up a bit. Okay, a lot.

#todo add rainbow braces

#!lua
local ts, ts_coro

local SORT_LIMIT = 500  -- This won't be necessary #todo remove

local coro = coro or coroutine

local yield, wrap = coro.yield, coro.wrap

local concat, insert, remove = table.concat, table.insert, table.remove

local function _keysort(a, b)
   if (type(a) == "string" and type(b) == "string")
      or (type(a) == "number" and type(b) == "number") then
      return a < b
   elseif type(a) == "number" and type(b) == "string" then
      return true
   elseif type(a) == "string" and type(b) == "number" then
      return false
   else
      return false
   end
end
#/lua


*** _yieldReprs(tab, disp)

I want to deliver =__repr=s from inside the funky coroutine brew,
because, well, because. =ts= is meant to be general.

I also want a lot of flexibility in how reprs are written, so we need to
handle several cases.

We're going to start with returning a string, and returning an iterator.

I might get around to returning tables with tokens in them and other intel,
I might not; I do have plans that are broader than merely writing an
incredibly intricate repl.

#!lua
local function _yieldReprs(tab, phrase)
   local _repr = getmetatable(tab).__repr
   assert(c, "must have a value for c")
   local repr = _repr(tab, phrase, c)
   local yielder
   if type(repr) == "string" then
      yielder = string.lines(repr)
   else
      yielder = repr
   end
   while true do
      local line, len = yielder()
      if line ~= nil then
         len = len or #line
         yield(line, len, "repr_line")
      else
         break
      end
   end
end

#/lua

*** _tabulate(tab, depth, cycle, phrase)

This =yield()s= pieces of a table, recursively, one at a time.

Second return value is the printed width, third, if any, is a string
representing what we're opening and/or closing.

#!lua
local O_BRACE = function() return c.base "{" end
local C_BRACE = function() return c.base "}" end
local COMMA, COM_LEN = function() return c.base ", " end, 2

local function _tabulate(tab, depth, cycle, phrase)
   cycle = cycle or {}
   depth = depth or 0
   if type(tab) ~= "table" then
      ts_coro(tab, nil, phrase)
      return nil
   end
   if depth > C.depth or cycle[tab] then
      ts_coro(tab, "tab_name", phrase)
      return nil
   end
   cycle[tab] = true
   -- if we have a metatable, get it first
   local _M = getmetatable(tab)
   if _M then
      ---[[special case tables with __repr
      if _M.__repr then
         _yieldReprs(tab, phrase)
         return nil
      end
      --]]
      --otherwise print the metatable normally
      ts_coro(tab, "mt", phrase)
      yield(c.base(" = "), 3)
      _tabulate(_M, depth + 1, cycle, phrase)
   end
   -- Check to see if this is an array
   local is_array = true
   local i = 1
   for k,_ in pairs(tab) do
      is_array = is_array and (k == i)
      i = i + 1
   end

   local keys
   if not is_array then
      keys = table.keys(tab)
      if #keys <= SORT_LIMIT then
         table.sort(keys, _keysort)
      end
   else
      keys = tab
   end
   yield(O_BRACE(), 1, (is_array and "array" or "map"))

   for j, key in ipairs(keys) do
      if is_array then
         _tabulate(key, depth + 1, cycle, phrase)
      else
         val = tab[key]
         if type(key) == "string" and key:find("^[%a_][%a%d_]*$") then
            ts_coro(key, nil, phrase)
            yield(c.base(" = "), 3)
         else
            yield(c.base("["), 1)
               -- we want names or hashes for any lvalue table,
               -- 100 triggers this
            _tabulate(key, 100, cycle, phrase)
            yield(c.base("] = "), 4)
         end
         _tabulate(val, depth + 1, cycle, phrase)
      end
   end
   yield(C_BRACE(), 1, "end")
   return nil
end
#/lua

line-buffer goes here

needs to decide when things are 'wide enough' so each yield needs to return
=str, len, done=, where =str= is the fragment of string, =len= is a number
representing its printable width (don't @ me) and =done= is a boolean for if
this is the last bit of the repr of a given thing. Table, userdata, what
have you.


*** tabulate(tab, depth, cycle)

This is going to undergo several metamorpheses as we make progress.

For now, we have the =_tabulate= function yielding pieces of a table as it
generates them, as well as the printed length (not valid across all Unicode,
but let's shave one yak at a time, shall we?).

Now for the real fun: we need to keep track of indentation levels, and break
'long' maps and arrays up into chunks.

We're yielding a "map" string for k/v type tables and an "array" string for
array-type, and just "end" for the end of either.  What we need is a classic
push-down automaton, and some kind of buffer that's more sophisticated than
just tossing everything into a =phrase= table.


**** oneLine(phrase, long)

Returns one line from =phrase=. =long= determines whether we're doing long
lines or short lines, which is determined by =lineGen=, the caller.

#!lua
local function _disp(phrase)
   local displacement = 0
   for i = 1, #phrase.disp do
      displacement = displacement + phrase.disp[i]
   end
   return displacement
end

local function _spill(phrase, line, disps)
   assert(#line == #disps, "#line must == #disps")
   for i = 0, #line do
      phrase[i] = line[i]
      phrase.disp[i] = disps[i]
   end
   phrase.yielding = true
   return false
end

local function oneLine(phrase, long)
   local line = {}
   local disps = {}
   if #phrase == 0 then
      phrase.yielding = true
      return false
   end
   while true do
      local frag, disp = remove(phrase, 1), remove(phrase.disp, 1)
      -- remove commas before closing braces
      if frag == COMMA() then
         if phrase[1] == C_BRACE() then
            frag = ""
            disp = 0
         elseif #phrase == 0 then
            insert(line, frag)
            insert(disps, disp)
            return _spill(phrase, line, disps)
         end
      end
      -- and after opening braces
      if frag == O_BRACE() and phrase[1] == COMMA() then
         remove(phrase, 1)
         remove(phrase.disp, 1)
      end
      -- pad with a space inside the braces
      if frag == C_BRACE() then
         insert(line, " ")
         insert(disps, 1)
      end
      insert(line, frag)
      insert(disps, disp)
      if frag == O_BRACE() then
         insert(line, " ")
         insert(disps, 1)
      end
      -- adjust stack for next round
      if frag == O_BRACE() then
         phrase.level = phrase.level + 1
      elseif frag == C_BRACE() then
         phrase.level = phrase.level - 1
      end
      if (frag == COMMA() and long)
         or (#phrase == 0 and not phrase.more) then
         local indent = phrase.dent == 0 and "" or ("  "):rep(phrase.dent)
         phrase.dent = phrase.level
         return indent.. concat(line)
      elseif #phrase == 0 and phrase.more then
         -- spill our fragments back
         return _spill(phrase, line, disps)
      end
   end
end
#/lua


**** lineGen

This function sets up an iterator, which returns one line at a time of the
table.

#!lua
assert(readOnly, "must have readOnly from core")

local function _remains(phrase)
   return phrase.width - _disp(phrase)
end

local function lineGen(tab, depth, cycle, disp_width)
   assert(disp_width, "lineGen must have a disp_width")
   local phrase = {}
   phrase.disp = {}
   local iter = wrap(_tabulate)
   local stage = {}              -- stage stack
   phrase.remains = _remains
   phrase.width = disp_width
   phrase.stage = stage
   phrase.level = 0              -- how many levels of recursion are we on
   phrase.dent = 0               -- indent level (lags by one line)
   phrase.more = true            -- are their more frags to come
   local map_counter = 0         -- counts where commas go
   phrase.yielding = true
   local long = false            -- long or short printing

   -- make a read-only phrase table for fetching values
   local phrase_ro = readOnly(phrase)
   -- return an iterator function which yields one line at a time.
   return function()
      ::start::
      while phrase.yielding do
         local line, len, event = iter(tab, depth, cycle, phrase_ro)
         if line == nil then
            phrase.yielding = false
            phrase.more = false
            break
         end
         phrase[#phrase + 1] = line
         phrase.disp[#phrase.disp + 1] = len
         if event then
            if event == "repr_line" then
               -- remove from the phrase and send directly
               phrase[#phrase] = nil
               phrase.disp[#phrase.disp] = nil
               return line
            end
            if event == "map" then
               map_counter = 0
            end
            if event == "array" or event == "map" then
               insert(stage, event)
            elseif event == "end" then
               remove(stage)
               if stage[#stage] == "map" then
                  map_counter = 3
               end
            elseif event == "mt_name" then
               -- gotta drop that comma
               map_counter = 1
            end
         end

         -- special-case for non-string values, which
         -- yield an extra piece
         if line == c.base("] = ") then
            map_counter = map_counter - 1
         end
         -- insert commas
         if stage[#stage] =="map"  then
            if map_counter == 3 then
               phrase[#phrase + 1] = COMMA()
               phrase.disp[#phrase.disp + 1] = COM_LEN
               map_counter = 1
            else
               map_counter = map_counter + 1
            end
         elseif stage[#stage] == "array"then
            phrase[#phrase + 1] = COMMA()
            phrase.disp[#phrase.disp + 1] = COM_LEN
            map_counter = map_counter + 1
         end
         if _disp(phrase) >= disp_width then
            long = true
            phrase.yielding = false
            break
         else
            long = false
         end
      end
      if #phrase > 0 then
         local ln = oneLine(phrase, long)
         if ln then
            return ln
         else
            goto start
         end
      elseif phrase.more == false then
         return nil
      else
         phrase.yielding = true
         goto start
      end
   end
end

function repr.lineGen(tab, disp)
   disp = disp or 80
   return lineGen(tab, nil, nil, disp)
end
#/lua


*** repr.lineGenBW(tab, depth, cycle, disp_width)

This generates lines, but with no color.

To keep it from interfering with other uses of the =repr= library, we turn
color off and back on with each line.

Global state is annoying!

I mean, module-local global.

But still.

#!lua
function repr.lineGenBW(tab, disp_width)
   local lg = lineGen(tab, nil, nil, disp_width)
   return function()
      c = C.no_color
      local line = lg()
      if line ~= nil then
         c = C.color
         return line
      end
      c = C.color
      return nil
   end
end
#/lua

#!lua
local function tabulate(tab, depth, cycle, disp_width)
   disp_width = disp_width or 80
   local phrase = {}
   for line in lineGen(tab, depth, cycle, disp_width) do
      phrase[#phrase + 1] = line
   end
   return concat(phrase, "\n")
end
#/lua


*** string and cdata pretty-printing

We make a small wrapper function which resets string color in between
escapes, then gsub the daylights out of it.

#!lua
local find, sub, gsub, byte = string.find, string.sub,
                              string.gsub, string.byte

local e = function(str)
   return c.stresc .. str .. c.string
end

-- Turn control characters into their byte rep,
-- preserving escapes
local function ctrl_pr(str)
   if byte(str) ~= 27 then
      return e("\\" .. byte(str))
   else
      return str
   end
end

local function scrub (str)
   return str:gsub("\27", e "\\x1b")
             :gsub('"',  e '\\"')
             :gsub("'",  e "\\'")
             :gsub("\a", e "\\a")
             :gsub("\b", e "\\b")
             :gsub("\f", e "\\f")
             :gsub("\n", e "\\n")
             :gsub("\r", e "\\r")
             :gsub("\t", e "\\t")
             :gsub("\v", e "\\v")
             :gsub("%c", ctrl_pr)
end
#/lua


Note: the reflect library appears to be broken for LuaJIT 2.1 so we're
not going to use it.

I'm leaving in the code for now, because I'd like to repair and use it...

lol

#Todo fix

#!lua
local function c_data(value, str, phrase)
   --local meta = reflect.getmetatable(value)
   yield(str, #str)
   --[[
   if meta then
      yield(c.base " = ", 3)
      ts_coro(meta, nil, phrase)
   end
   --]]
end
#/lua


*** ts_coro

Lots of small, nice things in this one.

#!lua
ts_coro = function (value, hint, phrase)
   local strval = tostring(value) or ""
   local len = #strval
   local str = scrub(strval)

   -- For cases more specific than mere type,
   -- we have hints:
   if hint then
      if hint == "tab_name" then
         local tab_name = anti_G[value] or "t:" .. sub(str, -6)
         len = #tab_name
         yield(c.table(tab_name), len)
         return nil
      elseif hint == "mt" then
         local mt_name = anti_G[value] or "mt:" .. sub(str, -6)
         len = #mt_name + 2
         yield(c.metatable("⟨" .. mt_name .. "⟩"), len, "mt_name")
         return nil
      elseif hints[hint] then
         yield(hints[hint](str), len)
         return nil
      elseif c[hint] then
         yield(c[hint](str), len)
         return nil
      end
   end

   local typica = type(value)

   if typica == "table" then
      _tabulate(value, nil, nil, phrase)
      return nil
   elseif typica == "function" then
      local f_label = sub(str,11)
      f_label = sub(f_label,1,5) == "built"
                and f_label
                or "f:" .. sub(str, -6)
      local func_name = anti_G[value] or f_label
      len = #func_name
      str = c.func(func_name)
   elseif typica == "boolean" then
      str = value and c.truth(str) or c.falsehood(str)
   elseif typica == "string" then
      if value == "" then
         str = c.string('""')
         len = 2
      else
         str = c.string(str)
      end
   elseif typica == "number" then
      str = c.number(str)
   elseif typica == "nil" then
      str = c.nilness(str)
   elseif typica == "thread" then
      local coro_name = anti_G[value] and "coro:" .. anti_G[value]
                                      or  "coro:" .. sub(str, -6)
      len = #coro_name
      str = c.thread(coro_name)
   elseif typica == "userdata" then
      if anti_G[value] then
         str = c.userdata(anti_G[value])
         len = #anti_G[value]
      else
         local name = find(str, ":")
         if name then
            name = sub(str, 1, name - 1)
            len = #name
            str = c.userdata(name)
         else
            str = c.userdata(str)
         end
      end
   elseif typica == "cdata" then
      if anti_G[value] then
         str = c.cdata(anti_G[value])
         len = anti_G[value]
      else
         str = c.cdata(str)
      end
      str, len = c_data(value, str)
   end
   yield(str, len)
end

repr.ts = tabulate
#/lua

#nb: the below is broken, #todo fix

#!lua
function repr.ts_bw(value)
   c = C.no_color
   local to_string = tabulate(value)
   c = C.color
   return to_string
end
#/lua

#!lua
return repr
#/lua


