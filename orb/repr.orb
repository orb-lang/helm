* Repr


  =repr= is our general-purpose pretty-printer.

This is undergoing a huge refactor to make it iterable, so it yields one
line at a time and won't get hung up on enormous tables.

Currently we yield most things, and are working our way toward providing an
iterator that itself returns one line at a time until it reaches the end of
the repr.


**** imports

#!lua
local a = require "anterm"

local core = require "core"

local reflect = require "reflect"

local C = require "color"
#/lua


**** setup

#!lua

local repr = {}

local hints = C.color.hints

local c = C.color
#/lua


*** anti_G

In order to provide names for values, we want to trawl through =_G= and
acquire them.  This table is from value to key where =_G= is key to value,
hence, =anti_G=.

#!lua
local anti_G = { _G = "_G" }
#/lua

Now to populate it:


*** C.allNames()

Ransacks =_G= looking for names to put on things.

To really dig out a good name for metatables we're going to need to write
some kind of reflection function that will dig around in upvalues to find
local names for things.


**** tie_break(old, new)

A helper function to decide which name is better.

#!lua
local function tie_break(old, new)
   return #old > #new
end


local function addName(t, aG, pre)
   pre = pre or ""
   aG = aG or anti_G
   if pre ~= "" then
      pre = pre .. "."
   end
   for k, v in pairs(t) do
      local T = type(v)
      if (T == "table") then
         local key = pre .. (type(k) == "string" and k or "<" .. type(k) .. ">")
         if not aG[v] then
            aG[v] = key
            if not (pre == "" and k == "package") then
               addName(v, aG, key)
            end
         else
            local kv = aG[v]
            if tie_break(kv, key) then
               -- quadradic lol
               aG[v] = key
               addName(v, aG, key)
            end
         end
         local _M = getmetatable(v)
         local _M_id = _M and "⟨" .. key.. "⟩" or ""
         if _M then
            if not aG[_M] then
               addName(_M, aG, _M_id)
               aG[_M] = _M_id
            else
               local aG_M_id = aG[_M]
               if tie_break(aG_M_id, _M_id) then
                  addName(_M, aG, _M_id)
                  aG[_M] = _M_id
               end
            end
         end
      elseif T == "function" or
         T == "thread" or
         T == "userdata" then
         aG[v] = pre .. k
      end
   end
   return aG
end
#/lua


**** repr.allNames(), repr.clearNames()

The trick here is that we scan =package.loaded= after =_G=, which gives
better names for things.

#!lua
function repr.allNames(tab)
   tab = tab or _G
   return addName(package.loaded, addName(tab))
end

function repr.clearNames()
   anti_G = {_G = "_G"}
   return anti_G
end
#/lua

*** tabulator

This is fundamentally [[Tim Caswell's][https://github.com/creationix]] code.

I've dressed it up a bit. Okay, a lot.

#todo add rainbow braces

#!lua
local ts, ts_coro

local SORT_LIMIT = 500  -- This won't be necessary #todo remove

local coro = coro or coroutine

local yield, wrap = coro.yield, coro.wrap

local concat, insert, remove = table.concat, table.insert, table.remove

local function _keysort(a, b)
   if (type(a) == "string" and type(b) == "string")
      or (type(a) == "number" and type(b) == "number") then
      return a < b
   elseif type(a) == "number" and type(b) == "string" then
      return true
   elseif type(a) == "string" and type(b) == "number" then
      return false
   else
      return false
   end
end
#/lua


*** _tabulate(tab, depth, cycle)

This =yield()s= pieces of a table, recursively, one at a time.

Second return value is the printed width, third, if any, is a string
representing what we're opening and/or closing.

At this point it works, time to start breaking it out into an iterator.

#!lua
local O_BRACE = c.base "{"
local C_BRACE = c.base "}"
local COMMA, COM_LEN = c.base ", ", 2

local tabulate -- this is a mess but will have to do for now

local function _tabulate(tab, depth, cycle)
   cycle = cycle or {}
   depth = depth or 0
   if type(tab) ~= "table" then
      ts_coro(tab)
      return nil
   end
   if depth > C.depth or cycle[tab] then
      yield(ts(tab, "tab_name"))
      return nil
   end

   cycle[tab] = true
   -- Check to see if this is an array
   local is_array = true
   local i = 1
   for k,_ in pairs(tab) do
      is_array = is_array and (k == i)
      i = i + 1
   end
   -- if we have a metatable, get it first
   local mt = ""
   local _M = getmetatable(tab)
   if _M then
      -- fix metatable stuff

      local mt_rep, mt_len = ts(tab, "mt")
      yield(mt_rep, mt_len)
      yield(c.base(" = "), 3)
      _tabulate(_M, depth + 1, cycle)
   end
   local estimated = 0
   local keys
   if not is_array then
      keys = table.keys(tab)
      if #keys <= SORT_LIMIT then
         table.sort(keys, _keysort)
      else
         -- bail
         yield("{ !!! }", 7, "end"); return nil
      end
   else
      if #tab > SORT_LIMIT then
         yield("{ #!!! }", 8, "end"); return nil
      end
      keys = tab
   end
   yield(O_BRACE, 1, (is_array and "array" or "map"))
   for j, key in ipairs(keys) do
      if is_array then
         _tabulate(key, depth + 1, cycle)
      else
         val = tab[key]
         if type(key) == "string" and key:find("^[%a_][%a%d_]*$") then
            ts_coro(key)
            yield(c.base(" = "), 3)
         else
            yield(c.base("["), 1)
               -- we want names or hashes for any lvalue table,
               -- 100 triggers this
            _tabulate(key, 100, cycle)
            yield(c.base("] = "), 4)
         end
         _tabulate(val, depth + 1, cycle)
      end
   end
   yield(C_BRACE, 1, "end")
   return nil
end
#/lua

line-buffer goes here

needs to decide when things are 'wide enough' so each yield needs to return
=str, len, done=, where =str= is the fragment of string, =len= is a number
representing its printable width (don't @ me) and =done= is a boolean for if
this is the last bit of the repr of a given thing. Table, userdata, what
have you.


*** tabulate(tab, depth, cycle)

This is going to undergo several metamorpheses as we make progress.

For now, we have the =_tabulate= function yielding pieces of a table as it
generates them, as well as the printed length (not valid across all Unicode,
but let's shave one yak at a time, shall we?).

Now for the real fun: we need to keep track of indentation levels, and break
'long' maps and arrays up into chunks.

We're yielding a "map" string for k/v type tables and an "array" string for
array-type, and just "end" for the end of either.  What we need is a classic
push-down automaton, and some kind of buffer that's more sophisticated than
just tossing everything into a =phrase= table.


**** oneLine(phrase, long)

Returns one line from =phrase=. =long= determines whether we're doing long
lines or short lines, which is determined by =lineGen=, the caller.

#!lua
local function oneLine(phrase, long)
   long = long or true
   local first_line = phrase.untouched
   phrase.untouched = false
   local closed = false
   local line = {}
   while true do
      local frag = remove(phrase, 1)
      -- remove commas before closing braces
      if frag == COMMA and phrase[1] == C_BRACE then
         frag = ""
      end
      -- and after opening braces
      if frag == O_BRACE and phrase[1] == COMMA then
         remove(phrase, 1)
      end
      -- pad with a space inside the braces
      if frag == C_BRACE then
         insert(line, " ")
      end
      insert(line, frag)
      if frag == O_BRACE then
         insert(line, " ")
      end
      -- adjust stack for next round
      if frag == O_BRACE then
         phrase.level = phrase.level + 1
      elseif frag == C_BRACE then
         phrase.level = phrase.level - 1
      end
      if (frag == COMMA and long) or #phrase == 0 then
         local indent = first_line and "" or ("  "):rep(phrase.dent)
         phrase.dent = phrase.level
         return indent .. concat(line)
      end
   end
end
#/lua

**** lineGen

This function sets up an iterator, which returns one line at a time of the
table.

#!lua
local function lineGen(tab, depth, cycle)
   local phrase = {}
   phrase.disp = {}
   phrase.untouched = true       -- don't indent at the beginning
   local iter = wrap(_tabulate)
   local stage = {}              -- stage stack
   phrase.stage = stage
   phrase.level = 0              -- how many levels of recursion are we on
   phrase.dent = 0               -- indent level (lags by one line)
   local map_counter = 0         -- this counts where commas go
   local disp = 0                -- column displacement
   local yielding = true
   -- return an iterator function that currently yields the entire
   -- line but will eventually yield one line at a time.
   return function()
      while yielding do
         local line, len, event = iter(tab, depth, cycle)
         if line == nil then
            yielding = false
            ---[[
            if phrase[#phrase] == COMMA then
               remove(phrase)
            end
            --]]
            break
         end
         phrase[#phrase + 1] = line
         phrase.disp[#phrase.disp + 1] = len
         disp = disp + len
         if event then
            if event == "map" then
               map_counter = 0
            end
            if event == "array" or event == "map" then
               insert(stage, event)
            elseif event == "end" then
               remove(stage)
               if stage[#stage] == "map" then
                  map_counter = 3
               end
            end
         end
         -- special-case for non-string values, which
         -- yield an extra piece
         if line == c.base("] = ") then
            map_counter = map_counter - 1
         end
         -- insert commas
         if stage[#stage] =="map"  then
            if map_counter == 3 then
               phrase[#phrase + 1] = COMMA
               disp = disp + COM_LEN
               phrase.disp[#phrase.disp + 1] = COM_LEN
               map_counter = 1
            else
               map_counter = map_counter + 1
            end
         elseif stage[#stage] == "array"then
            phrase[#phrase + 1] = COMMA
            phrase.disp[#phrase.disp + 1] = COM_LEN
            disp = disp + COM_LEN
            map_counter = map_counter + 1
         end
      end
      if #phrase > 0 then
         return oneLine(phrase)
      else
         return nil
      end
   end
end

tabulate = function(tab, depth, cycle)
   local phrase = {}
   for line in lineGen(tab, depth, cycle) do
      phrase[#phrase + 1] = line
   end
   return concat(phrase, "\n")
end
#/lua


*** string and cdata pretty-printing

We make a small wrapper function which resets string color in between
escapes, then gsub the daylights out of it.

#!lua
local find, sub, gsub, byte = string.find, string.sub,
                              string.gsub, string.byte

local e = function(str)
   return c.stresc .. str .. c.string
end

-- Turn control characters into their byte rep,
-- preserving escapes
local function ctrl_pr(str)
   if byte(str) ~= 27 then
      return e("\\" .. byte(str))
   else
      return str
   end
end

local function scrub (str)
   return str:gsub("\27", e "\\x1b")
             :gsub('"',  e '\\"')
             :gsub("'",  e "\\'")
             :gsub("\a", e "\\a")
             :gsub("\b", e "\\b")
             :gsub("\f", e "\\f")
             :gsub("\n", e "\\n")
             :gsub("\r", e "\\r")
             :gsub("\t", e "\\t")
             :gsub("\v", e "\\v")
             :gsub("%c", ctrl_pr)
end
#/lua

#!lua
local function c_data(value, str)
   local meta = reflect.getmetatable(value)
   if meta then
      local mt_str, meta_len = ts(meta)
      meta_len = meta_len or #mt_str
      return str .. " = " .. mt_str, meta_len
   else
      return str, #str
   end
end
#/lua

*** ts

Lots of small, nice things in this one.

#!lua
ts_coro = function (value, hint)
   local strval = tostring(value) or ""
   local len = #strval
   local str = scrub(strval)

   -- For cases more specific than mere type,
   -- we have hints:
   if hint then
      if hint == "tab_name" then
         local tab_name = anti_G[value] or "t:" .. sub(str, -6)
         len = #tab_name
         yield(c.table(tab_name), len)
      elseif hint == "mt" then
         local mt_name = anti_G[value] or "mt:" .. sub(str, -6)
         len = #mt_name + 2
         yield(c.metatable("⟨" .. mt_name .. "⟩"), len); return nil
      elseif hints[hint] then
         yield(hints[hint](str), len)
      elseif c[hint] then
         yield(c[hint](str), len)
      end
   end

   local typica = type(value)

   if typica == "table" then
      -- check for a __repr metamethod
      local _M = getmetatable(value)
      if _M and _M.__repr and not (hint == "raw") then
         local repr_len
         str, repr_len  = _M.__repr(value, c)
         len = repr_len or len
         assert(type(str) == "string")
      else
         str = tabulate(value)
      end
   elseif typica == "function" then
      local f_label = sub(str,11)
      f_label = sub(f_label,1,5) == "built"
                and f_label
                or "f:" .. sub(str, -6)
      local func_name = anti_G[value] or f_label
      len = #func_name
      str = c.func(func_name)
   elseif typica == "boolean" then
      str = value and c.truth(str) or c.falsehood(str)
   elseif typica == "string" then
      if value == "" then
         str = c.string('""')
         len = 2
      else
         str = c.string(str)
      end
   elseif typica == "number" then
      str = c.number(str)
   elseif typica == "nil" then
      str = c.nilness(str)
   elseif typica == "thread" then
      local coro_name = anti_G[value] and "coro:" .. anti_G[value]
                                      or  "coro:" .. sub(str, -6)
      len = #coro_name
      str = c.thread(coro_name)
   elseif typica == "userdata" then
      if anti_G[value] then
         str = c.userdata(anti_G[value])
         len = #anti_G[value]
      else
         local name = find(str, ":")
         if name then
            name = sub(str, 1, name - 1)
            len = #name
            str = c.userdata(name)
         else
            str = c.userdata(str)
         end
      end
   elseif typica == "cdata" then
      if anti_G[value] then
         str = c.cdata(anti_G[value])
         len = anti_G[value]
      else
         str = c.cdata(str)
      end
      str, len = c_data(value, str)
   end
   yield(str, len)
end

ts = function(...)
      local rep, len, done = wrap(ts_coro)(...)
      return rep, len, done
end

repr.ts = ts
#/lua

#!lua
function repr.ts_bw(value)
   c = C.no_color
   local to_string = ts(value)
   c = C.color
   return to_string
end
#/lua

#!lua
return repr
#/lua


