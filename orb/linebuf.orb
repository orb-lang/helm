* Linebuf


Rather than derive this from [[espalier's Phrase class][@/espalier/phrase]],
I'm going to port it.

The concepts are close, but different.

The main notes on where I'm going with this are under [[rainbuf][rainbuf]],
which will build from this class and is a generalization of it to support
complex text types.

I'm realizing that for clarity, a =linebuf= needs to be a line, period.  The
recursive container class is a =txtbuf=, and =rainbuf= enhances that and
also makes a =rainline= out of each =linebuf=.

linebufs are pretty dumb.  Smart enough to understand utf-8, smart enough to
do a bit of tokenizing on the side.

** Instance fields

- lines :  An array of string fragments
- dsps  :  An array of uint, each corresponds to the number of *bytes*
          in line[i].

- cursor :  An uint representing the number of bytes to be skipped over
            before executing =insert()=.  Not 1-1 the same as the column
            index of the tty cursor.

            cursor is moved by linebuf, ensuring we stay on codepoint
            boundaries.

- len  : sum of dsps.
#!lua
local sub = assert(string.sub)
#/lua

#!lua
local Linebuf = meta()
#/lua

#!lua

local function sum(dsps)
   local summa = 0
   for i = 1, #dsps do
      summa = summa + #dsps[i]
   end
   return summa
end

local concat = table.concat
function Linebuf.__tostring(linebuf)
   -- return concat(linebuf.line)
   -- patch to see tok boundaries
   local phrase = ""
   for _, tok in ipairs(linebuf.line) do
      phrase = phrase .. tok .. a.red("|")
   end
   return phrase
end
#/lua


** Linebuf.insert(linebuf, frag)

=insert= takes a fragment and carefully places it at the cursor point.

A =frag= is any kind of string that we won't want to break into pieces.

At first that means pasting long strings will cause syntax highlighting to
fall over. Harmlessly.  Once lexing is working we can trip an interrupt on
long input.

#!lua
-- a pass through for now
local function join(token, frag)
   if sub(token, -1) == " " and sub(frag, 1,1) ~= " " then
      return token, frag
   else
      return token .. frag, nil
   end
end

function Linebuf.insert(linebuf, frag)
   assert(linebuf.cursor, "linebuf must have cursor to insert")
   local line = linebuf.line
   -- end of line
   if cursor == len then
      local token, new_tok = join(line[#line], frag)
      line[#line] = token
      if new_tok then
         line[#line + 1] = new_tok
      end
      linebuf.len = sum(line)
      linebuf.cursor = linebuf.cursor + #frag
      return true
   end
   return false
end
#/lua


#!lua
local function new(cursor)
   local linebuf = meta(Linebuf)
   linebuf.back  =  false
   linebuf.len = 0 -- in bytes
   linebuf.line  = {""}
   -- Cursor may be nil
   linebuf.cursor = cursor
   return linebuf
end
#/lua

#!lua
return new
#/lua