* Zone


We need to get a lot more intelligent about how we write to the screen.

=Zone= is our metatable for handling these regions.  It's a tricky bit of
engineering and something I've never really done before.

The result we want is to have a single =modeS:refresh()= called at the end of
each action, which repaints the screen.  A Zone is either affected or it
isn't; if it is, we repaint the whole Zone, if not, nothing.

Zones have a =.z= axis, starting with 1, and monotonically increasing. I
expect to use ===.z == 2=== and leave it at that, for now, but we want to
be able to stack as well as tile, at some point.

We'll want a =zoneherder= of some sort to manage zone changes. Each Z plane
has to have non-overlapping Zones, and =1= should be completely tiled. The
zoneherder propagates adjustments.

Man. I should read some =awesomewm= source code, huh.

A paint message to a Zone will be a =rainbuf=.  There are a few tricky things
here, and ultimately we'll need a Unicode database to chase down all the
edges.  We need to engineer the system so that it can use that info when the
time comes.

The Zone needs to stay in its lane, basically, so we need to know when we've
reached the edges.  When we start to add mouse clicks, we have to know what
the mouse has targeted, so Zones will receive mouse messages also.

This is the next major push for =femto=, and when it's complete I'll be ready
to show it off.  It's a significant piece of engineering and I'm thinking I
need to shore up Orb a bit to get there.

Specifically, I need the ability to add a plantUML pipeline to the doc
generator, and maybe cut the apron strings with respect to Markdown and public
hosting.

This is a delicate point in the boot process.  =femto= needs to be able to
interact with an already-running bridge/luv process, as it stands the two
event loops will collide.  =orb= only runs an event loop with =orb serve= so
the next step with =femto= proper is to set it up locally to run as a =repl=
on plain ordinary =br= programs, so I can use all this carefully won tooling
on the other parts of the programme.


** Design

This file is going to have both the zone herder, called =modeS.zones=, and
a =Zone= metatable for handling single Zones.

The Zone herder will need to hold zones by name as well as by index, because
we want to repaint in a specific order (pre-sorting by =.z=) and pass messages
by name, so that we send a result to =modeS.zones.result=.

We'll need methods for reflowing, for creating, and for refreshing.  Each
=Zone= will have a =.touched= field and if it's flipped we repaint; if there's
an overlapping Zone of higher =z= we flip its touched bit as well.

A =Zone= needs an =onMouse= method that receives the whole packet and acts
accordingly.  The flow hands every input including parsed mouse messages to
the =modeselektor=, and some, particularly scrolls, are handled there. The
rest are assigned by the zone herder, which sould probably normalize the
action so, for example, a click in the upper left corner of a Zone is =1,1=.

Since the hard part is repainting, I'll start with reflow, and just hard-
switch the REPL to a 'reflow mode' that just draws characters to a screen,
then add a popup.

#!lua
assert(meta)
local Zone = meta {}

local Zoneherd = meta {}
#/lua


*** new

Makes a Zoneherd.  Borrows the modeselektor to get proportions, but returns
the zoneherd, which is assigned to its slot on the modeselector at the call
site for consistency.

#!lua
local function new(modeS, writer)
   local zoneherd = meta(Zoneherd)
   zoneherd.write = writer
   -- make Zones
   return zoneherd
end
#/lua

#!lua
return new
#/lua









